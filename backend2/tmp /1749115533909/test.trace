{"version":7,"type":"context-options","origin":"testRunner","browserName":"","options":{},"platform":"linux","wallTime":1748577880623,"monotonicTime":85414.34,"sdkLanguage":"javascript"}
{"type":"before","callId":"hook@1","startTime":85418.511,"class":"Test","method":"step","apiName":"Before Hooks","params":{},"stack":[]}
{"type":"before","callId":"hook@2","parentId":"hook@1","startTime":85419.577,"class":"Test","method":"step","apiName":"beforeEach hook","params":{},"stack":[{"file":"/home/neetoci/neeto-chat-web/playwright-tests/e2e/tests/integrations/slack.spec.ts","line":21,"column":8}]}
{"type":"before","callId":"fixture@3","parentId":"hook@2","startTime":85422.225,"class":"Test","method":"step","apiName":"fixture: i18n","params":{},"stack":[{"file":"/home/neetoci/neeto-chat-web/playwright-tests/e2e/fixtures/index.ts","line":8,"column":4}]}
{"type":"after","callId":"fixture@3","endTime":85946.476,"annotations":[]}
{"type":"before","callId":"fixture@4","parentId":"hook@2","startTime":85953.076,"class":"Test","method":"step","apiName":"fixture: browser","params":{},"stack":[]}
{"type":"before","callId":"pw:api@5","parentId":"fixture@4","startTime":85956.735,"class":"Test","method":"step","apiName":"browserType.launch","params":{"handleSIGINT":"false","args":"[--js-flags=--max-old-space-size=6144]","tracesDir":"/home/neetoci/neeto-chat-web/playwright-tests/test-results/.playwright-artifacts-5/traces","headless":"true","ignoreDefaultArgs":"undefined","ignoreAllDefaultArgs":"false","env":"undefined"},"stack":[]}
{"type":"after","callId":"pw:api@5","endTime":86217.548,"annotations":[]}
{"type":"after","callId":"fixture@4","endTime":86217.698,"annotations":[]}
{"type":"before","callId":"fixture@6","parentId":"hook@2","startTime":86218.247,"class":"Test","method":"step","apiName":"fixture: browser","params":{},"stack":[{"file":"/home/neetoci/neeto-chat-web/playwright-tests/node_modules/@bigbinary/neeto-playwright-commons/build/compiled/fixtures/stealth.js","line":4,"column":21}]}
{"type":"before","callId":"pw:api@7","parentId":"fixture@6","startTime":86219.91,"class":"Test","method":"step","apiName":"browser.close","params":{},"stack":[{"file":"/home/neetoci/neeto-chat-web/playwright-tests/node_modules/@bigbinary/neeto-playwright-commons/build/compiled/fixtures/stealth.js","line":6,"column":23,"function":"Object.browser"}]}
{"type":"after","callId":"pw:api@7","endTime":86347.94,"annotations":[]}
{"type":"before","callId":"pw:api@8","parentId":"fixture@6","startTime":86522.325,"class":"Test","method":"step","apiName":"browserType.launch","params":{"handleSIGINT":"false","args":"[--disable-blink-features=AutomationControlled]","tracesDir":"/home/neetoci/neeto-chat-web/playwright-tests/test-results/.playwright-artifacts-5/traces","headless":"true","defaultViewport":"null","ignoreDefaultArgs":"[--disable-extensions, --disable-default-apps, --disable-component-extensions-with-background-pages]","ignoreAllDefaultArgs":"false","env":"undefined"},"stack":[{"file":"/home/neetoci/neeto-chat-web/playwright-tests/node_modules/@bigbinary/neeto-playwright-commons/node_modules/playwright-extra/dist/index.esm.js","line":680,"column":54,"function":"Proxy.launch"}]}
{"type":"after","callId":"pw:api@8","endTime":86658.316,"annotations":[]}
{"type":"after","callId":"fixture@6","endTime":86659.076,"annotations":[]}
{"type":"before","callId":"fixture@9","parentId":"hook@2","startTime":86660.108,"class":"Test","method":"step","apiName":"fixture: context","params":{},"stack":[]}
{"type":"before","callId":"pw:api@10","parentId":"fixture@9","startTime":86713.331,"class":"Test","method":"step","apiName":"browser.newContext","params":{"acceptDownloads":"accept","bypassCSP":"false","colorScheme":"light","deviceScaleFactor":"1","geolocation":"Object","hasTouch":"false","ignoreHTTPSErrors":"false","isMobile":"false","javaScriptEnabled":"true","locale":"en-US","offline":"false","permissions":"[geolocation]","storageState":"Object","timezoneId":"Asia/Calcutta","userAgent":"Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/136.0.7103.25 Safari/537.36","viewport":"Object","baseURL":"https://cpt-chat-05300403215823.neetochat.net","serviceWorkers":"allow","recordVideo":"Object","noDefaultViewport":"false","extraHTTPHeaders":"undefined","recordHar":"undefined","reducedMotion":"undefined","forcedColors":"undefined","contrast":"undefined","clientCertificates":"undefined"},"stack":[{"file":"/home/neetoci/neeto-chat-web/playwright-tests/node_modules/@bigbinary/neeto-playwright-commons/node_modules/playwright-extra/dist/index.esm.js","line":805,"column":33,"function":"Browser.newContext"}]}
{"type":"after","callId":"pw:api@10","endTime":86851.341,"annotations":[]}
{"type":"after","callId":"fixture@9","endTime":86913.362,"annotations":[]}
{"type":"before","callId":"fixture@11","parentId":"hook@2","startTime":86914.135,"class":"Test","method":"step","apiName":"fixture: page","params":{},"stack":[]}
{"type":"before","callId":"pw:api@12","parentId":"fixture@11","startTime":86915.844,"class":"Test","method":"step","apiName":"browserContext.newPage","params":{},"stack":[{"file":"/home/neetoci/neeto-chat-web/playwright-tests/node_modules/@bigbinary/neeto-playwright-commons/node_modules/playwright-extra/dist/index.esm.js","line":778,"column":51,"function":"BrowserContext.newPage"}]}
{"type":"before","callId":"pw:api@13","parentId":"fixture@11","startTime":87014.419,"class":"Test","method":"step","apiName":"browser.newBrowserCDPSession","params":{},"stack":[{"file":"/home/neetoci/neeto-chat-web/playwright-tests/node_modules/@bigbinary/neeto-playwright-commons/node_modules/playwright-extra/dist/index.esm.js","line":166,"column":33,"function":"getBrowserCDPSession"}]}
{"type":"before","callId":"pw:api@14","parentId":"fixture@11","startTime":87015.984,"class":"Test","method":"step","apiName":"page.addInitScript","params":{"source":"(({ _utilsFns, _mainFunction, _args }) => {\n        // Add this point we cannot use our utililty functions as they're just strings, we need to materialize them first\n        const utils = Object.fromEntries(\n          Object.entries(_utilsFns).map(([key, value]) => [key, eval(value)]) // eslint-disable-line no-eval\n        )\n        utils.init()\n        return eval(_mainFunction)(utils, ..._args) // eslint-disable-line no-eval\n      })({\"_utilsFns\":{\"init\":\"() => {\\n  utils.preloadCache()\\n}\",\"stripProxyFromErrors\":\"(handler = {}) => {\\n  const newHandler = {\\n    setPrototypeOf: function (target, proto) {\\n      if (proto === null)\\n        throw new TypeError('Cannot convert object to primitive value')\\n      if (Object.getPrototypeOf(target) === Object.getPrototypeOf(proto)) {\\n        throw new TypeError('Cyclic __proto__ value')\\n      }\\n      return Reflect.setPrototypeOf(target, proto)\\n    }\\n  }\\n  // We wrap each trap in the handler in a try/catch and modify the error stack if they throw\\n  const traps = Object.getOwnPropertyNames(handler)\\n  traps.forEach(trap => {\\n    newHandler[trap] = function () {\\n      try {\\n        // Forward the call to the defined proxy handler\\n        return handler[trap].apply(this, arguments || [])\\n      } catch (err) {\\n        // Stack traces differ per browser, we only support chromium based ones currently\\n        if (!err || !err.stack || !err.stack.includes(`at `)) {\\n          throw err\\n        }\\n\\n        // When something throws within one of our traps the Proxy will show up in error stacks\\n        // An earlier implementation of this code would simply strip lines with a blacklist,\\n        // but it makes sense to be more surgical here and only remove lines related to our Proxy.\\n        // We try to use a known \\\"anchor\\\" line for that and strip it with everything above it.\\n        // If the anchor line cannot be found for some reason we fall back to our blacklist approach.\\n\\n        const stripWithBlacklist = (stack, stripFirstLine = true) => {\\n          const blacklist = [\\n            `at Reflect.${trap} `, // e.g. Reflect.get or Reflect.apply\\n            `at Object.${trap} `, // e.g. Object.get or Object.apply\\n            `at Object.newHandler.<computed> [as ${trap}] ` // caused by this very wrapper :-)\\n          ]\\n          return (\\n            err.stack\\n              .split('\\\\n')\\n              // Always remove the first (file) line in the stack (guaranteed to be our proxy)\\n              .filter((line, index) => !(index === 1 && stripFirstLine))\\n              // Check if the line starts with one of our blacklisted strings\\n              .filter(line => !blacklist.some(bl => line.trim().startsWith(bl)))\\n              .join('\\\\n')\\n          )\\n        }\\n\\n        const stripWithAnchor = (stack, anchor) => {\\n          const stackArr = stack.split('\\\\n')\\n          anchor = anchor || `at Object.newHandler.<computed> [as ${trap}] ` // Known first Proxy line in chromium\\n          const anchorIndex = stackArr.findIndex(line =>\\n            line.trim().startsWith(anchor)\\n          )\\n          if (anchorIndex === -1) {\\n            return false // 404, anchor not found\\n          }\\n          // Strip everything from the top until we reach the anchor line\\n          // Note: We're keeping the 1st line (zero index) as it's unrelated (e.g. `TypeError`)\\n          stackArr.splice(1, anchorIndex)\\n          return stackArr.join('\\\\n')\\n        }\\n\\n        // Special cases due to our nested toString proxies\\n        err.stack = err.stack.replace(\\n          'at Object.toString (',\\n          'at Function.toString ('\\n        )\\n        if ((err.stack || '').includes('at Function.toString (')) {\\n          err.stack = stripWithBlacklist(err.stack, false)\\n          throw err\\n        }\\n\\n        // Try using the anchor method, fallback to blacklist if necessary\\n        err.stack = stripWithAnchor(err.stack) || stripWithBlacklist(err.stack)\\n\\n        throw err // Re-throw our now sanitized error\\n      }\\n    }\\n  })\\n  return newHandler\\n}\",\"stripErrorWithAnchor\":\"(err, anchor) => {\\n  const stackArr = err.stack.split('\\\\n')\\n  const anchorIndex = stackArr.findIndex(line => line.trim().startsWith(anchor))\\n  if (anchorIndex === -1) {\\n    return err // 404, anchor not found\\n  }\\n  // Strip everything from the top until we reach the anchor line (remove anchor line as well)\\n  // Note: We're keeping the 1st line (zero index) as it's unrelated (e.g. `TypeError`)\\n  stackArr.splice(1, anchorIndex)\\n  err.stack = stackArr.join('\\\\n')\\n  return err\\n}\",\"replaceProperty\":\"(obj, propName, descriptorOverrides = {}) => {\\n  return Object.defineProperty(obj, propName, {\\n    // Copy over the existing descriptors (writable, enumerable, configurable, etc)\\n    ...(Object.getOwnPropertyDescriptor(obj, propName) || {}),\\n    // Add our overrides (e.g. value, get())\\n    ...descriptorOverrides\\n  })\\n}\",\"preloadCache\":\"() => {\\n  if (utils.cache) {\\n    return\\n  }\\n  utils.cache = {\\n    // Used in our proxies\\n    Reflect: {\\n      get: Reflect.get.bind(Reflect),\\n      apply: Reflect.apply.bind(Reflect)\\n    },\\n    // Used in `makeNativeString`\\n    nativeToStringStr: Function.toString + '' // => `function toString() { [native code] }`\\n  }\\n}\",\"makeNativeString\":\"(name = '') => {\\n  return utils.cache.nativeToStringStr.replace('toString', name || '')\\n}\",\"patchToString\":\"(obj, str = '') => {\\n  const handler = {\\n    apply: function (target, ctx) {\\n      // This fixes e.g. `HTMLMediaElement.prototype.canPlayType.toString + \\\"\\\"`\\n      if (ctx === Function.prototype.toString) {\\n        return utils.makeNativeString('toString')\\n      }\\n      // `toString` targeted at our proxied Object detected\\n      if (ctx === obj) {\\n        // We either return the optional string verbatim or derive the most desired result automatically\\n        return str || utils.makeNativeString(obj.name)\\n      }\\n      // Check if the toString protype of the context is the same as the global prototype,\\n      // if not indicates that we are doing a check across different windows., e.g. the iframeWithdirect` test case\\n      const hasSameProto = Object.getPrototypeOf(\\n        Function.prototype.toString\\n      ).isPrototypeOf(ctx.toString) // eslint-disable-line no-prototype-builtins\\n      if (!hasSameProto) {\\n        // Pass the call on to the local Function.prototype.toString instead\\n        return ctx.toString()\\n      }\\n      return target.call(ctx)\\n    }\\n  }\\n\\n  const toStringProxy = new Proxy(\\n    Function.prototype.toString,\\n    utils.stripProxyFromErrors(handler)\\n  )\\n  utils.replaceProperty(Function.prototype, 'toString', {\\n    value: toStringProxy\\n  })\\n}\",\"patchToStringNested\":\"(obj = {}) => {\\n  return utils.execRecursively(obj, ['function'], utils.patchToString)\\n}\",\"redirectToString\":\"(proxyObj, originalObj) => {\\n  const handler = {\\n    apply: function (target, ctx) {\\n      // This fixes e.g. `HTMLMediaElement.prototype.canPlayType.toString + \\\"\\\"`\\n      if (ctx === Function.prototype.toString) {\\n        return utils.makeNativeString('toString')\\n      }\\n\\n      // `toString` targeted at our proxied Object detected\\n      if (ctx === proxyObj) {\\n        const fallback = () =>\\n          originalObj && originalObj.name\\n            ? utils.makeNativeString(originalObj.name)\\n            : utils.makeNativeString(proxyObj.name)\\n\\n        // Return the toString representation of our original object if possible\\n        return originalObj + '' || fallback()\\n      }\\n\\n      if (typeof ctx === 'undefined' || ctx === null) {\\n        return target.call(ctx)\\n      }\\n\\n      // Check if the toString protype of the context is the same as the global prototype,\\n      // if not indicates that we are doing a check across different windows., e.g. the iframeWithdirect` test case\\n      const hasSameProto = Object.getPrototypeOf(\\n        Function.prototype.toString\\n      ).isPrototypeOf(ctx.toString) // eslint-disable-line no-prototype-builtins\\n      if (!hasSameProto) {\\n        // Pass the call on to the local Function.prototype.toString instead\\n        return ctx.toString()\\n      }\\n\\n      return target.call(ctx)\\n    }\\n  }\\n\\n  const toStringProxy = new Proxy(\\n    Function.prototype.toString,\\n    utils.stripProxyFromErrors(handler)\\n  )\\n  utils.replaceProperty(Function.prototype, 'toString', {\\n    value: toStringProxy\\n  })\\n}\",\"replaceWithProxy\":\"(obj, propName, handler) => {\\n  const originalObj = obj[propName]\\n  const proxyObj = new Proxy(obj[propName], utils.stripProxyFromErrors(handler))\\n\\n  utils.replaceProperty(obj, propName, { value: proxyObj })\\n  utils.redirectToString(proxyObj, originalObj)\\n\\n  return true\\n}\",\"replaceGetterWithProxy\":\"(obj, propName, handler) => {\\n  const fn = Object.getOwnPropertyDescriptor(obj, propName).get\\n  const fnStr = fn.toString() // special getter function string\\n  const proxyObj = new Proxy(fn, utils.stripProxyFromErrors(handler))\\n\\n  utils.replaceProperty(obj, propName, { get: proxyObj })\\n  utils.patchToString(proxyObj, fnStr)\\n\\n  return true\\n}\",\"replaceGetterSetter\":\"(obj, propName, handlerGetterSetter) => {\\n  const ownPropertyDescriptor = Object.getOwnPropertyDescriptor(obj, propName)\\n  const handler = { ...ownPropertyDescriptor }\\n\\n  if (handlerGetterSetter.get !== undefined) {\\n    const nativeFn = ownPropertyDescriptor.get\\n    handler.get = function() {\\n      return handlerGetterSetter.get.call(this, nativeFn.bind(this))\\n    }\\n    utils.redirectToString(handler.get, nativeFn)\\n  }\\n\\n  if (handlerGetterSetter.set !== undefined) {\\n    const nativeFn = ownPropertyDescriptor.set\\n    handler.set = function(newValue) {\\n      handlerGetterSetter.set.call(this, newValue, nativeFn.bind(this))\\n    }\\n    utils.redirectToString(handler.set, nativeFn)\\n  }\\n\\n  Object.defineProperty(obj, propName, handler)\\n}\",\"mockWithProxy\":\"(obj, propName, pseudoTarget, handler) => {\\n  const proxyObj = new Proxy(pseudoTarget, utils.stripProxyFromErrors(handler))\\n\\n  utils.replaceProperty(obj, propName, { value: proxyObj })\\n  utils.patchToString(proxyObj)\\n\\n  return true\\n}\",\"createProxy\":\"(pseudoTarget, handler) => {\\n  const proxyObj = new Proxy(pseudoTarget, utils.stripProxyFromErrors(handler))\\n  utils.patchToString(proxyObj)\\n\\n  return proxyObj\\n}\",\"splitObjPath\":\"objPath => ({\\n  // Remove last dot entry (property) ==> `HTMLMediaElement.prototype`\\n  objName: objPath.split('.').slice(0, -1).join('.'),\\n  // Extract last dot entry ==> `canPlayType`\\n  propName: objPath.split('.').slice(-1)[0]\\n})\",\"replaceObjPathWithProxy\":\"(objPath, handler) => {\\n  const { objName, propName } = utils.splitObjPath(objPath)\\n  const obj = eval(objName) // eslint-disable-line no-eval\\n  return utils.replaceWithProxy(obj, propName, handler)\\n}\",\"execRecursively\":\"(obj = {}, typeFilter = [], fn) => {\\n  function recurse(obj) {\\n    for (const key in obj) {\\n      if (obj[key] === undefined) {\\n        continue\\n      }\\n      if (obj[key] && typeof obj[key] === 'object') {\\n        recurse(obj[key])\\n      } else {\\n        if (obj[key] && typeFilter.includes(typeof obj[key])) {\\n          fn.call(this, obj[key])\\n        }\\n      }\\n    }\\n  }\\n  recurse(obj)\\n  return obj\\n}\",\"stringifyFns\":\"(fnObj = { hello: () => 'world' }) => {\\n  // Object.fromEntries() ponyfill (in 6 lines) - supported only in Node v12+, modern browsers are fine\\n  // https://github.com/feross/fromentries\\n  function fromEntries(iterable) {\\n    return [...iterable].reduce((obj, [key, val]) => {\\n      obj[key] = val\\n      return obj\\n    }, {})\\n  }\\n  return (Object.fromEntries || fromEntries)(\\n    Object.entries(fnObj)\\n      .filter(([key, value]) => typeof value === 'function')\\n      .map(([key, value]) => [key, value.toString()]) // eslint-disable-line no-eval\\n  )\\n}\",\"materializeFns\":\"(fnStrObj = { hello: \\\"() => 'world'\\\" }) => {\\n  return Object.fromEntries(\\n    Object.entries(fnStrObj).map(([key, value]) => {\\n      if (value.startsWith('function')) {\\n        // some trickery is needed to make oldschool functions work :-)\\n        return [key, eval(`() => ${value}`)()] // eslint-disable-line no-eval\\n      } else {\\n        // arrow functions just work\\n        return [key, eval(value)] // eslint-disable-line no-eval\\n      }\\n    })\\n  )\\n}\",\"makeHandler\":\"() => ({\\n  // Used by simple `navigator` getter evasions\\n  getterValue: value => ({\\n    apply(target, ctx, args) {\\n      // Let's fetch the value first, to trigger and escalate potential errors\\n      // Illegal invocations like `navigator.__proto__.vendor` will throw here\\n      utils.cache.Reflect.apply(...arguments)\\n      return value\\n    }\\n  })\\n})\",\"arrayEquals\":\"(array1, array2) => {\\n  if (array1.length !== array2.length) {\\n    return false\\n  }\\n  for (let i = 0; i < array1.length; ++i) {\\n    if (array1[i] !== array2[i]) {\\n      return false\\n    }\\n  }\\n  return true\\n}\",\"memoize\":\"fn => {\\n  const cache = []\\n  return function(...args) {\\n    if (!cache.some(c => utils.arrayEquals(c.key, args))) {\\n      cache.push({ key: args, value: fn.apply(this, args) })\\n    }\\n    return cache.find(c => utils.arrayEquals(c.key, args)).value\\n  }\\n}\"},\"_mainFunction\":\"utils => {\\n      if (!window.chrome) {\\n        // Use the exact property descriptor found in headful Chrome\\n        // fetch it via `Object.getOwnPropertyDescriptor(window, 'chrome')`\\n        Object.defineProperty(window, 'chrome', {\\n          writable: true,\\n          enumerable: true,\\n          configurable: false, // note!\\n          value: {} // We'll extend that later\\n        })\\n      }\\n\\n      // That means we're running headful and don't need to mock anything\\n      if ('app' in window.chrome) {\\n        return // Nothing to do here\\n      }\\n\\n      const makeError = {\\n        ErrorInInvocation: fn => {\\n          const err = new TypeError(`Error in invocation of app.${fn}()`)\\n          return utils.stripErrorWithAnchor(\\n            err,\\n            `at ${fn} (eval at <anonymous>`\\n          )\\n        }\\n      }\\n\\n      // There's a some static data in that property which doesn't seem to change,\\n      // we should periodically check for updates: `JSON.stringify(window.app, null, 2)`\\n      const STATIC_DATA = JSON.parse(\\n        `\\n{\\n  \\\"isInstalled\\\": false,\\n  \\\"InstallState\\\": {\\n    \\\"DISABLED\\\": \\\"disabled\\\",\\n    \\\"INSTALLED\\\": \\\"installed\\\",\\n    \\\"NOT_INSTALLED\\\": \\\"not_installed\\\"\\n  },\\n  \\\"RunningState\\\": {\\n    \\\"CANNOT_RUN\\\": \\\"cannot_run\\\",\\n    \\\"READY_TO_RUN\\\": \\\"ready_to_run\\\",\\n    \\\"RUNNING\\\": \\\"running\\\"\\n  }\\n}\\n        `.trim()\\n      )\\n\\n      window.chrome.app = {\\n        ...STATIC_DATA,\\n\\n        get isInstalled() {\\n          return false\\n        },\\n\\n        getDetails: function getDetails() {\\n          if (arguments.length) {\\n            throw makeError.ErrorInInvocation(`getDetails`)\\n          }\\n          return null\\n        },\\n        getIsInstalled: function getDetails() {\\n          if (arguments.length) {\\n            throw makeError.ErrorInInvocation(`getIsInstalled`)\\n          }\\n          return false\\n        },\\n        runningState: function getDetails() {\\n          if (arguments.length) {\\n            throw makeError.ErrorInInvocation(`runningState`)\\n          }\\n          return 'cannot_run'\\n        }\\n      }\\n      utils.patchToStringNested(window.chrome.app)\\n    }\",\"_args\":[]})"},"stack":[{"file":"/home/neetoci/neeto-chat-web/playwright-tests/node_modules/@bigbinary/neeto-playwright-commons/node_modules/playwright-extra/dist/index.esm.js","line":230,"column":32,"function":"Proxy.<anonymous>"}]}
{"type":"before","callId":"pw:api@15","parentId":"fixture@11","startTime":87016.713,"class":"Test","method":"step","apiName":"page.addInitScript","params":{"source":"(({ _utilsFns, _mainFunction, _args }) => {\n        // Add this point we cannot use our utililty functions as they're just strings, we need to materialize them first\n        const utils = Object.fromEntries(\n          Object.entries(_utilsFns).map(([key, value]) => [key, eval(value)]) // eslint-disable-line no-eval\n        )\n        utils.init()\n        return eval(_mainFunction)(utils, ..._args) // eslint-disable-line no-eval\n      })({\"_utilsFns\":{\"init\":\"() => {\\n  utils.preloadCache()\\n}\",\"stripProxyFromErrors\":\"(handler = {}) => {\\n  const newHandler = {\\n    setPrototypeOf: function (target, proto) {\\n      if (proto === null)\\n        throw new TypeError('Cannot convert object to primitive value')\\n      if (Object.getPrototypeOf(target) === Object.getPrototypeOf(proto)) {\\n        throw new TypeError('Cyclic __proto__ value')\\n      }\\n      return Reflect.setPrototypeOf(target, proto)\\n    }\\n  }\\n  // We wrap each trap in the handler in a try/catch and modify the error stack if they throw\\n  const traps = Object.getOwnPropertyNames(handler)\\n  traps.forEach(trap => {\\n    newHandler[trap] = function () {\\n      try {\\n        // Forward the call to the defined proxy handler\\n        return handler[trap].apply(this, arguments || [])\\n      } catch (err) {\\n        // Stack traces differ per browser, we only support chromium based ones currently\\n        if (!err || !err.stack || !err.stack.includes(`at `)) {\\n          throw err\\n        }\\n\\n        // When something throws within one of our traps the Proxy will show up in error stacks\\n        // An earlier implementation of this code would simply strip lines with a blacklist,\\n        // but it makes sense to be more surgical here and only remove lines related to our Proxy.\\n        // We try to use a known \\\"anchor\\\" line for that and strip it with everything above it.\\n        // If the anchor line cannot be found for some reason we fall back to our blacklist approach.\\n\\n        const stripWithBlacklist = (stack, stripFirstLine = true) => {\\n          const blacklist = [\\n            `at Reflect.${trap} `, // e.g. Reflect.get or Reflect.apply\\n            `at Object.${trap} `, // e.g. Object.get or Object.apply\\n            `at Object.newHandler.<computed> [as ${trap}] ` // caused by this very wrapper :-)\\n          ]\\n          return (\\n            err.stack\\n              .split('\\\\n')\\n              // Always remove the first (file) line in the stack (guaranteed to be our proxy)\\n              .filter((line, index) => !(index === 1 && stripFirstLine))\\n              // Check if the line starts with one of our blacklisted strings\\n              .filter(line => !blacklist.some(bl => line.trim().startsWith(bl)))\\n              .join('\\\\n')\\n          )\\n        }\\n\\n        const stripWithAnchor = (stack, anchor) => {\\n          const stackArr = stack.split('\\\\n')\\n          anchor = anchor || `at Object.newHandler.<computed> [as ${trap}] ` // Known first Proxy line in chromium\\n          const anchorIndex = stackArr.findIndex(line =>\\n            line.trim().startsWith(anchor)\\n          )\\n          if (anchorIndex === -1) {\\n            return false // 404, anchor not found\\n          }\\n          // Strip everything from the top until we reach the anchor line\\n          // Note: We're keeping the 1st line (zero index) as it's unrelated (e.g. `TypeError`)\\n          stackArr.splice(1, anchorIndex)\\n          return stackArr.join('\\\\n')\\n        }\\n\\n        // Special cases due to our nested toString proxies\\n        err.stack = err.stack.replace(\\n          'at Object.toString (',\\n          'at Function.toString ('\\n        )\\n        if ((err.stack || '').includes('at Function.toString (')) {\\n          err.stack = stripWithBlacklist(err.stack, false)\\n          throw err\\n        }\\n\\n        // Try using the anchor method, fallback to blacklist if necessary\\n        err.stack = stripWithAnchor(err.stack) || stripWithBlacklist(err.stack)\\n\\n        throw err // Re-throw our now sanitized error\\n      }\\n    }\\n  })\\n  return newHandler\\n}\",\"stripErrorWithAnchor\":\"(err, anchor) => {\\n  const stackArr = err.stack.split('\\\\n')\\n  const anchorIndex = stackArr.findIndex(line => line.trim().startsWith(anchor))\\n  if (anchorIndex === -1) {\\n    return err // 404, anchor not found\\n  }\\n  // Strip everything from the top until we reach the anchor line (remove anchor line as well)\\n  // Note: We're keeping the 1st line (zero index) as it's unrelated (e.g. `TypeError`)\\n  stackArr.splice(1, anchorIndex)\\n  err.stack = stackArr.join('\\\\n')\\n  return err\\n}\",\"replaceProperty\":\"(obj, propName, descriptorOverrides = {}) => {\\n  return Object.defineProperty(obj, propName, {\\n    // Copy over the existing descriptors (writable, enumerable, configurable, etc)\\n    ...(Object.getOwnPropertyDescriptor(obj, propName) || {}),\\n    // Add our overrides (e.g. value, get())\\n    ...descriptorOverrides\\n  })\\n}\",\"preloadCache\":\"() => {\\n  if (utils.cache) {\\n    return\\n  }\\n  utils.cache = {\\n    // Used in our proxies\\n    Reflect: {\\n      get: Reflect.get.bind(Reflect),\\n      apply: Reflect.apply.bind(Reflect)\\n    },\\n    // Used in `makeNativeString`\\n    nativeToStringStr: Function.toString + '' // => `function toString() { [native code] }`\\n  }\\n}\",\"makeNativeString\":\"(name = '') => {\\n  return utils.cache.nativeToStringStr.replace('toString', name || '')\\n}\",\"patchToString\":\"(obj, str = '') => {\\n  const handler = {\\n    apply: function (target, ctx) {\\n      // This fixes e.g. `HTMLMediaElement.prototype.canPlayType.toString + \\\"\\\"`\\n      if (ctx === Function.prototype.toString) {\\n        return utils.makeNativeString('toString')\\n      }\\n      // `toString` targeted at our proxied Object detected\\n      if (ctx === obj) {\\n        // We either return the optional string verbatim or derive the most desired result automatically\\n        return str || utils.makeNativeString(obj.name)\\n      }\\n      // Check if the toString protype of the context is the same as the global prototype,\\n      // if not indicates that we are doing a check across different windows., e.g. the iframeWithdirect` test case\\n      const hasSameProto = Object.getPrototypeOf(\\n        Function.prototype.toString\\n      ).isPrototypeOf(ctx.toString) // eslint-disable-line no-prototype-builtins\\n      if (!hasSameProto) {\\n        // Pass the call on to the local Function.prototype.toString instead\\n        return ctx.toString()\\n      }\\n      return target.call(ctx)\\n    }\\n  }\\n\\n  const toStringProxy = new Proxy(\\n    Function.prototype.toString,\\n    utils.stripProxyFromErrors(handler)\\n  )\\n  utils.replaceProperty(Function.prototype, 'toString', {\\n    value: toStringProxy\\n  })\\n}\",\"patchToStringNested\":\"(obj = {}) => {\\n  return utils.execRecursively(obj, ['function'], utils.patchToString)\\n}\",\"redirectToString\":\"(proxyObj, originalObj) => {\\n  const handler = {\\n    apply: function (target, ctx) {\\n      // This fixes e.g. `HTMLMediaElement.prototype.canPlayType.toString + \\\"\\\"`\\n      if (ctx === Function.prototype.toString) {\\n        return utils.makeNativeString('toString')\\n      }\\n\\n      // `toString` targeted at our proxied Object detected\\n      if (ctx === proxyObj) {\\n        const fallback = () =>\\n          originalObj && originalObj.name\\n            ? utils.makeNativeString(originalObj.name)\\n            : utils.makeNativeString(proxyObj.name)\\n\\n        // Return the toString representation of our original object if possible\\n        return originalObj + '' || fallback()\\n      }\\n\\n      if (typeof ctx === 'undefined' || ctx === null) {\\n        return target.call(ctx)\\n      }\\n\\n      // Check if the toString protype of the context is the same as the global prototype,\\n      // if not indicates that we are doing a check across different windows., e.g. the iframeWithdirect` test case\\n      const hasSameProto = Object.getPrototypeOf(\\n        Function.prototype.toString\\n      ).isPrototypeOf(ctx.toString) // eslint-disable-line no-prototype-builtins\\n      if (!hasSameProto) {\\n        // Pass the call on to the local Function.prototype.toString instead\\n        return ctx.toString()\\n      }\\n\\n      return target.call(ctx)\\n    }\\n  }\\n\\n  const toStringProxy = new Proxy(\\n    Function.prototype.toString,\\n    utils.stripProxyFromErrors(handler)\\n  )\\n  utils.replaceProperty(Function.prototype, 'toString', {\\n    value: toStringProxy\\n  })\\n}\",\"replaceWithProxy\":\"(obj, propName, handler) => {\\n  const originalObj = obj[propName]\\n  const proxyObj = new Proxy(obj[propName], utils.stripProxyFromErrors(handler))\\n\\n  utils.replaceProperty(obj, propName, { value: proxyObj })\\n  utils.redirectToString(proxyObj, originalObj)\\n\\n  return true\\n}\",\"replaceGetterWithProxy\":\"(obj, propName, handler) => {\\n  const fn = Object.getOwnPropertyDescriptor(obj, propName).get\\n  const fnStr = fn.toString() // special getter function string\\n  const proxyObj = new Proxy(fn, utils.stripProxyFromErrors(handler))\\n\\n  utils.replaceProperty(obj, propName, { get: proxyObj })\\n  utils.patchToString(proxyObj, fnStr)\\n\\n  return true\\n}\",\"replaceGetterSetter\":\"(obj, propName, handlerGetterSetter) => {\\n  const ownPropertyDescriptor = Object.getOwnPropertyDescriptor(obj, propName)\\n  const handler = { ...ownPropertyDescriptor }\\n\\n  if (handlerGetterSetter.get !== undefined) {\\n    const nativeFn = ownPropertyDescriptor.get\\n    handler.get = function() {\\n      return handlerGetterSetter.get.call(this, nativeFn.bind(this))\\n    }\\n    utils.redirectToString(handler.get, nativeFn)\\n  }\\n\\n  if (handlerGetterSetter.set !== undefined) {\\n    const nativeFn = ownPropertyDescriptor.set\\n    handler.set = function(newValue) {\\n      handlerGetterSetter.set.call(this, newValue, nativeFn.bind(this))\\n    }\\n    utils.redirectToString(handler.set, nativeFn)\\n  }\\n\\n  Object.defineProperty(obj, propName, handler)\\n}\",\"mockWithProxy\":\"(obj, propName, pseudoTarget, handler) => {\\n  const proxyObj = new Proxy(pseudoTarget, utils.stripProxyFromErrors(handler))\\n\\n  utils.replaceProperty(obj, propName, { value: proxyObj })\\n  utils.patchToString(proxyObj)\\n\\n  return true\\n}\",\"createProxy\":\"(pseudoTarget, handler) => {\\n  const proxyObj = new Proxy(pseudoTarget, utils.stripProxyFromErrors(handler))\\n  utils.patchToString(proxyObj)\\n\\n  return proxyObj\\n}\",\"splitObjPath\":\"objPath => ({\\n  // Remove last dot entry (property) ==> `HTMLMediaElement.prototype`\\n  objName: objPath.split('.').slice(0, -1).join('.'),\\n  // Extract last dot entry ==> `canPlayType`\\n  propName: objPath.split('.').slice(-1)[0]\\n})\",\"replaceObjPathWithProxy\":\"(objPath, handler) => {\\n  const { objName, propName } = utils.splitObjPath(objPath)\\n  const obj = eval(objName) // eslint-disable-line no-eval\\n  return utils.replaceWithProxy(obj, propName, handler)\\n}\",\"execRecursively\":\"(obj = {}, typeFilter = [], fn) => {\\n  function recurse(obj) {\\n    for (const key in obj) {\\n      if (obj[key] === undefined) {\\n        continue\\n      }\\n      if (obj[key] && typeof obj[key] === 'object') {\\n        recurse(obj[key])\\n      } else {\\n        if (obj[key] && typeFilter.includes(typeof obj[key])) {\\n          fn.call(this, obj[key])\\n        }\\n      }\\n    }\\n  }\\n  recurse(obj)\\n  return obj\\n}\",\"stringifyFns\":\"(fnObj = { hello: () => 'world' }) => {\\n  // Object.fromEntries() ponyfill (in 6 lines) - supported only in Node v12+, modern browsers are fine\\n  // https://github.com/feross/fromentries\\n  function fromEntries(iterable) {\\n    return [...iterable].reduce((obj, [key, val]) => {\\n      obj[key] = val\\n      return obj\\n    }, {})\\n  }\\n  return (Object.fromEntries || fromEntries)(\\n    Object.entries(fnObj)\\n      .filter(([key, value]) => typeof value === 'function')\\n      .map(([key, value]) => [key, value.toString()]) // eslint-disable-line no-eval\\n  )\\n}\",\"materializeFns\":\"(fnStrObj = { hello: \\\"() => 'world'\\\" }) => {\\n  return Object.fromEntries(\\n    Object.entries(fnStrObj).map(([key, value]) => {\\n      if (value.startsWith('function')) {\\n        // some trickery is needed to make oldschool functions work :-)\\n        return [key, eval(`() => ${value}`)()] // eslint-disable-line no-eval\\n      } else {\\n        // arrow functions just work\\n        return [key, eval(value)] // eslint-disable-line no-eval\\n      }\\n    })\\n  )\\n}\",\"makeHandler\":\"() => ({\\n  // Used by simple `navigator` getter evasions\\n  getterValue: value => ({\\n    apply(target, ctx, args) {\\n      // Let's fetch the value first, to trigger and escalate potential errors\\n      // Illegal invocations like `navigator.__proto__.vendor` will throw here\\n      utils.cache.Reflect.apply(...arguments)\\n      return value\\n    }\\n  })\\n})\",\"arrayEquals\":\"(array1, array2) => {\\n  if (array1.length !== array2.length) {\\n    return false\\n  }\\n  for (let i = 0; i < array1.length; ++i) {\\n    if (array1[i] !== array2[i]) {\\n      return false\\n    }\\n  }\\n  return true\\n}\",\"memoize\":\"fn => {\\n  const cache = []\\n  return function(...args) {\\n    if (!cache.some(c => utils.arrayEquals(c.key, args))) {\\n      cache.push({ key: args, value: fn.apply(this, args) })\\n    }\\n    return cache.find(c => utils.arrayEquals(c.key, args)).value\\n  }\\n}\"},\"_mainFunction\":\"utils => {\\n      if (!window.chrome) {\\n        // Use the exact property descriptor found in headful Chrome\\n        // fetch it via `Object.getOwnPropertyDescriptor(window, 'chrome')`\\n        Object.defineProperty(window, 'chrome', {\\n          writable: true,\\n          enumerable: true,\\n          configurable: false, // note!\\n          value: {} // We'll extend that later\\n        })\\n      }\\n\\n      // That means we're running headful and don't need to mock anything\\n      if ('csi' in window.chrome) {\\n        return // Nothing to do here\\n      }\\n\\n      // Check that the Navigation Timing API v1 is available, we need that\\n      if (!window.performance || !window.performance.timing) {\\n        return\\n      }\\n\\n      const { timing } = window.performance\\n\\n      window.chrome.csi = function() {\\n        return {\\n          onloadT: timing.domContentLoadedEventEnd,\\n          startE: timing.navigationStart,\\n          pageT: Date.now() - timing.navigationStart,\\n          tran: 15 // Transition type or something\\n        }\\n      }\\n      utils.patchToString(window.chrome.csi)\\n    }\",\"_args\":[]})"},"stack":[{"file":"/home/neetoci/neeto-chat-web/playwright-tests/node_modules/@bigbinary/neeto-playwright-commons/node_modules/playwright-extra/dist/index.esm.js","line":230,"column":32,"function":"Proxy.<anonymous>"}]}
{"type":"before","callId":"pw:api@16","parentId":"fixture@11","startTime":87017.36,"class":"Test","method":"step","apiName":"page.addInitScript","params":{"source":"(({ _utilsFns, _mainFunction, _args }) => {\n        // Add this point we cannot use our utililty functions as they're just strings, we need to materialize them first\n        const utils = Object.fromEntries(\n          Object.entries(_utilsFns).map(([key, value]) => [key, eval(value)]) // eslint-disable-line no-eval\n        )\n        utils.init()\n        return eval(_mainFunction)(utils, ..._args) // eslint-disable-line no-eval\n      })({\"_utilsFns\":{\"init\":\"() => {\\n  utils.preloadCache()\\n}\",\"stripProxyFromErrors\":\"(handler = {}) => {\\n  const newHandler = {\\n    setPrototypeOf: function (target, proto) {\\n      if (proto === null)\\n        throw new TypeError('Cannot convert object to primitive value')\\n      if (Object.getPrototypeOf(target) === Object.getPrototypeOf(proto)) {\\n        throw new TypeError('Cyclic __proto__ value')\\n      }\\n      return Reflect.setPrototypeOf(target, proto)\\n    }\\n  }\\n  // We wrap each trap in the handler in a try/catch and modify the error stack if they throw\\n  const traps = Object.getOwnPropertyNames(handler)\\n  traps.forEach(trap => {\\n    newHandler[trap] = function () {\\n      try {\\n        // Forward the call to the defined proxy handler\\n        return handler[trap].apply(this, arguments || [])\\n      } catch (err) {\\n        // Stack traces differ per browser, we only support chromium based ones currently\\n        if (!err || !err.stack || !err.stack.includes(`at `)) {\\n          throw err\\n        }\\n\\n        // When something throws within one of our traps the Proxy will show up in error stacks\\n        // An earlier implementation of this code would simply strip lines with a blacklist,\\n        // but it makes sense to be more surgical here and only remove lines related to our Proxy.\\n        // We try to use a known \\\"anchor\\\" line for that and strip it with everything above it.\\n        // If the anchor line cannot be found for some reason we fall back to our blacklist approach.\\n\\n        const stripWithBlacklist = (stack, stripFirstLine = true) => {\\n          const blacklist = [\\n            `at Reflect.${trap} `, // e.g. Reflect.get or Reflect.apply\\n            `at Object.${trap} `, // e.g. Object.get or Object.apply\\n            `at Object.newHandler.<computed> [as ${trap}] ` // caused by this very wrapper :-)\\n          ]\\n          return (\\n            err.stack\\n              .split('\\\\n')\\n              // Always remove the first (file) line in the stack (guaranteed to be our proxy)\\n              .filter((line, index) => !(index === 1 && stripFirstLine))\\n              // Check if the line starts with one of our blacklisted strings\\n              .filter(line => !blacklist.some(bl => line.trim().startsWith(bl)))\\n              .join('\\\\n')\\n          )\\n        }\\n\\n        const stripWithAnchor = (stack, anchor) => {\\n          const stackArr = stack.split('\\\\n')\\n          anchor = anchor || `at Object.newHandler.<computed> [as ${trap}] ` // Known first Proxy line in chromium\\n          const anchorIndex = stackArr.findIndex(line =>\\n            line.trim().startsWith(anchor)\\n          )\\n          if (anchorIndex === -1) {\\n            return false // 404, anchor not found\\n          }\\n          // Strip everything from the top until we reach the anchor line\\n          // Note: We're keeping the 1st line (zero index) as it's unrelated (e.g. `TypeError`)\\n          stackArr.splice(1, anchorIndex)\\n          return stackArr.join('\\\\n')\\n        }\\n\\n        // Special cases due to our nested toString proxies\\n        err.stack = err.stack.replace(\\n          'at Object.toString (',\\n          'at Function.toString ('\\n        )\\n        if ((err.stack || '').includes('at Function.toString (')) {\\n          err.stack = stripWithBlacklist(err.stack, false)\\n          throw err\\n        }\\n\\n        // Try using the anchor method, fallback to blacklist if necessary\\n        err.stack = stripWithAnchor(err.stack) || stripWithBlacklist(err.stack)\\n\\n        throw err // Re-throw our now sanitized error\\n      }\\n    }\\n  })\\n  return newHandler\\n}\",\"stripErrorWithAnchor\":\"(err, anchor) => {\\n  const stackArr = err.stack.split('\\\\n')\\n  const anchorIndex = stackArr.findIndex(line => line.trim().startsWith(anchor))\\n  if (anchorIndex === -1) {\\n    return err // 404, anchor not found\\n  }\\n  // Strip everything from the top until we reach the anchor line (remove anchor line as well)\\n  // Note: We're keeping the 1st line (zero index) as it's unrelated (e.g. `TypeError`)\\n  stackArr.splice(1, anchorIndex)\\n  err.stack = stackArr.join('\\\\n')\\n  return err\\n}\",\"replaceProperty\":\"(obj, propName, descriptorOverrides = {}) => {\\n  return Object.defineProperty(obj, propName, {\\n    // Copy over the existing descriptors (writable, enumerable, configurable, etc)\\n    ...(Object.getOwnPropertyDescriptor(obj, propName) || {}),\\n    // Add our overrides (e.g. value, get())\\n    ...descriptorOverrides\\n  })\\n}\",\"preloadCache\":\"() => {\\n  if (utils.cache) {\\n    return\\n  }\\n  utils.cache = {\\n    // Used in our proxies\\n    Reflect: {\\n      get: Reflect.get.bind(Reflect),\\n      apply: Reflect.apply.bind(Reflect)\\n    },\\n    // Used in `makeNativeString`\\n    nativeToStringStr: Function.toString + '' // => `function toString() { [native code] }`\\n  }\\n}\",\"makeNativeString\":\"(name = '') => {\\n  return utils.cache.nativeToStringStr.replace('toString', name || '')\\n}\",\"patchToString\":\"(obj, str = '') => {\\n  const handler = {\\n    apply: function (target, ctx) {\\n      // This fixes e.g. `HTMLMediaElement.prototype.canPlayType.toString + \\\"\\\"`\\n      if (ctx === Function.prototype.toString) {\\n        return utils.makeNativeString('toString')\\n      }\\n      // `toString` targeted at our proxied Object detected\\n      if (ctx === obj) {\\n        // We either return the optional string verbatim or derive the most desired result automatically\\n        return str || utils.makeNativeString(obj.name)\\n      }\\n      // Check if the toString protype of the context is the same as the global prototype,\\n      // if not indicates that we are doing a check across different windows., e.g. the iframeWithdirect` test case\\n      const hasSameProto = Object.getPrototypeOf(\\n        Function.prototype.toString\\n      ).isPrototypeOf(ctx.toString) // eslint-disable-line no-prototype-builtins\\n      if (!hasSameProto) {\\n        // Pass the call on to the local Function.prototype.toString instead\\n        return ctx.toString()\\n      }\\n      return target.call(ctx)\\n    }\\n  }\\n\\n  const toStringProxy = new Proxy(\\n    Function.prototype.toString,\\n    utils.stripProxyFromErrors(handler)\\n  )\\n  utils.replaceProperty(Function.prototype, 'toString', {\\n    value: toStringProxy\\n  })\\n}\",\"patchToStringNested\":\"(obj = {}) => {\\n  return utils.execRecursively(obj, ['function'], utils.patchToString)\\n}\",\"redirectToString\":\"(proxyObj, originalObj) => {\\n  const handler = {\\n    apply: function (target, ctx) {\\n      // This fixes e.g. `HTMLMediaElement.prototype.canPlayType.toString + \\\"\\\"`\\n      if (ctx === Function.prototype.toString) {\\n        return utils.makeNativeString('toString')\\n      }\\n\\n      // `toString` targeted at our proxied Object detected\\n      if (ctx === proxyObj) {\\n        const fallback = () =>\\n          originalObj && originalObj.name\\n            ? utils.makeNativeString(originalObj.name)\\n            : utils.makeNativeString(proxyObj.name)\\n\\n        // Return the toString representation of our original object if possible\\n        return originalObj + '' || fallback()\\n      }\\n\\n      if (typeof ctx === 'undefined' || ctx === null) {\\n        return target.call(ctx)\\n      }\\n\\n      // Check if the toString protype of the context is the same as the global prototype,\\n      // if not indicates that we are doing a check across different windows., e.g. the iframeWithdirect` test case\\n      const hasSameProto = Object.getPrototypeOf(\\n        Function.prototype.toString\\n      ).isPrototypeOf(ctx.toString) // eslint-disable-line no-prototype-builtins\\n      if (!hasSameProto) {\\n        // Pass the call on to the local Function.prototype.toString instead\\n        return ctx.toString()\\n      }\\n\\n      return target.call(ctx)\\n    }\\n  }\\n\\n  const toStringProxy = new Proxy(\\n    Function.prototype.toString,\\n    utils.stripProxyFromErrors(handler)\\n  )\\n  utils.replaceProperty(Function.prototype, 'toString', {\\n    value: toStringProxy\\n  })\\n}\",\"replaceWithProxy\":\"(obj, propName, handler) => {\\n  const originalObj = obj[propName]\\n  const proxyObj = new Proxy(obj[propName], utils.stripProxyFromErrors(handler))\\n\\n  utils.replaceProperty(obj, propName, { value: proxyObj })\\n  utils.redirectToString(proxyObj, originalObj)\\n\\n  return true\\n}\",\"replaceGetterWithProxy\":\"(obj, propName, handler) => {\\n  const fn = Object.getOwnPropertyDescriptor(obj, propName).get\\n  const fnStr = fn.toString() // special getter function string\\n  const proxyObj = new Proxy(fn, utils.stripProxyFromErrors(handler))\\n\\n  utils.replaceProperty(obj, propName, { get: proxyObj })\\n  utils.patchToString(proxyObj, fnStr)\\n\\n  return true\\n}\",\"replaceGetterSetter\":\"(obj, propName, handlerGetterSetter) => {\\n  const ownPropertyDescriptor = Object.getOwnPropertyDescriptor(obj, propName)\\n  const handler = { ...ownPropertyDescriptor }\\n\\n  if (handlerGetterSetter.get !== undefined) {\\n    const nativeFn = ownPropertyDescriptor.get\\n    handler.get = function() {\\n      return handlerGetterSetter.get.call(this, nativeFn.bind(this))\\n    }\\n    utils.redirectToString(handler.get, nativeFn)\\n  }\\n\\n  if (handlerGetterSetter.set !== undefined) {\\n    const nativeFn = ownPropertyDescriptor.set\\n    handler.set = function(newValue) {\\n      handlerGetterSetter.set.call(this, newValue, nativeFn.bind(this))\\n    }\\n    utils.redirectToString(handler.set, nativeFn)\\n  }\\n\\n  Object.defineProperty(obj, propName, handler)\\n}\",\"mockWithProxy\":\"(obj, propName, pseudoTarget, handler) => {\\n  const proxyObj = new Proxy(pseudoTarget, utils.stripProxyFromErrors(handler))\\n\\n  utils.replaceProperty(obj, propName, { value: proxyObj })\\n  utils.patchToString(proxyObj)\\n\\n  return true\\n}\",\"createProxy\":\"(pseudoTarget, handler) => {\\n  const proxyObj = new Proxy(pseudoTarget, utils.stripProxyFromErrors(handler))\\n  utils.patchToString(proxyObj)\\n\\n  return proxyObj\\n}\",\"splitObjPath\":\"objPath => ({\\n  // Remove last dot entry (property) ==> `HTMLMediaElement.prototype`\\n  objName: objPath.split('.').slice(0, -1).join('.'),\\n  // Extract last dot entry ==> `canPlayType`\\n  propName: objPath.split('.').slice(-1)[0]\\n})\",\"replaceObjPathWithProxy\":\"(objPath, handler) => {\\n  const { objName, propName } = utils.splitObjPath(objPath)\\n  const obj = eval(objName) // eslint-disable-line no-eval\\n  return utils.replaceWithProxy(obj, propName, handler)\\n}\",\"execRecursively\":\"(obj = {}, typeFilter = [], fn) => {\\n  function recurse(obj) {\\n    for (const key in obj) {\\n      if (obj[key] === undefined) {\\n        continue\\n      }\\n      if (obj[key] && typeof obj[key] === 'object') {\\n        recurse(obj[key])\\n      } else {\\n        if (obj[key] && typeFilter.includes(typeof obj[key])) {\\n          fn.call(this, obj[key])\\n        }\\n      }\\n    }\\n  }\\n  recurse(obj)\\n  return obj\\n}\",\"stringifyFns\":\"(fnObj = { hello: () => 'world' }) => {\\n  // Object.fromEntries() ponyfill (in 6 lines) - supported only in Node v12+, modern browsers are fine\\n  // https://github.com/feross/fromentries\\n  function fromEntries(iterable) {\\n    return [...iterable].reduce((obj, [key, val]) => {\\n      obj[key] = val\\n      return obj\\n    }, {})\\n  }\\n  return (Object.fromEntries || fromEntries)(\\n    Object.entries(fnObj)\\n      .filter(([key, value]) => typeof value === 'function')\\n      .map(([key, value]) => [key, value.toString()]) // eslint-disable-line no-eval\\n  )\\n}\",\"materializeFns\":\"(fnStrObj = { hello: \\\"() => 'world'\\\" }) => {\\n  return Object.fromEntries(\\n    Object.entries(fnStrObj).map(([key, value]) => {\\n      if (value.startsWith('function')) {\\n        // some trickery is needed to make oldschool functions work :-)\\n        return [key, eval(`() => ${value}`)()] // eslint-disable-line no-eval\\n      } else {\\n        // arrow functions just work\\n        return [key, eval(value)] // eslint-disable-line no-eval\\n      }\\n    })\\n  )\\n}\",\"makeHandler\":\"() => ({\\n  // Used by simple `navigator` getter evasions\\n  getterValue: value => ({\\n    apply(target, ctx, args) {\\n      // Let's fetch the value first, to trigger and escalate potential errors\\n      // Illegal invocations like `navigator.__proto__.vendor` will throw here\\n      utils.cache.Reflect.apply(...arguments)\\n      return value\\n    }\\n  })\\n})\",\"arrayEquals\":\"(array1, array2) => {\\n  if (array1.length !== array2.length) {\\n    return false\\n  }\\n  for (let i = 0; i < array1.length; ++i) {\\n    if (array1[i] !== array2[i]) {\\n      return false\\n    }\\n  }\\n  return true\\n}\",\"memoize\":\"fn => {\\n  const cache = []\\n  return function(...args) {\\n    if (!cache.some(c => utils.arrayEquals(c.key, args))) {\\n      cache.push({ key: args, value: fn.apply(this, args) })\\n    }\\n    return cache.find(c => utils.arrayEquals(c.key, args)).value\\n  }\\n}\"},\"_mainFunction\":\"(utils, { opts }) => {\\n        if (!window.chrome) {\\n          // Use the exact property descriptor found in headful Chrome\\n          // fetch it via `Object.getOwnPropertyDescriptor(window, 'chrome')`\\n          Object.defineProperty(window, 'chrome', {\\n            writable: true,\\n            enumerable: true,\\n            configurable: false, // note!\\n            value: {} // We'll extend that later\\n          })\\n        }\\n\\n        // That means we're running headful and don't need to mock anything\\n        if ('loadTimes' in window.chrome) {\\n          return // Nothing to do here\\n        }\\n\\n        // Check that the Navigation Timing API v1 + v2 is available, we need that\\n        if (\\n          !window.performance ||\\n          !window.performance.timing ||\\n          !window.PerformancePaintTiming\\n        ) {\\n          return\\n        }\\n\\n        const { performance } = window\\n\\n        // Some stuff is not available on about:blank as it requires a navigation to occur,\\n        // let's harden the code to not fail then:\\n        const ntEntryFallback = {\\n          nextHopProtocol: 'h2',\\n          type: 'other'\\n        }\\n\\n        // The API exposes some funky info regarding the connection\\n        const protocolInfo = {\\n          get connectionInfo() {\\n            const ntEntry =\\n              performance.getEntriesByType('navigation')[0] || ntEntryFallback\\n            return ntEntry.nextHopProtocol\\n          },\\n          get npnNegotiatedProtocol() {\\n            // NPN is deprecated in favor of ALPN, but this implementation returns the\\n            // HTTP/2 or HTTP2+QUIC/39 requests negotiated via ALPN.\\n            const ntEntry =\\n              performance.getEntriesByType('navigation')[0] || ntEntryFallback\\n            return ['h2', 'hq'].includes(ntEntry.nextHopProtocol)\\n              ? ntEntry.nextHopProtocol\\n              : 'unknown'\\n          },\\n          get navigationType() {\\n            const ntEntry =\\n              performance.getEntriesByType('navigation')[0] || ntEntryFallback\\n            return ntEntry.type\\n          },\\n          get wasAlternateProtocolAvailable() {\\n            // The Alternate-Protocol header is deprecated in favor of Alt-Svc\\n            // (https://www.mnot.net/blog/2016/03/09/alt-svc), so technically this\\n            // should always return false.\\n            return false\\n          },\\n          get wasFetchedViaSpdy() {\\n            // SPDY is deprecated in favor of HTTP/2, but this implementation returns\\n            // true for HTTP/2 or HTTP2+QUIC/39 as well.\\n            const ntEntry =\\n              performance.getEntriesByType('navigation')[0] || ntEntryFallback\\n            return ['h2', 'hq'].includes(ntEntry.nextHopProtocol)\\n          },\\n          get wasNpnNegotiated() {\\n            // NPN is deprecated in favor of ALPN, but this implementation returns true\\n            // for HTTP/2 or HTTP2+QUIC/39 requests negotiated via ALPN.\\n            const ntEntry =\\n              performance.getEntriesByType('navigation')[0] || ntEntryFallback\\n            return ['h2', 'hq'].includes(ntEntry.nextHopProtocol)\\n          }\\n        }\\n\\n        const { timing } = window.performance\\n\\n        // Truncate number to specific number of decimals, most of the `loadTimes` stuff has 3\\n        function toFixed(num, fixed) {\\n          var re = new RegExp('^-?\\\\\\\\d+(?:.\\\\\\\\d{0,' + (fixed || -1) + '})?')\\n          return num.toString().match(re)[0]\\n        }\\n\\n        const timingInfo = {\\n          get firstPaintAfterLoadTime() {\\n            // This was never actually implemented and always returns 0.\\n            return 0\\n          },\\n          get requestTime() {\\n            return timing.navigationStart / 1000\\n          },\\n          get startLoadTime() {\\n            return timing.navigationStart / 1000\\n          },\\n          get commitLoadTime() {\\n            return timing.responseStart / 1000\\n          },\\n          get finishDocumentLoadTime() {\\n            return timing.domContentLoadedEventEnd / 1000\\n          },\\n          get finishLoadTime() {\\n            return timing.loadEventEnd / 1000\\n          },\\n          get firstPaintTime() {\\n            const fpEntry = performance.getEntriesByType('paint')[0] || {\\n              startTime: timing.loadEventEnd / 1000 // Fallback if no navigation occured (`about:blank`)\\n            }\\n            return toFixed(\\n              (fpEntry.startTime + performance.timeOrigin) / 1000,\\n              3\\n            )\\n          }\\n        }\\n\\n        window.chrome.loadTimes = function() {\\n          return {\\n            ...protocolInfo,\\n            ...timingInfo\\n          }\\n        }\\n        utils.patchToString(window.chrome.loadTimes)\\n      }\",\"_args\":[{\"opts\":{}}]})"},"stack":[{"file":"/home/neetoci/neeto-chat-web/playwright-tests/node_modules/@bigbinary/neeto-playwright-commons/node_modules/playwright-extra/dist/index.esm.js","line":230,"column":32,"function":"Proxy.<anonymous>"}]}
{"type":"before","callId":"pw:api@17","parentId":"fixture@11","startTime":87018.007,"class":"Test","method":"step","apiName":"page.addInitScript","params":{"source":"(({ _utilsFns, _mainFunction, _args }) => {\n        // Add this point we cannot use our utililty functions as they're just strings, we need to materialize them first\n        const utils = Object.fromEntries(\n          Object.entries(_utilsFns).map(([key, value]) => [key, eval(value)]) // eslint-disable-line no-eval\n        )\n        utils.init()\n        return eval(_mainFunction)(utils, ..._args) // eslint-disable-line no-eval\n      })({\"_utilsFns\":{\"init\":\"() => {\\n  utils.preloadCache()\\n}\",\"stripProxyFromErrors\":\"(handler = {}) => {\\n  const newHandler = {\\n    setPrototypeOf: function (target, proto) {\\n      if (proto === null)\\n        throw new TypeError('Cannot convert object to primitive value')\\n      if (Object.getPrototypeOf(target) === Object.getPrototypeOf(proto)) {\\n        throw new TypeError('Cyclic __proto__ value')\\n      }\\n      return Reflect.setPrototypeOf(target, proto)\\n    }\\n  }\\n  // We wrap each trap in the handler in a try/catch and modify the error stack if they throw\\n  const traps = Object.getOwnPropertyNames(handler)\\n  traps.forEach(trap => {\\n    newHandler[trap] = function () {\\n      try {\\n        // Forward the call to the defined proxy handler\\n        return handler[trap].apply(this, arguments || [])\\n      } catch (err) {\\n        // Stack traces differ per browser, we only support chromium based ones currently\\n        if (!err || !err.stack || !err.stack.includes(`at `)) {\\n          throw err\\n        }\\n\\n        // When something throws within one of our traps the Proxy will show up in error stacks\\n        // An earlier implementation of this code would simply strip lines with a blacklist,\\n        // but it makes sense to be more surgical here and only remove lines related to our Proxy.\\n        // We try to use a known \\\"anchor\\\" line for that and strip it with everything above it.\\n        // If the anchor line cannot be found for some reason we fall back to our blacklist approach.\\n\\n        const stripWithBlacklist = (stack, stripFirstLine = true) => {\\n          const blacklist = [\\n            `at Reflect.${trap} `, // e.g. Reflect.get or Reflect.apply\\n            `at Object.${trap} `, // e.g. Object.get or Object.apply\\n            `at Object.newHandler.<computed> [as ${trap}] ` // caused by this very wrapper :-)\\n          ]\\n          return (\\n            err.stack\\n              .split('\\\\n')\\n              // Always remove the first (file) line in the stack (guaranteed to be our proxy)\\n              .filter((line, index) => !(index === 1 && stripFirstLine))\\n              // Check if the line starts with one of our blacklisted strings\\n              .filter(line => !blacklist.some(bl => line.trim().startsWith(bl)))\\n              .join('\\\\n')\\n          )\\n        }\\n\\n        const stripWithAnchor = (stack, anchor) => {\\n          const stackArr = stack.split('\\\\n')\\n          anchor = anchor || `at Object.newHandler.<computed> [as ${trap}] ` // Known first Proxy line in chromium\\n          const anchorIndex = stackArr.findIndex(line =>\\n            line.trim().startsWith(anchor)\\n          )\\n          if (anchorIndex === -1) {\\n            return false // 404, anchor not found\\n          }\\n          // Strip everything from the top until we reach the anchor line\\n          // Note: We're keeping the 1st line (zero index) as it's unrelated (e.g. `TypeError`)\\n          stackArr.splice(1, anchorIndex)\\n          return stackArr.join('\\\\n')\\n        }\\n\\n        // Special cases due to our nested toString proxies\\n        err.stack = err.stack.replace(\\n          'at Object.toString (',\\n          'at Function.toString ('\\n        )\\n        if ((err.stack || '').includes('at Function.toString (')) {\\n          err.stack = stripWithBlacklist(err.stack, false)\\n          throw err\\n        }\\n\\n        // Try using the anchor method, fallback to blacklist if necessary\\n        err.stack = stripWithAnchor(err.stack) || stripWithBlacklist(err.stack)\\n\\n        throw err // Re-throw our now sanitized error\\n      }\\n    }\\n  })\\n  return newHandler\\n}\",\"stripErrorWithAnchor\":\"(err, anchor) => {\\n  const stackArr = err.stack.split('\\\\n')\\n  const anchorIndex = stackArr.findIndex(line => line.trim().startsWith(anchor))\\n  if (anchorIndex === -1) {\\n    return err // 404, anchor not found\\n  }\\n  // Strip everything from the top until we reach the anchor line (remove anchor line as well)\\n  // Note: We're keeping the 1st line (zero index) as it's unrelated (e.g. `TypeError`)\\n  stackArr.splice(1, anchorIndex)\\n  err.stack = stackArr.join('\\\\n')\\n  return err\\n}\",\"replaceProperty\":\"(obj, propName, descriptorOverrides = {}) => {\\n  return Object.defineProperty(obj, propName, {\\n    // Copy over the existing descriptors (writable, enumerable, configurable, etc)\\n    ...(Object.getOwnPropertyDescriptor(obj, propName) || {}),\\n    // Add our overrides (e.g. value, get())\\n    ...descriptorOverrides\\n  })\\n}\",\"preloadCache\":\"() => {\\n  if (utils.cache) {\\n    return\\n  }\\n  utils.cache = {\\n    // Used in our proxies\\n    Reflect: {\\n      get: Reflect.get.bind(Reflect),\\n      apply: Reflect.apply.bind(Reflect)\\n    },\\n    // Used in `makeNativeString`\\n    nativeToStringStr: Function.toString + '' // => `function toString() { [native code] }`\\n  }\\n}\",\"makeNativeString\":\"(name = '') => {\\n  return utils.cache.nativeToStringStr.replace('toString', name || '')\\n}\",\"patchToString\":\"(obj, str = '') => {\\n  const handler = {\\n    apply: function (target, ctx) {\\n      // This fixes e.g. `HTMLMediaElement.prototype.canPlayType.toString + \\\"\\\"`\\n      if (ctx === Function.prototype.toString) {\\n        return utils.makeNativeString('toString')\\n      }\\n      // `toString` targeted at our proxied Object detected\\n      if (ctx === obj) {\\n        // We either return the optional string verbatim or derive the most desired result automatically\\n        return str || utils.makeNativeString(obj.name)\\n      }\\n      // Check if the toString protype of the context is the same as the global prototype,\\n      // if not indicates that we are doing a check across different windows., e.g. the iframeWithdirect` test case\\n      const hasSameProto = Object.getPrototypeOf(\\n        Function.prototype.toString\\n      ).isPrototypeOf(ctx.toString) // eslint-disable-line no-prototype-builtins\\n      if (!hasSameProto) {\\n        // Pass the call on to the local Function.prototype.toString instead\\n        return ctx.toString()\\n      }\\n      return target.call(ctx)\\n    }\\n  }\\n\\n  const toStringProxy = new Proxy(\\n    Function.prototype.toString,\\n    utils.stripProxyFromErrors(handler)\\n  )\\n  utils.replaceProperty(Function.prototype, 'toString', {\\n    value: toStringProxy\\n  })\\n}\",\"patchToStringNested\":\"(obj = {}) => {\\n  return utils.execRecursively(obj, ['function'], utils.patchToString)\\n}\",\"redirectToString\":\"(proxyObj, originalObj) => {\\n  const handler = {\\n    apply: function (target, ctx) {\\n      // This fixes e.g. `HTMLMediaElement.prototype.canPlayType.toString + \\\"\\\"`\\n      if (ctx === Function.prototype.toString) {\\n        return utils.makeNativeString('toString')\\n      }\\n\\n      // `toString` targeted at our proxied Object detected\\n      if (ctx === proxyObj) {\\n        const fallback = () =>\\n          originalObj && originalObj.name\\n            ? utils.makeNativeString(originalObj.name)\\n            : utils.makeNativeString(proxyObj.name)\\n\\n        // Return the toString representation of our original object if possible\\n        return originalObj + '' || fallback()\\n      }\\n\\n      if (typeof ctx === 'undefined' || ctx === null) {\\n        return target.call(ctx)\\n      }\\n\\n      // Check if the toString protype of the context is the same as the global prototype,\\n      // if not indicates that we are doing a check across different windows., e.g. the iframeWithdirect` test case\\n      const hasSameProto = Object.getPrototypeOf(\\n        Function.prototype.toString\\n      ).isPrototypeOf(ctx.toString) // eslint-disable-line no-prototype-builtins\\n      if (!hasSameProto) {\\n        // Pass the call on to the local Function.prototype.toString instead\\n        return ctx.toString()\\n      }\\n\\n      return target.call(ctx)\\n    }\\n  }\\n\\n  const toStringProxy = new Proxy(\\n    Function.prototype.toString,\\n    utils.stripProxyFromErrors(handler)\\n  )\\n  utils.replaceProperty(Function.prototype, 'toString', {\\n    value: toStringProxy\\n  })\\n}\",\"replaceWithProxy\":\"(obj, propName, handler) => {\\n  const originalObj = obj[propName]\\n  const proxyObj = new Proxy(obj[propName], utils.stripProxyFromErrors(handler))\\n\\n  utils.replaceProperty(obj, propName, { value: proxyObj })\\n  utils.redirectToString(proxyObj, originalObj)\\n\\n  return true\\n}\",\"replaceGetterWithProxy\":\"(obj, propName, handler) => {\\n  const fn = Object.getOwnPropertyDescriptor(obj, propName).get\\n  const fnStr = fn.toString() // special getter function string\\n  const proxyObj = new Proxy(fn, utils.stripProxyFromErrors(handler))\\n\\n  utils.replaceProperty(obj, propName, { get: proxyObj })\\n  utils.patchToString(proxyObj, fnStr)\\n\\n  return true\\n}\",\"replaceGetterSetter\":\"(obj, propName, handlerGetterSetter) => {\\n  const ownPropertyDescriptor = Object.getOwnPropertyDescriptor(obj, propName)\\n  const handler = { ...ownPropertyDescriptor }\\n\\n  if (handlerGetterSetter.get !== undefined) {\\n    const nativeFn = ownPropertyDescriptor.get\\n    handler.get = function() {\\n      return handlerGetterSetter.get.call(this, nativeFn.bind(this))\\n    }\\n    utils.redirectToString(handler.get, nativeFn)\\n  }\\n\\n  if (handlerGetterSetter.set !== undefined) {\\n    const nativeFn = ownPropertyDescriptor.set\\n    handler.set = function(newValue) {\\n      handlerGetterSetter.set.call(this, newValue, nativeFn.bind(this))\\n    }\\n    utils.redirectToString(handler.set, nativeFn)\\n  }\\n\\n  Object.defineProperty(obj, propName, handler)\\n}\",\"mockWithProxy\":\"(obj, propName, pseudoTarget, handler) => {\\n  const proxyObj = new Proxy(pseudoTarget, utils.stripProxyFromErrors(handler))\\n\\n  utils.replaceProperty(obj, propName, { value: proxyObj })\\n  utils.patchToString(proxyObj)\\n\\n  return true\\n}\",\"createProxy\":\"(pseudoTarget, handler) => {\\n  const proxyObj = new Proxy(pseudoTarget, utils.stripProxyFromErrors(handler))\\n  utils.patchToString(proxyObj)\\n\\n  return proxyObj\\n}\",\"splitObjPath\":\"objPath => ({\\n  // Remove last dot entry (property) ==> `HTMLMediaElement.prototype`\\n  objName: objPath.split('.').slice(0, -1).join('.'),\\n  // Extract last dot entry ==> `canPlayType`\\n  propName: objPath.split('.').slice(-1)[0]\\n})\",\"replaceObjPathWithProxy\":\"(objPath, handler) => {\\n  const { objName, propName } = utils.splitObjPath(objPath)\\n  const obj = eval(objName) // eslint-disable-line no-eval\\n  return utils.replaceWithProxy(obj, propName, handler)\\n}\",\"execRecursively\":\"(obj = {}, typeFilter = [], fn) => {\\n  function recurse(obj) {\\n    for (const key in obj) {\\n      if (obj[key] === undefined) {\\n        continue\\n      }\\n      if (obj[key] && typeof obj[key] === 'object') {\\n        recurse(obj[key])\\n      } else {\\n        if (obj[key] && typeFilter.includes(typeof obj[key])) {\\n          fn.call(this, obj[key])\\n        }\\n      }\\n    }\\n  }\\n  recurse(obj)\\n  return obj\\n}\",\"stringifyFns\":\"(fnObj = { hello: () => 'world' }) => {\\n  // Object.fromEntries() ponyfill (in 6 lines) - supported only in Node v12+, modern browsers are fine\\n  // https://github.com/feross/fromentries\\n  function fromEntries(iterable) {\\n    return [...iterable].reduce((obj, [key, val]) => {\\n      obj[key] = val\\n      return obj\\n    }, {})\\n  }\\n  return (Object.fromEntries || fromEntries)(\\n    Object.entries(fnObj)\\n      .filter(([key, value]) => typeof value === 'function')\\n      .map(([key, value]) => [key, value.toString()]) // eslint-disable-line no-eval\\n  )\\n}\",\"materializeFns\":\"(fnStrObj = { hello: \\\"() => 'world'\\\" }) => {\\n  return Object.fromEntries(\\n    Object.entries(fnStrObj).map(([key, value]) => {\\n      if (value.startsWith('function')) {\\n        // some trickery is needed to make oldschool functions work :-)\\n        return [key, eval(`() => ${value}`)()] // eslint-disable-line no-eval\\n      } else {\\n        // arrow functions just work\\n        return [key, eval(value)] // eslint-disable-line no-eval\\n      }\\n    })\\n  )\\n}\",\"makeHandler\":\"() => ({\\n  // Used by simple `navigator` getter evasions\\n  getterValue: value => ({\\n    apply(target, ctx, args) {\\n      // Let's fetch the value first, to trigger and escalate potential errors\\n      // Illegal invocations like `navigator.__proto__.vendor` will throw here\\n      utils.cache.Reflect.apply(...arguments)\\n      return value\\n    }\\n  })\\n})\",\"arrayEquals\":\"(array1, array2) => {\\n  if (array1.length !== array2.length) {\\n    return false\\n  }\\n  for (let i = 0; i < array1.length; ++i) {\\n    if (array1[i] !== array2[i]) {\\n      return false\\n    }\\n  }\\n  return true\\n}\",\"memoize\":\"fn => {\\n  const cache = []\\n  return function(...args) {\\n    if (!cache.some(c => utils.arrayEquals(c.key, args))) {\\n      cache.push({ key: args, value: fn.apply(this, args) })\\n    }\\n    return cache.find(c => utils.arrayEquals(c.key, args)).value\\n  }\\n}\"},\"_mainFunction\":\"(utils, { opts, STATIC_DATA }) => {\\n        if (!window.chrome) {\\n          // Use the exact property descriptor found in headful Chrome\\n          // fetch it via `Object.getOwnPropertyDescriptor(window, 'chrome')`\\n          Object.defineProperty(window, 'chrome', {\\n            writable: true,\\n            enumerable: true,\\n            configurable: false, // note!\\n            value: {} // We'll extend that later\\n          })\\n        }\\n\\n        // That means we're running headful and don't need to mock anything\\n        const existsAlready = 'runtime' in window.chrome\\n        // `chrome.runtime` is only exposed on secure origins\\n        const isNotSecure = !window.location.protocol.startsWith('https')\\n        if (existsAlready || (isNotSecure && !opts.runOnInsecureOrigins)) {\\n          return // Nothing to do here\\n        }\\n\\n        window.chrome.runtime = {\\n          // There's a bunch of static data in that property which doesn't seem to change,\\n          // we should periodically check for updates: `JSON.stringify(window.chrome.runtime, null, 2)`\\n          ...STATIC_DATA,\\n          // `chrome.runtime.id` is extension related and returns undefined in Chrome\\n          get id() {\\n            return undefined\\n          },\\n          // These two require more sophisticated mocks\\n          connect: null,\\n          sendMessage: null\\n        }\\n\\n        const makeCustomRuntimeErrors = (preamble, method, extensionId) => ({\\n          NoMatchingSignature: new TypeError(\\n            preamble + `No matching signature.`\\n          ),\\n          MustSpecifyExtensionID: new TypeError(\\n            preamble +\\n              `${method} called from a webpage must specify an Extension ID (string) for its first argument.`\\n          ),\\n          InvalidExtensionID: new TypeError(\\n            preamble + `Invalid extension id: '${extensionId}'`\\n          )\\n        })\\n\\n        // Valid Extension IDs are 32 characters in length and use the letter `a` to `p`:\\n        // https://source.chromium.org/chromium/chromium/src/+/master:components/crx_file/id_util.cc;drc=14a055ccb17e8c8d5d437fe080faba4c6f07beac;l=90\\n        const isValidExtensionID = str =>\\n          str.length === 32 && str.toLowerCase().match(/^[a-p]+$/)\\n\\n        /** Mock `chrome.runtime.sendMessage` */\\n        const sendMessageHandler = {\\n          apply: function(target, ctx, args) {\\n            const [extensionId, options, responseCallback] = args || []\\n\\n            // Define custom errors\\n            const errorPreamble = `Error in invocation of runtime.sendMessage(optional string extensionId, any message, optional object options, optional function responseCallback): `\\n            const Errors = makeCustomRuntimeErrors(\\n              errorPreamble,\\n              `chrome.runtime.sendMessage()`,\\n              extensionId\\n            )\\n\\n            // Check if the call signature looks ok\\n            const noArguments = args.length === 0\\n            const tooManyArguments = args.length > 4\\n            const incorrectOptions = options && typeof options !== 'object'\\n            const incorrectResponseCallback =\\n              responseCallback && typeof responseCallback !== 'function'\\n            if (\\n              noArguments ||\\n              tooManyArguments ||\\n              incorrectOptions ||\\n              incorrectResponseCallback\\n            ) {\\n              throw Errors.NoMatchingSignature\\n            }\\n\\n            // At least 2 arguments are required before we even validate the extension ID\\n            if (args.length < 2) {\\n              throw Errors.MustSpecifyExtensionID\\n            }\\n\\n            // Now let's make sure we got a string as extension ID\\n            if (typeof extensionId !== 'string') {\\n              throw Errors.NoMatchingSignature\\n            }\\n\\n            if (!isValidExtensionID(extensionId)) {\\n              throw Errors.InvalidExtensionID\\n            }\\n\\n            return undefined // Normal behavior\\n          }\\n        }\\n        utils.mockWithProxy(\\n          window.chrome.runtime,\\n          'sendMessage',\\n          function sendMessage() {},\\n          sendMessageHandler\\n        )\\n\\n        /**\\n         * Mock `chrome.runtime.connect`\\n         *\\n         * @see https://developer.chrome.com/apps/runtime#method-connect\\n         */\\n        const connectHandler = {\\n          apply: function(target, ctx, args) {\\n            const [extensionId, connectInfo] = args || []\\n\\n            // Define custom errors\\n            const errorPreamble = `Error in invocation of runtime.connect(optional string extensionId, optional object connectInfo): `\\n            const Errors = makeCustomRuntimeErrors(\\n              errorPreamble,\\n              `chrome.runtime.connect()`,\\n              extensionId\\n            )\\n\\n            // Behavior differs a bit from sendMessage:\\n            const noArguments = args.length === 0\\n            const emptyStringArgument = args.length === 1 && extensionId === ''\\n            if (noArguments || emptyStringArgument) {\\n              throw Errors.MustSpecifyExtensionID\\n            }\\n\\n            const tooManyArguments = args.length > 2\\n            const incorrectConnectInfoType =\\n              connectInfo && typeof connectInfo !== 'object'\\n\\n            if (tooManyArguments || incorrectConnectInfoType) {\\n              throw Errors.NoMatchingSignature\\n            }\\n\\n            const extensionIdIsString = typeof extensionId === 'string'\\n            if (extensionIdIsString && extensionId === '') {\\n              throw Errors.MustSpecifyExtensionID\\n            }\\n            if (extensionIdIsString && !isValidExtensionID(extensionId)) {\\n              throw Errors.InvalidExtensionID\\n            }\\n\\n            // There's another edge-case here: extensionId is optional so we might find a connectInfo object as first param, which we need to validate\\n            const validateConnectInfo = ci => {\\n              // More than a first param connectInfo as been provided\\n              if (args.length > 1) {\\n                throw Errors.NoMatchingSignature\\n              }\\n              // An empty connectInfo has been provided\\n              if (Object.keys(ci).length === 0) {\\n                throw Errors.MustSpecifyExtensionID\\n              }\\n              // Loop over all connectInfo props an check them\\n              Object.entries(ci).forEach(([k, v]) => {\\n                const isExpected = ['name', 'includeTlsChannelId'].includes(k)\\n                if (!isExpected) {\\n                  throw new TypeError(\\n                    errorPreamble + `Unexpected property: '${k}'.`\\n                  )\\n                }\\n                const MismatchError = (propName, expected, found) =>\\n                  TypeError(\\n                    errorPreamble +\\n                      `Error at property '${propName}': Invalid type: expected ${expected}, found ${found}.`\\n                  )\\n                if (k === 'name' && typeof v !== 'string') {\\n                  throw MismatchError(k, 'string', typeof v)\\n                }\\n                if (k === 'includeTlsChannelId' && typeof v !== 'boolean') {\\n                  throw MismatchError(k, 'boolean', typeof v)\\n                }\\n              })\\n            }\\n            if (typeof extensionId === 'object') {\\n              validateConnectInfo(extensionId)\\n              throw Errors.MustSpecifyExtensionID\\n            }\\n\\n            // Unfortunately even when the connect fails Chrome will return an object with methods we need to mock as well\\n            return utils.patchToStringNested(makeConnectResponse())\\n          }\\n        }\\n        utils.mockWithProxy(\\n          window.chrome.runtime,\\n          'connect',\\n          function connect() {},\\n          connectHandler\\n        )\\n\\n        function makeConnectResponse() {\\n          const onSomething = () => ({\\n            addListener: function addListener() {},\\n            dispatch: function dispatch() {},\\n            hasListener: function hasListener() {},\\n            hasListeners: function hasListeners() {\\n              return false\\n            },\\n            removeListener: function removeListener() {}\\n          })\\n\\n          const response = {\\n            name: '',\\n            sender: undefined,\\n            disconnect: function disconnect() {},\\n            onDisconnect: onSomething(),\\n            onMessage: onSomething(),\\n            postMessage: function postMessage() {\\n              if (!arguments.length) {\\n                throw new TypeError(`Insufficient number of arguments.`)\\n              }\\n              throw new Error(`Attempting to use a disconnected port object`)\\n            }\\n          }\\n          return response\\n        }\\n      }\",\"_args\":[{\"opts\":{\"runOnInsecureOrigins\":false},\"STATIC_DATA\":{\"OnInstalledReason\":{\"CHROME_UPDATE\":\"chrome_update\",\"INSTALL\":\"install\",\"SHARED_MODULE_UPDATE\":\"shared_module_update\",\"UPDATE\":\"update\"},\"OnRestartRequiredReason\":{\"APP_UPDATE\":\"app_update\",\"OS_UPDATE\":\"os_update\",\"PERIODIC\":\"periodic\"},\"PlatformArch\":{\"ARM\":\"arm\",\"ARM64\":\"arm64\",\"MIPS\":\"mips\",\"MIPS64\":\"mips64\",\"X86_32\":\"x86-32\",\"X86_64\":\"x86-64\"},\"PlatformNaclArch\":{\"ARM\":\"arm\",\"MIPS\":\"mips\",\"MIPS64\":\"mips64\",\"X86_32\":\"x86-32\",\"X86_64\":\"x86-64\"},\"PlatformOs\":{\"ANDROID\":\"android\",\"CROS\":\"cros\",\"LINUX\":\"linux\",\"MAC\":\"mac\",\"OPENBSD\":\"openbsd\",\"WIN\":\"win\"},\"RequestUpdateCheckStatus\":{\"NO_UPDATE\":\"no_update\",\"THROTTLED\":\"throttled\",\"UPDATE_AVAILABLE\":\"update_available\"}}}]})"},"stack":[{"file":"/home/neetoci/neeto-chat-web/playwright-tests/node_modules/@bigbinary/neeto-playwright-commons/node_modules/playwright-extra/dist/index.esm.js","line":230,"column":32,"function":"Proxy.<anonymous>"}]}
{"type":"before","callId":"pw:api@18","parentId":"fixture@11","startTime":87018.548,"class":"Test","method":"step","apiName":"page.addInitScript","params":{"source":"(({ _utilsFns, _mainFunction, _args }) => {\n        // Add this point we cannot use our utililty functions as they're just strings, we need to materialize them first\n        const utils = Object.fromEntries(\n          Object.entries(_utilsFns).map(([key, value]) => [key, eval(value)]) // eslint-disable-line no-eval\n        )\n        utils.init()\n        return eval(_mainFunction)(utils, ..._args) // eslint-disable-line no-eval\n      })({\"_utilsFns\":{\"init\":\"() => {\\n  utils.preloadCache()\\n}\",\"stripProxyFromErrors\":\"(handler = {}) => {\\n  const newHandler = {\\n    setPrototypeOf: function (target, proto) {\\n      if (proto === null)\\n        throw new TypeError('Cannot convert object to primitive value')\\n      if (Object.getPrototypeOf(target) === Object.getPrototypeOf(proto)) {\\n        throw new TypeError('Cyclic __proto__ value')\\n      }\\n      return Reflect.setPrototypeOf(target, proto)\\n    }\\n  }\\n  // We wrap each trap in the handler in a try/catch and modify the error stack if they throw\\n  const traps = Object.getOwnPropertyNames(handler)\\n  traps.forEach(trap => {\\n    newHandler[trap] = function () {\\n      try {\\n        // Forward the call to the defined proxy handler\\n        return handler[trap].apply(this, arguments || [])\\n      } catch (err) {\\n        // Stack traces differ per browser, we only support chromium based ones currently\\n        if (!err || !err.stack || !err.stack.includes(`at `)) {\\n          throw err\\n        }\\n\\n        // When something throws within one of our traps the Proxy will show up in error stacks\\n        // An earlier implementation of this code would simply strip lines with a blacklist,\\n        // but it makes sense to be more surgical here and only remove lines related to our Proxy.\\n        // We try to use a known \\\"anchor\\\" line for that and strip it with everything above it.\\n        // If the anchor line cannot be found for some reason we fall back to our blacklist approach.\\n\\n        const stripWithBlacklist = (stack, stripFirstLine = true) => {\\n          const blacklist = [\\n            `at Reflect.${trap} `, // e.g. Reflect.get or Reflect.apply\\n            `at Object.${trap} `, // e.g. Object.get or Object.apply\\n            `at Object.newHandler.<computed> [as ${trap}] ` // caused by this very wrapper :-)\\n          ]\\n          return (\\n            err.stack\\n              .split('\\\\n')\\n              // Always remove the first (file) line in the stack (guaranteed to be our proxy)\\n              .filter((line, index) => !(index === 1 && stripFirstLine))\\n              // Check if the line starts with one of our blacklisted strings\\n              .filter(line => !blacklist.some(bl => line.trim().startsWith(bl)))\\n              .join('\\\\n')\\n          )\\n        }\\n\\n        const stripWithAnchor = (stack, anchor) => {\\n          const stackArr = stack.split('\\\\n')\\n          anchor = anchor || `at Object.newHandler.<computed> [as ${trap}] ` // Known first Proxy line in chromium\\n          const anchorIndex = stackArr.findIndex(line =>\\n            line.trim().startsWith(anchor)\\n          )\\n          if (anchorIndex === -1) {\\n            return false // 404, anchor not found\\n          }\\n          // Strip everything from the top until we reach the anchor line\\n          // Note: We're keeping the 1st line (zero index) as it's unrelated (e.g. `TypeError`)\\n          stackArr.splice(1, anchorIndex)\\n          return stackArr.join('\\\\n')\\n        }\\n\\n        // Special cases due to our nested toString proxies\\n        err.stack = err.stack.replace(\\n          'at Object.toString (',\\n          'at Function.toString ('\\n        )\\n        if ((err.stack || '').includes('at Function.toString (')) {\\n          err.stack = stripWithBlacklist(err.stack, false)\\n          throw err\\n        }\\n\\n        // Try using the anchor method, fallback to blacklist if necessary\\n        err.stack = stripWithAnchor(err.stack) || stripWithBlacklist(err.stack)\\n\\n        throw err // Re-throw our now sanitized error\\n      }\\n    }\\n  })\\n  return newHandler\\n}\",\"stripErrorWithAnchor\":\"(err, anchor) => {\\n  const stackArr = err.stack.split('\\\\n')\\n  const anchorIndex = stackArr.findIndex(line => line.trim().startsWith(anchor))\\n  if (anchorIndex === -1) {\\n    return err // 404, anchor not found\\n  }\\n  // Strip everything from the top until we reach the anchor line (remove anchor line as well)\\n  // Note: We're keeping the 1st line (zero index) as it's unrelated (e.g. `TypeError`)\\n  stackArr.splice(1, anchorIndex)\\n  err.stack = stackArr.join('\\\\n')\\n  return err\\n}\",\"replaceProperty\":\"(obj, propName, descriptorOverrides = {}) => {\\n  return Object.defineProperty(obj, propName, {\\n    // Copy over the existing descriptors (writable, enumerable, configurable, etc)\\n    ...(Object.getOwnPropertyDescriptor(obj, propName) || {}),\\n    // Add our overrides (e.g. value, get())\\n    ...descriptorOverrides\\n  })\\n}\",\"preloadCache\":\"() => {\\n  if (utils.cache) {\\n    return\\n  }\\n  utils.cache = {\\n    // Used in our proxies\\n    Reflect: {\\n      get: Reflect.get.bind(Reflect),\\n      apply: Reflect.apply.bind(Reflect)\\n    },\\n    // Used in `makeNativeString`\\n    nativeToStringStr: Function.toString + '' // => `function toString() { [native code] }`\\n  }\\n}\",\"makeNativeString\":\"(name = '') => {\\n  return utils.cache.nativeToStringStr.replace('toString', name || '')\\n}\",\"patchToString\":\"(obj, str = '') => {\\n  const handler = {\\n    apply: function (target, ctx) {\\n      // This fixes e.g. `HTMLMediaElement.prototype.canPlayType.toString + \\\"\\\"`\\n      if (ctx === Function.prototype.toString) {\\n        return utils.makeNativeString('toString')\\n      }\\n      // `toString` targeted at our proxied Object detected\\n      if (ctx === obj) {\\n        // We either return the optional string verbatim or derive the most desired result automatically\\n        return str || utils.makeNativeString(obj.name)\\n      }\\n      // Check if the toString protype of the context is the same as the global prototype,\\n      // if not indicates that we are doing a check across different windows., e.g. the iframeWithdirect` test case\\n      const hasSameProto = Object.getPrototypeOf(\\n        Function.prototype.toString\\n      ).isPrototypeOf(ctx.toString) // eslint-disable-line no-prototype-builtins\\n      if (!hasSameProto) {\\n        // Pass the call on to the local Function.prototype.toString instead\\n        return ctx.toString()\\n      }\\n      return target.call(ctx)\\n    }\\n  }\\n\\n  const toStringProxy = new Proxy(\\n    Function.prototype.toString,\\n    utils.stripProxyFromErrors(handler)\\n  )\\n  utils.replaceProperty(Function.prototype, 'toString', {\\n    value: toStringProxy\\n  })\\n}\",\"patchToStringNested\":\"(obj = {}) => {\\n  return utils.execRecursively(obj, ['function'], utils.patchToString)\\n}\",\"redirectToString\":\"(proxyObj, originalObj) => {\\n  const handler = {\\n    apply: function (target, ctx) {\\n      // This fixes e.g. `HTMLMediaElement.prototype.canPlayType.toString + \\\"\\\"`\\n      if (ctx === Function.prototype.toString) {\\n        return utils.makeNativeString('toString')\\n      }\\n\\n      // `toString` targeted at our proxied Object detected\\n      if (ctx === proxyObj) {\\n        const fallback = () =>\\n          originalObj && originalObj.name\\n            ? utils.makeNativeString(originalObj.name)\\n            : utils.makeNativeString(proxyObj.name)\\n\\n        // Return the toString representation of our original object if possible\\n        return originalObj + '' || fallback()\\n      }\\n\\n      if (typeof ctx === 'undefined' || ctx === null) {\\n        return target.call(ctx)\\n      }\\n\\n      // Check if the toString protype of the context is the same as the global prototype,\\n      // if not indicates that we are doing a check across different windows., e.g. the iframeWithdirect` test case\\n      const hasSameProto = Object.getPrototypeOf(\\n        Function.prototype.toString\\n      ).isPrototypeOf(ctx.toString) // eslint-disable-line no-prototype-builtins\\n      if (!hasSameProto) {\\n        // Pass the call on to the local Function.prototype.toString instead\\n        return ctx.toString()\\n      }\\n\\n      return target.call(ctx)\\n    }\\n  }\\n\\n  const toStringProxy = new Proxy(\\n    Function.prototype.toString,\\n    utils.stripProxyFromErrors(handler)\\n  )\\n  utils.replaceProperty(Function.prototype, 'toString', {\\n    value: toStringProxy\\n  })\\n}\",\"replaceWithProxy\":\"(obj, propName, handler) => {\\n  const originalObj = obj[propName]\\n  const proxyObj = new Proxy(obj[propName], utils.stripProxyFromErrors(handler))\\n\\n  utils.replaceProperty(obj, propName, { value: proxyObj })\\n  utils.redirectToString(proxyObj, originalObj)\\n\\n  return true\\n}\",\"replaceGetterWithProxy\":\"(obj, propName, handler) => {\\n  const fn = Object.getOwnPropertyDescriptor(obj, propName).get\\n  const fnStr = fn.toString() // special getter function string\\n  const proxyObj = new Proxy(fn, utils.stripProxyFromErrors(handler))\\n\\n  utils.replaceProperty(obj, propName, { get: proxyObj })\\n  utils.patchToString(proxyObj, fnStr)\\n\\n  return true\\n}\",\"replaceGetterSetter\":\"(obj, propName, handlerGetterSetter) => {\\n  const ownPropertyDescriptor = Object.getOwnPropertyDescriptor(obj, propName)\\n  const handler = { ...ownPropertyDescriptor }\\n\\n  if (handlerGetterSetter.get !== undefined) {\\n    const nativeFn = ownPropertyDescriptor.get\\n    handler.get = function() {\\n      return handlerGetterSetter.get.call(this, nativeFn.bind(this))\\n    }\\n    utils.redirectToString(handler.get, nativeFn)\\n  }\\n\\n  if (handlerGetterSetter.set !== undefined) {\\n    const nativeFn = ownPropertyDescriptor.set\\n    handler.set = function(newValue) {\\n      handlerGetterSetter.set.call(this, newValue, nativeFn.bind(this))\\n    }\\n    utils.redirectToString(handler.set, nativeFn)\\n  }\\n\\n  Object.defineProperty(obj, propName, handler)\\n}\",\"mockWithProxy\":\"(obj, propName, pseudoTarget, handler) => {\\n  const proxyObj = new Proxy(pseudoTarget, utils.stripProxyFromErrors(handler))\\n\\n  utils.replaceProperty(obj, propName, { value: proxyObj })\\n  utils.patchToString(proxyObj)\\n\\n  return true\\n}\",\"createProxy\":\"(pseudoTarget, handler) => {\\n  const proxyObj = new Proxy(pseudoTarget, utils.stripProxyFromErrors(handler))\\n  utils.patchToString(proxyObj)\\n\\n  return proxyObj\\n}\",\"splitObjPath\":\"objPath => ({\\n  // Remove last dot entry (property) ==> `HTMLMediaElement.prototype`\\n  objName: objPath.split('.').slice(0, -1).join('.'),\\n  // Extract last dot entry ==> `canPlayType`\\n  propName: objPath.split('.').slice(-1)[0]\\n})\",\"replaceObjPathWithProxy\":\"(objPath, handler) => {\\n  const { objName, propName } = utils.splitObjPath(objPath)\\n  const obj = eval(objName) // eslint-disable-line no-eval\\n  return utils.replaceWithProxy(obj, propName, handler)\\n}\",\"execRecursively\":\"(obj = {}, typeFilter = [], fn) => {\\n  function recurse(obj) {\\n    for (const key in obj) {\\n      if (obj[key] === undefined) {\\n        continue\\n      }\\n      if (obj[key] && typeof obj[key] === 'object') {\\n        recurse(obj[key])\\n      } else {\\n        if (obj[key] && typeFilter.includes(typeof obj[key])) {\\n          fn.call(this, obj[key])\\n        }\\n      }\\n    }\\n  }\\n  recurse(obj)\\n  return obj\\n}\",\"stringifyFns\":\"(fnObj = { hello: () => 'world' }) => {\\n  // Object.fromEntries() ponyfill (in 6 lines) - supported only in Node v12+, modern browsers are fine\\n  // https://github.com/feross/fromentries\\n  function fromEntries(iterable) {\\n    return [...iterable].reduce((obj, [key, val]) => {\\n      obj[key] = val\\n      return obj\\n    }, {})\\n  }\\n  return (Object.fromEntries || fromEntries)(\\n    Object.entries(fnObj)\\n      .filter(([key, value]) => typeof value === 'function')\\n      .map(([key, value]) => [key, value.toString()]) // eslint-disable-line no-eval\\n  )\\n}\",\"materializeFns\":\"(fnStrObj = { hello: \\\"() => 'world'\\\" }) => {\\n  return Object.fromEntries(\\n    Object.entries(fnStrObj).map(([key, value]) => {\\n      if (value.startsWith('function')) {\\n        // some trickery is needed to make oldschool functions work :-)\\n        return [key, eval(`() => ${value}`)()] // eslint-disable-line no-eval\\n      } else {\\n        // arrow functions just work\\n        return [key, eval(value)] // eslint-disable-line no-eval\\n      }\\n    })\\n  )\\n}\",\"makeHandler\":\"() => ({\\n  // Used by simple `navigator` getter evasions\\n  getterValue: value => ({\\n    apply(target, ctx, args) {\\n      // Let's fetch the value first, to trigger and escalate potential errors\\n      // Illegal invocations like `navigator.__proto__.vendor` will throw here\\n      utils.cache.Reflect.apply(...arguments)\\n      return value\\n    }\\n  })\\n})\",\"arrayEquals\":\"(array1, array2) => {\\n  if (array1.length !== array2.length) {\\n    return false\\n  }\\n  for (let i = 0; i < array1.length; ++i) {\\n    if (array1[i] !== array2[i]) {\\n      return false\\n    }\\n  }\\n  return true\\n}\",\"memoize\":\"fn => {\\n  const cache = []\\n  return function(...args) {\\n    if (!cache.some(c => utils.arrayEquals(c.key, args))) {\\n      cache.push({ key: args, value: fn.apply(this, args) })\\n    }\\n    return cache.find(c => utils.arrayEquals(c.key, args)).value\\n  }\\n}\"},\"_mainFunction\":\"utils => {\\n      /**\\n       * Input might look funky, we need to normalize it so e.g. whitespace isn't an issue for our spoofing.\\n       *\\n       * @example\\n       * video/webm; codecs=\\\"vp8, vorbis\\\"\\n       * video/mp4; codecs=\\\"avc1.42E01E\\\"\\n       * audio/x-m4a;\\n       * audio/ogg; codecs=\\\"vorbis\\\"\\n       * @param {String} arg\\n       */\\n      const parseInput = arg => {\\n        const [mime, codecStr] = arg.trim().split(';')\\n        let codecs = []\\n        if (codecStr && codecStr.includes('codecs=\\\"')) {\\n          codecs = codecStr\\n            .trim()\\n            .replace(`codecs=\\\"`, '')\\n            .replace(`\\\"`, '')\\n            .trim()\\n            .split(',')\\n            .filter(x => !!x)\\n            .map(x => x.trim())\\n        }\\n        return {\\n          mime,\\n          codecStr,\\n          codecs\\n        }\\n      }\\n\\n      const canPlayType = {\\n        // Intercept certain requests\\n        apply: function(target, ctx, args) {\\n          if (!args || !args.length) {\\n            return target.apply(ctx, args)\\n          }\\n          const { mime, codecs } = parseInput(args[0])\\n          // This specific mp4 codec is missing in Chromium\\n          if (mime === 'video/mp4') {\\n            if (codecs.includes('avc1.42E01E')) {\\n              return 'probably'\\n            }\\n          }\\n          // This mimetype is only supported if no codecs are specified\\n          if (mime === 'audio/x-m4a' && !codecs.length) {\\n            return 'maybe'\\n          }\\n\\n          // This mimetype is only supported if no codecs are specified\\n          if (mime === 'audio/aac' && !codecs.length) {\\n            return 'probably'\\n          }\\n          // Everything else as usual\\n          return target.apply(ctx, args)\\n        }\\n      }\\n\\n      /* global HTMLMediaElement */\\n      utils.replaceWithProxy(\\n        HTMLMediaElement.prototype,\\n        'canPlayType',\\n        canPlayType\\n      )\\n    }\",\"_args\":[]})"},"stack":[{"file":"/home/neetoci/neeto-chat-web/playwright-tests/node_modules/@bigbinary/neeto-playwright-commons/node_modules/playwright-extra/dist/index.esm.js","line":230,"column":32,"function":"Proxy.<anonymous>"}]}
{"type":"before","callId":"pw:api@19","parentId":"fixture@11","startTime":87019.325,"class":"Test","method":"step","apiName":"page.addInitScript","params":{"source":"(({ _utilsFns, _mainFunction, _args }) => {\n        // Add this point we cannot use our utililty functions as they're just strings, we need to materialize them first\n        const utils = Object.fromEntries(\n          Object.entries(_utilsFns).map(([key, value]) => [key, eval(value)]) // eslint-disable-line no-eval\n        )\n        utils.init()\n        return eval(_mainFunction)(utils, ..._args) // eslint-disable-line no-eval\n      })({\"_utilsFns\":{\"init\":\"() => {\\n  utils.preloadCache()\\n}\",\"stripProxyFromErrors\":\"(handler = {}) => {\\n  const newHandler = {\\n    setPrototypeOf: function (target, proto) {\\n      if (proto === null)\\n        throw new TypeError('Cannot convert object to primitive value')\\n      if (Object.getPrototypeOf(target) === Object.getPrototypeOf(proto)) {\\n        throw new TypeError('Cyclic __proto__ value')\\n      }\\n      return Reflect.setPrototypeOf(target, proto)\\n    }\\n  }\\n  // We wrap each trap in the handler in a try/catch and modify the error stack if they throw\\n  const traps = Object.getOwnPropertyNames(handler)\\n  traps.forEach(trap => {\\n    newHandler[trap] = function () {\\n      try {\\n        // Forward the call to the defined proxy handler\\n        return handler[trap].apply(this, arguments || [])\\n      } catch (err) {\\n        // Stack traces differ per browser, we only support chromium based ones currently\\n        if (!err || !err.stack || !err.stack.includes(`at `)) {\\n          throw err\\n        }\\n\\n        // When something throws within one of our traps the Proxy will show up in error stacks\\n        // An earlier implementation of this code would simply strip lines with a blacklist,\\n        // but it makes sense to be more surgical here and only remove lines related to our Proxy.\\n        // We try to use a known \\\"anchor\\\" line for that and strip it with everything above it.\\n        // If the anchor line cannot be found for some reason we fall back to our blacklist approach.\\n\\n        const stripWithBlacklist = (stack, stripFirstLine = true) => {\\n          const blacklist = [\\n            `at Reflect.${trap} `, // e.g. Reflect.get or Reflect.apply\\n            `at Object.${trap} `, // e.g. Object.get or Object.apply\\n            `at Object.newHandler.<computed> [as ${trap}] ` // caused by this very wrapper :-)\\n          ]\\n          return (\\n            err.stack\\n              .split('\\\\n')\\n              // Always remove the first (file) line in the stack (guaranteed to be our proxy)\\n              .filter((line, index) => !(index === 1 && stripFirstLine))\\n              // Check if the line starts with one of our blacklisted strings\\n              .filter(line => !blacklist.some(bl => line.trim().startsWith(bl)))\\n              .join('\\\\n')\\n          )\\n        }\\n\\n        const stripWithAnchor = (stack, anchor) => {\\n          const stackArr = stack.split('\\\\n')\\n          anchor = anchor || `at Object.newHandler.<computed> [as ${trap}] ` // Known first Proxy line in chromium\\n          const anchorIndex = stackArr.findIndex(line =>\\n            line.trim().startsWith(anchor)\\n          )\\n          if (anchorIndex === -1) {\\n            return false // 404, anchor not found\\n          }\\n          // Strip everything from the top until we reach the anchor line\\n          // Note: We're keeping the 1st line (zero index) as it's unrelated (e.g. `TypeError`)\\n          stackArr.splice(1, anchorIndex)\\n          return stackArr.join('\\\\n')\\n        }\\n\\n        // Special cases due to our nested toString proxies\\n        err.stack = err.stack.replace(\\n          'at Object.toString (',\\n          'at Function.toString ('\\n        )\\n        if ((err.stack || '').includes('at Function.toString (')) {\\n          err.stack = stripWithBlacklist(err.stack, false)\\n          throw err\\n        }\\n\\n        // Try using the anchor method, fallback to blacklist if necessary\\n        err.stack = stripWithAnchor(err.stack) || stripWithBlacklist(err.stack)\\n\\n        throw err // Re-throw our now sanitized error\\n      }\\n    }\\n  })\\n  return newHandler\\n}\",\"stripErrorWithAnchor\":\"(err, anchor) => {\\n  const stackArr = err.stack.split('\\\\n')\\n  const anchorIndex = stackArr.findIndex(line => line.trim().startsWith(anchor))\\n  if (anchorIndex === -1) {\\n    return err // 404, anchor not found\\n  }\\n  // Strip everything from the top until we reach the anchor line (remove anchor line as well)\\n  // Note: We're keeping the 1st line (zero index) as it's unrelated (e.g. `TypeError`)\\n  stackArr.splice(1, anchorIndex)\\n  err.stack = stackArr.join('\\\\n')\\n  return err\\n}\",\"replaceProperty\":\"(obj, propName, descriptorOverrides = {}) => {\\n  return Object.defineProperty(obj, propName, {\\n    // Copy over the existing descriptors (writable, enumerable, configurable, etc)\\n    ...(Object.getOwnPropertyDescriptor(obj, propName) || {}),\\n    // Add our overrides (e.g. value, get())\\n    ...descriptorOverrides\\n  })\\n}\",\"preloadCache\":\"() => {\\n  if (utils.cache) {\\n    return\\n  }\\n  utils.cache = {\\n    // Used in our proxies\\n    Reflect: {\\n      get: Reflect.get.bind(Reflect),\\n      apply: Reflect.apply.bind(Reflect)\\n    },\\n    // Used in `makeNativeString`\\n    nativeToStringStr: Function.toString + '' // => `function toString() { [native code] }`\\n  }\\n}\",\"makeNativeString\":\"(name = '') => {\\n  return utils.cache.nativeToStringStr.replace('toString', name || '')\\n}\",\"patchToString\":\"(obj, str = '') => {\\n  const handler = {\\n    apply: function (target, ctx) {\\n      // This fixes e.g. `HTMLMediaElement.prototype.canPlayType.toString + \\\"\\\"`\\n      if (ctx === Function.prototype.toString) {\\n        return utils.makeNativeString('toString')\\n      }\\n      // `toString` targeted at our proxied Object detected\\n      if (ctx === obj) {\\n        // We either return the optional string verbatim or derive the most desired result automatically\\n        return str || utils.makeNativeString(obj.name)\\n      }\\n      // Check if the toString protype of the context is the same as the global prototype,\\n      // if not indicates that we are doing a check across different windows., e.g. the iframeWithdirect` test case\\n      const hasSameProto = Object.getPrototypeOf(\\n        Function.prototype.toString\\n      ).isPrototypeOf(ctx.toString) // eslint-disable-line no-prototype-builtins\\n      if (!hasSameProto) {\\n        // Pass the call on to the local Function.prototype.toString instead\\n        return ctx.toString()\\n      }\\n      return target.call(ctx)\\n    }\\n  }\\n\\n  const toStringProxy = new Proxy(\\n    Function.prototype.toString,\\n    utils.stripProxyFromErrors(handler)\\n  )\\n  utils.replaceProperty(Function.prototype, 'toString', {\\n    value: toStringProxy\\n  })\\n}\",\"patchToStringNested\":\"(obj = {}) => {\\n  return utils.execRecursively(obj, ['function'], utils.patchToString)\\n}\",\"redirectToString\":\"(proxyObj, originalObj) => {\\n  const handler = {\\n    apply: function (target, ctx) {\\n      // This fixes e.g. `HTMLMediaElement.prototype.canPlayType.toString + \\\"\\\"`\\n      if (ctx === Function.prototype.toString) {\\n        return utils.makeNativeString('toString')\\n      }\\n\\n      // `toString` targeted at our proxied Object detected\\n      if (ctx === proxyObj) {\\n        const fallback = () =>\\n          originalObj && originalObj.name\\n            ? utils.makeNativeString(originalObj.name)\\n            : utils.makeNativeString(proxyObj.name)\\n\\n        // Return the toString representation of our original object if possible\\n        return originalObj + '' || fallback()\\n      }\\n\\n      if (typeof ctx === 'undefined' || ctx === null) {\\n        return target.call(ctx)\\n      }\\n\\n      // Check if the toString protype of the context is the same as the global prototype,\\n      // if not indicates that we are doing a check across different windows., e.g. the iframeWithdirect` test case\\n      const hasSameProto = Object.getPrototypeOf(\\n        Function.prototype.toString\\n      ).isPrototypeOf(ctx.toString) // eslint-disable-line no-prototype-builtins\\n      if (!hasSameProto) {\\n        // Pass the call on to the local Function.prototype.toString instead\\n        return ctx.toString()\\n      }\\n\\n      return target.call(ctx)\\n    }\\n  }\\n\\n  const toStringProxy = new Proxy(\\n    Function.prototype.toString,\\n    utils.stripProxyFromErrors(handler)\\n  )\\n  utils.replaceProperty(Function.prototype, 'toString', {\\n    value: toStringProxy\\n  })\\n}\",\"replaceWithProxy\":\"(obj, propName, handler) => {\\n  const originalObj = obj[propName]\\n  const proxyObj = new Proxy(obj[propName], utils.stripProxyFromErrors(handler))\\n\\n  utils.replaceProperty(obj, propName, { value: proxyObj })\\n  utils.redirectToString(proxyObj, originalObj)\\n\\n  return true\\n}\",\"replaceGetterWithProxy\":\"(obj, propName, handler) => {\\n  const fn = Object.getOwnPropertyDescriptor(obj, propName).get\\n  const fnStr = fn.toString() // special getter function string\\n  const proxyObj = new Proxy(fn, utils.stripProxyFromErrors(handler))\\n\\n  utils.replaceProperty(obj, propName, { get: proxyObj })\\n  utils.patchToString(proxyObj, fnStr)\\n\\n  return true\\n}\",\"replaceGetterSetter\":\"(obj, propName, handlerGetterSetter) => {\\n  const ownPropertyDescriptor = Object.getOwnPropertyDescriptor(obj, propName)\\n  const handler = { ...ownPropertyDescriptor }\\n\\n  if (handlerGetterSetter.get !== undefined) {\\n    const nativeFn = ownPropertyDescriptor.get\\n    handler.get = function() {\\n      return handlerGetterSetter.get.call(this, nativeFn.bind(this))\\n    }\\n    utils.redirectToString(handler.get, nativeFn)\\n  }\\n\\n  if (handlerGetterSetter.set !== undefined) {\\n    const nativeFn = ownPropertyDescriptor.set\\n    handler.set = function(newValue) {\\n      handlerGetterSetter.set.call(this, newValue, nativeFn.bind(this))\\n    }\\n    utils.redirectToString(handler.set, nativeFn)\\n  }\\n\\n  Object.defineProperty(obj, propName, handler)\\n}\",\"mockWithProxy\":\"(obj, propName, pseudoTarget, handler) => {\\n  const proxyObj = new Proxy(pseudoTarget, utils.stripProxyFromErrors(handler))\\n\\n  utils.replaceProperty(obj, propName, { value: proxyObj })\\n  utils.patchToString(proxyObj)\\n\\n  return true\\n}\",\"createProxy\":\"(pseudoTarget, handler) => {\\n  const proxyObj = new Proxy(pseudoTarget, utils.stripProxyFromErrors(handler))\\n  utils.patchToString(proxyObj)\\n\\n  return proxyObj\\n}\",\"splitObjPath\":\"objPath => ({\\n  // Remove last dot entry (property) ==> `HTMLMediaElement.prototype`\\n  objName: objPath.split('.').slice(0, -1).join('.'),\\n  // Extract last dot entry ==> `canPlayType`\\n  propName: objPath.split('.').slice(-1)[0]\\n})\",\"replaceObjPathWithProxy\":\"(objPath, handler) => {\\n  const { objName, propName } = utils.splitObjPath(objPath)\\n  const obj = eval(objName) // eslint-disable-line no-eval\\n  return utils.replaceWithProxy(obj, propName, handler)\\n}\",\"execRecursively\":\"(obj = {}, typeFilter = [], fn) => {\\n  function recurse(obj) {\\n    for (const key in obj) {\\n      if (obj[key] === undefined) {\\n        continue\\n      }\\n      if (obj[key] && typeof obj[key] === 'object') {\\n        recurse(obj[key])\\n      } else {\\n        if (obj[key] && typeFilter.includes(typeof obj[key])) {\\n          fn.call(this, obj[key])\\n        }\\n      }\\n    }\\n  }\\n  recurse(obj)\\n  return obj\\n}\",\"stringifyFns\":\"(fnObj = { hello: () => 'world' }) => {\\n  // Object.fromEntries() ponyfill (in 6 lines) - supported only in Node v12+, modern browsers are fine\\n  // https://github.com/feross/fromentries\\n  function fromEntries(iterable) {\\n    return [...iterable].reduce((obj, [key, val]) => {\\n      obj[key] = val\\n      return obj\\n    }, {})\\n  }\\n  return (Object.fromEntries || fromEntries)(\\n    Object.entries(fnObj)\\n      .filter(([key, value]) => typeof value === 'function')\\n      .map(([key, value]) => [key, value.toString()]) // eslint-disable-line no-eval\\n  )\\n}\",\"materializeFns\":\"(fnStrObj = { hello: \\\"() => 'world'\\\" }) => {\\n  return Object.fromEntries(\\n    Object.entries(fnStrObj).map(([key, value]) => {\\n      if (value.startsWith('function')) {\\n        // some trickery is needed to make oldschool functions work :-)\\n        return [key, eval(`() => ${value}`)()] // eslint-disable-line no-eval\\n      } else {\\n        // arrow functions just work\\n        return [key, eval(value)] // eslint-disable-line no-eval\\n      }\\n    })\\n  )\\n}\",\"makeHandler\":\"() => ({\\n  // Used by simple `navigator` getter evasions\\n  getterValue: value => ({\\n    apply(target, ctx, args) {\\n      // Let's fetch the value first, to trigger and escalate potential errors\\n      // Illegal invocations like `navigator.__proto__.vendor` will throw here\\n      utils.cache.Reflect.apply(...arguments)\\n      return value\\n    }\\n  })\\n})\",\"arrayEquals\":\"(array1, array2) => {\\n  if (array1.length !== array2.length) {\\n    return false\\n  }\\n  for (let i = 0; i < array1.length; ++i) {\\n    if (array1[i] !== array2[i]) {\\n      return false\\n    }\\n  }\\n  return true\\n}\",\"memoize\":\"fn => {\\n  const cache = []\\n  return function(...args) {\\n    if (!cache.some(c => utils.arrayEquals(c.key, args))) {\\n      cache.push({ key: args, value: fn.apply(this, args) })\\n    }\\n    return cache.find(c => utils.arrayEquals(c.key, args)).value\\n  }\\n}\"},\"_mainFunction\":\"(utils, { opts }) => {\\n        utils.replaceGetterWithProxy(\\n          Object.getPrototypeOf(navigator),\\n          'hardwareConcurrency',\\n          utils.makeHandler().getterValue(opts.hardwareConcurrency)\\n        )\\n      }\",\"_args\":[{\"opts\":{\"hardwareConcurrency\":4}}]})"},"stack":[{"file":"/home/neetoci/neeto-chat-web/playwright-tests/node_modules/@bigbinary/neeto-playwright-commons/node_modules/playwright-extra/dist/index.esm.js","line":230,"column":32,"function":"Proxy.<anonymous>"}]}
{"type":"before","callId":"pw:api@20","parentId":"fixture@11","startTime":87019.908,"class":"Test","method":"step","apiName":"page.addInitScript","params":{"source":"(({ _utilsFns, _mainFunction, _args }) => {\n        // Add this point we cannot use our utililty functions as they're just strings, we need to materialize them first\n        const utils = Object.fromEntries(\n          Object.entries(_utilsFns).map(([key, value]) => [key, eval(value)]) // eslint-disable-line no-eval\n        )\n        utils.init()\n        return eval(_mainFunction)(utils, ..._args) // eslint-disable-line no-eval\n      })({\"_utilsFns\":{\"init\":\"() => {\\n  utils.preloadCache()\\n}\",\"stripProxyFromErrors\":\"(handler = {}) => {\\n  const newHandler = {\\n    setPrototypeOf: function (target, proto) {\\n      if (proto === null)\\n        throw new TypeError('Cannot convert object to primitive value')\\n      if (Object.getPrototypeOf(target) === Object.getPrototypeOf(proto)) {\\n        throw new TypeError('Cyclic __proto__ value')\\n      }\\n      return Reflect.setPrototypeOf(target, proto)\\n    }\\n  }\\n  // We wrap each trap in the handler in a try/catch and modify the error stack if they throw\\n  const traps = Object.getOwnPropertyNames(handler)\\n  traps.forEach(trap => {\\n    newHandler[trap] = function () {\\n      try {\\n        // Forward the call to the defined proxy handler\\n        return handler[trap].apply(this, arguments || [])\\n      } catch (err) {\\n        // Stack traces differ per browser, we only support chromium based ones currently\\n        if (!err || !err.stack || !err.stack.includes(`at `)) {\\n          throw err\\n        }\\n\\n        // When something throws within one of our traps the Proxy will show up in error stacks\\n        // An earlier implementation of this code would simply strip lines with a blacklist,\\n        // but it makes sense to be more surgical here and only remove lines related to our Proxy.\\n        // We try to use a known \\\"anchor\\\" line for that and strip it with everything above it.\\n        // If the anchor line cannot be found for some reason we fall back to our blacklist approach.\\n\\n        const stripWithBlacklist = (stack, stripFirstLine = true) => {\\n          const blacklist = [\\n            `at Reflect.${trap} `, // e.g. Reflect.get or Reflect.apply\\n            `at Object.${trap} `, // e.g. Object.get or Object.apply\\n            `at Object.newHandler.<computed> [as ${trap}] ` // caused by this very wrapper :-)\\n          ]\\n          return (\\n            err.stack\\n              .split('\\\\n')\\n              // Always remove the first (file) line in the stack (guaranteed to be our proxy)\\n              .filter((line, index) => !(index === 1 && stripFirstLine))\\n              // Check if the line starts with one of our blacklisted strings\\n              .filter(line => !blacklist.some(bl => line.trim().startsWith(bl)))\\n              .join('\\\\n')\\n          )\\n        }\\n\\n        const stripWithAnchor = (stack, anchor) => {\\n          const stackArr = stack.split('\\\\n')\\n          anchor = anchor || `at Object.newHandler.<computed> [as ${trap}] ` // Known first Proxy line in chromium\\n          const anchorIndex = stackArr.findIndex(line =>\\n            line.trim().startsWith(anchor)\\n          )\\n          if (anchorIndex === -1) {\\n            return false // 404, anchor not found\\n          }\\n          // Strip everything from the top until we reach the anchor line\\n          // Note: We're keeping the 1st line (zero index) as it's unrelated (e.g. `TypeError`)\\n          stackArr.splice(1, anchorIndex)\\n          return stackArr.join('\\\\n')\\n        }\\n\\n        // Special cases due to our nested toString proxies\\n        err.stack = err.stack.replace(\\n          'at Object.toString (',\\n          'at Function.toString ('\\n        )\\n        if ((err.stack || '').includes('at Function.toString (')) {\\n          err.stack = stripWithBlacklist(err.stack, false)\\n          throw err\\n        }\\n\\n        // Try using the anchor method, fallback to blacklist if necessary\\n        err.stack = stripWithAnchor(err.stack) || stripWithBlacklist(err.stack)\\n\\n        throw err // Re-throw our now sanitized error\\n      }\\n    }\\n  })\\n  return newHandler\\n}\",\"stripErrorWithAnchor\":\"(err, anchor) => {\\n  const stackArr = err.stack.split('\\\\n')\\n  const anchorIndex = stackArr.findIndex(line => line.trim().startsWith(anchor))\\n  if (anchorIndex === -1) {\\n    return err // 404, anchor not found\\n  }\\n  // Strip everything from the top until we reach the anchor line (remove anchor line as well)\\n  // Note: We're keeping the 1st line (zero index) as it's unrelated (e.g. `TypeError`)\\n  stackArr.splice(1, anchorIndex)\\n  err.stack = stackArr.join('\\\\n')\\n  return err\\n}\",\"replaceProperty\":\"(obj, propName, descriptorOverrides = {}) => {\\n  return Object.defineProperty(obj, propName, {\\n    // Copy over the existing descriptors (writable, enumerable, configurable, etc)\\n    ...(Object.getOwnPropertyDescriptor(obj, propName) || {}),\\n    // Add our overrides (e.g. value, get())\\n    ...descriptorOverrides\\n  })\\n}\",\"preloadCache\":\"() => {\\n  if (utils.cache) {\\n    return\\n  }\\n  utils.cache = {\\n    // Used in our proxies\\n    Reflect: {\\n      get: Reflect.get.bind(Reflect),\\n      apply: Reflect.apply.bind(Reflect)\\n    },\\n    // Used in `makeNativeString`\\n    nativeToStringStr: Function.toString + '' // => `function toString() { [native code] }`\\n  }\\n}\",\"makeNativeString\":\"(name = '') => {\\n  return utils.cache.nativeToStringStr.replace('toString', name || '')\\n}\",\"patchToString\":\"(obj, str = '') => {\\n  const handler = {\\n    apply: function (target, ctx) {\\n      // This fixes e.g. `HTMLMediaElement.prototype.canPlayType.toString + \\\"\\\"`\\n      if (ctx === Function.prototype.toString) {\\n        return utils.makeNativeString('toString')\\n      }\\n      // `toString` targeted at our proxied Object detected\\n      if (ctx === obj) {\\n        // We either return the optional string verbatim or derive the most desired result automatically\\n        return str || utils.makeNativeString(obj.name)\\n      }\\n      // Check if the toString protype of the context is the same as the global prototype,\\n      // if not indicates that we are doing a check across different windows., e.g. the iframeWithdirect` test case\\n      const hasSameProto = Object.getPrototypeOf(\\n        Function.prototype.toString\\n      ).isPrototypeOf(ctx.toString) // eslint-disable-line no-prototype-builtins\\n      if (!hasSameProto) {\\n        // Pass the call on to the local Function.prototype.toString instead\\n        return ctx.toString()\\n      }\\n      return target.call(ctx)\\n    }\\n  }\\n\\n  const toStringProxy = new Proxy(\\n    Function.prototype.toString,\\n    utils.stripProxyFromErrors(handler)\\n  )\\n  utils.replaceProperty(Function.prototype, 'toString', {\\n    value: toStringProxy\\n  })\\n}\",\"patchToStringNested\":\"(obj = {}) => {\\n  return utils.execRecursively(obj, ['function'], utils.patchToString)\\n}\",\"redirectToString\":\"(proxyObj, originalObj) => {\\n  const handler = {\\n    apply: function (target, ctx) {\\n      // This fixes e.g. `HTMLMediaElement.prototype.canPlayType.toString + \\\"\\\"`\\n      if (ctx === Function.prototype.toString) {\\n        return utils.makeNativeString('toString')\\n      }\\n\\n      // `toString` targeted at our proxied Object detected\\n      if (ctx === proxyObj) {\\n        const fallback = () =>\\n          originalObj && originalObj.name\\n            ? utils.makeNativeString(originalObj.name)\\n            : utils.makeNativeString(proxyObj.name)\\n\\n        // Return the toString representation of our original object if possible\\n        return originalObj + '' || fallback()\\n      }\\n\\n      if (typeof ctx === 'undefined' || ctx === null) {\\n        return target.call(ctx)\\n      }\\n\\n      // Check if the toString protype of the context is the same as the global prototype,\\n      // if not indicates that we are doing a check across different windows., e.g. the iframeWithdirect` test case\\n      const hasSameProto = Object.getPrototypeOf(\\n        Function.prototype.toString\\n      ).isPrototypeOf(ctx.toString) // eslint-disable-line no-prototype-builtins\\n      if (!hasSameProto) {\\n        // Pass the call on to the local Function.prototype.toString instead\\n        return ctx.toString()\\n      }\\n\\n      return target.call(ctx)\\n    }\\n  }\\n\\n  const toStringProxy = new Proxy(\\n    Function.prototype.toString,\\n    utils.stripProxyFromErrors(handler)\\n  )\\n  utils.replaceProperty(Function.prototype, 'toString', {\\n    value: toStringProxy\\n  })\\n}\",\"replaceWithProxy\":\"(obj, propName, handler) => {\\n  const originalObj = obj[propName]\\n  const proxyObj = new Proxy(obj[propName], utils.stripProxyFromErrors(handler))\\n\\n  utils.replaceProperty(obj, propName, { value: proxyObj })\\n  utils.redirectToString(proxyObj, originalObj)\\n\\n  return true\\n}\",\"replaceGetterWithProxy\":\"(obj, propName, handler) => {\\n  const fn = Object.getOwnPropertyDescriptor(obj, propName).get\\n  const fnStr = fn.toString() // special getter function string\\n  const proxyObj = new Proxy(fn, utils.stripProxyFromErrors(handler))\\n\\n  utils.replaceProperty(obj, propName, { get: proxyObj })\\n  utils.patchToString(proxyObj, fnStr)\\n\\n  return true\\n}\",\"replaceGetterSetter\":\"(obj, propName, handlerGetterSetter) => {\\n  const ownPropertyDescriptor = Object.getOwnPropertyDescriptor(obj, propName)\\n  const handler = { ...ownPropertyDescriptor }\\n\\n  if (handlerGetterSetter.get !== undefined) {\\n    const nativeFn = ownPropertyDescriptor.get\\n    handler.get = function() {\\n      return handlerGetterSetter.get.call(this, nativeFn.bind(this))\\n    }\\n    utils.redirectToString(handler.get, nativeFn)\\n  }\\n\\n  if (handlerGetterSetter.set !== undefined) {\\n    const nativeFn = ownPropertyDescriptor.set\\n    handler.set = function(newValue) {\\n      handlerGetterSetter.set.call(this, newValue, nativeFn.bind(this))\\n    }\\n    utils.redirectToString(handler.set, nativeFn)\\n  }\\n\\n  Object.defineProperty(obj, propName, handler)\\n}\",\"mockWithProxy\":\"(obj, propName, pseudoTarget, handler) => {\\n  const proxyObj = new Proxy(pseudoTarget, utils.stripProxyFromErrors(handler))\\n\\n  utils.replaceProperty(obj, propName, { value: proxyObj })\\n  utils.patchToString(proxyObj)\\n\\n  return true\\n}\",\"createProxy\":\"(pseudoTarget, handler) => {\\n  const proxyObj = new Proxy(pseudoTarget, utils.stripProxyFromErrors(handler))\\n  utils.patchToString(proxyObj)\\n\\n  return proxyObj\\n}\",\"splitObjPath\":\"objPath => ({\\n  // Remove last dot entry (property) ==> `HTMLMediaElement.prototype`\\n  objName: objPath.split('.').slice(0, -1).join('.'),\\n  // Extract last dot entry ==> `canPlayType`\\n  propName: objPath.split('.').slice(-1)[0]\\n})\",\"replaceObjPathWithProxy\":\"(objPath, handler) => {\\n  const { objName, propName } = utils.splitObjPath(objPath)\\n  const obj = eval(objName) // eslint-disable-line no-eval\\n  return utils.replaceWithProxy(obj, propName, handler)\\n}\",\"execRecursively\":\"(obj = {}, typeFilter = [], fn) => {\\n  function recurse(obj) {\\n    for (const key in obj) {\\n      if (obj[key] === undefined) {\\n        continue\\n      }\\n      if (obj[key] && typeof obj[key] === 'object') {\\n        recurse(obj[key])\\n      } else {\\n        if (obj[key] && typeFilter.includes(typeof obj[key])) {\\n          fn.call(this, obj[key])\\n        }\\n      }\\n    }\\n  }\\n  recurse(obj)\\n  return obj\\n}\",\"stringifyFns\":\"(fnObj = { hello: () => 'world' }) => {\\n  // Object.fromEntries() ponyfill (in 6 lines) - supported only in Node v12+, modern browsers are fine\\n  // https://github.com/feross/fromentries\\n  function fromEntries(iterable) {\\n    return [...iterable].reduce((obj, [key, val]) => {\\n      obj[key] = val\\n      return obj\\n    }, {})\\n  }\\n  return (Object.fromEntries || fromEntries)(\\n    Object.entries(fnObj)\\n      .filter(([key, value]) => typeof value === 'function')\\n      .map(([key, value]) => [key, value.toString()]) // eslint-disable-line no-eval\\n  )\\n}\",\"materializeFns\":\"(fnStrObj = { hello: \\\"() => 'world'\\\" }) => {\\n  return Object.fromEntries(\\n    Object.entries(fnStrObj).map(([key, value]) => {\\n      if (value.startsWith('function')) {\\n        // some trickery is needed to make oldschool functions work :-)\\n        return [key, eval(`() => ${value}`)()] // eslint-disable-line no-eval\\n      } else {\\n        // arrow functions just work\\n        return [key, eval(value)] // eslint-disable-line no-eval\\n      }\\n    })\\n  )\\n}\",\"makeHandler\":\"() => ({\\n  // Used by simple `navigator` getter evasions\\n  getterValue: value => ({\\n    apply(target, ctx, args) {\\n      // Let's fetch the value first, to trigger and escalate potential errors\\n      // Illegal invocations like `navigator.__proto__.vendor` will throw here\\n      utils.cache.Reflect.apply(...arguments)\\n      return value\\n    }\\n  })\\n})\",\"arrayEquals\":\"(array1, array2) => {\\n  if (array1.length !== array2.length) {\\n    return false\\n  }\\n  for (let i = 0; i < array1.length; ++i) {\\n    if (array1[i] !== array2[i]) {\\n      return false\\n    }\\n  }\\n  return true\\n}\",\"memoize\":\"fn => {\\n  const cache = []\\n  return function(...args) {\\n    if (!cache.some(c => utils.arrayEquals(c.key, args))) {\\n      cache.push({ key: args, value: fn.apply(this, args) })\\n    }\\n    return cache.find(c => utils.arrayEquals(c.key, args)).value\\n  }\\n}\"},\"_mainFunction\":\"(utils, { opts }) => {\\n        const languages = opts.languages.length\\n          ? opts.languages\\n          : ['en-US', 'en']\\n        utils.replaceGetterWithProxy(\\n          Object.getPrototypeOf(navigator),\\n          'languages',\\n          utils.makeHandler().getterValue(Object.freeze([...languages]))\\n        )\\n      }\",\"_args\":[{\"opts\":{\"languages\":[]}}]})"},"stack":[{"file":"/home/neetoci/neeto-chat-web/playwright-tests/node_modules/@bigbinary/neeto-playwright-commons/node_modules/playwright-extra/dist/index.esm.js","line":230,"column":32,"function":"Proxy.<anonymous>"}]}
{"type":"before","callId":"pw:api@21","parentId":"fixture@11","startTime":87020.385,"class":"Test","method":"step","apiName":"page.addInitScript","params":{"source":"(({ _utilsFns, _mainFunction, _args }) => {\n        // Add this point we cannot use our utililty functions as they're just strings, we need to materialize them first\n        const utils = Object.fromEntries(\n          Object.entries(_utilsFns).map(([key, value]) => [key, eval(value)]) // eslint-disable-line no-eval\n        )\n        utils.init()\n        return eval(_mainFunction)(utils, ..._args) // eslint-disable-line no-eval\n      })({\"_utilsFns\":{\"init\":\"() => {\\n  utils.preloadCache()\\n}\",\"stripProxyFromErrors\":\"(handler = {}) => {\\n  const newHandler = {\\n    setPrototypeOf: function (target, proto) {\\n      if (proto === null)\\n        throw new TypeError('Cannot convert object to primitive value')\\n      if (Object.getPrototypeOf(target) === Object.getPrototypeOf(proto)) {\\n        throw new TypeError('Cyclic __proto__ value')\\n      }\\n      return Reflect.setPrototypeOf(target, proto)\\n    }\\n  }\\n  // We wrap each trap in the handler in a try/catch and modify the error stack if they throw\\n  const traps = Object.getOwnPropertyNames(handler)\\n  traps.forEach(trap => {\\n    newHandler[trap] = function () {\\n      try {\\n        // Forward the call to the defined proxy handler\\n        return handler[trap].apply(this, arguments || [])\\n      } catch (err) {\\n        // Stack traces differ per browser, we only support chromium based ones currently\\n        if (!err || !err.stack || !err.stack.includes(`at `)) {\\n          throw err\\n        }\\n\\n        // When something throws within one of our traps the Proxy will show up in error stacks\\n        // An earlier implementation of this code would simply strip lines with a blacklist,\\n        // but it makes sense to be more surgical here and only remove lines related to our Proxy.\\n        // We try to use a known \\\"anchor\\\" line for that and strip it with everything above it.\\n        // If the anchor line cannot be found for some reason we fall back to our blacklist approach.\\n\\n        const stripWithBlacklist = (stack, stripFirstLine = true) => {\\n          const blacklist = [\\n            `at Reflect.${trap} `, // e.g. Reflect.get or Reflect.apply\\n            `at Object.${trap} `, // e.g. Object.get or Object.apply\\n            `at Object.newHandler.<computed> [as ${trap}] ` // caused by this very wrapper :-)\\n          ]\\n          return (\\n            err.stack\\n              .split('\\\\n')\\n              // Always remove the first (file) line in the stack (guaranteed to be our proxy)\\n              .filter((line, index) => !(index === 1 && stripFirstLine))\\n              // Check if the line starts with one of our blacklisted strings\\n              .filter(line => !blacklist.some(bl => line.trim().startsWith(bl)))\\n              .join('\\\\n')\\n          )\\n        }\\n\\n        const stripWithAnchor = (stack, anchor) => {\\n          const stackArr = stack.split('\\\\n')\\n          anchor = anchor || `at Object.newHandler.<computed> [as ${trap}] ` // Known first Proxy line in chromium\\n          const anchorIndex = stackArr.findIndex(line =>\\n            line.trim().startsWith(anchor)\\n          )\\n          if (anchorIndex === -1) {\\n            return false // 404, anchor not found\\n          }\\n          // Strip everything from the top until we reach the anchor line\\n          // Note: We're keeping the 1st line (zero index) as it's unrelated (e.g. `TypeError`)\\n          stackArr.splice(1, anchorIndex)\\n          return stackArr.join('\\\\n')\\n        }\\n\\n        // Special cases due to our nested toString proxies\\n        err.stack = err.stack.replace(\\n          'at Object.toString (',\\n          'at Function.toString ('\\n        )\\n        if ((err.stack || '').includes('at Function.toString (')) {\\n          err.stack = stripWithBlacklist(err.stack, false)\\n          throw err\\n        }\\n\\n        // Try using the anchor method, fallback to blacklist if necessary\\n        err.stack = stripWithAnchor(err.stack) || stripWithBlacklist(err.stack)\\n\\n        throw err // Re-throw our now sanitized error\\n      }\\n    }\\n  })\\n  return newHandler\\n}\",\"stripErrorWithAnchor\":\"(err, anchor) => {\\n  const stackArr = err.stack.split('\\\\n')\\n  const anchorIndex = stackArr.findIndex(line => line.trim().startsWith(anchor))\\n  if (anchorIndex === -1) {\\n    return err // 404, anchor not found\\n  }\\n  // Strip everything from the top until we reach the anchor line (remove anchor line as well)\\n  // Note: We're keeping the 1st line (zero index) as it's unrelated (e.g. `TypeError`)\\n  stackArr.splice(1, anchorIndex)\\n  err.stack = stackArr.join('\\\\n')\\n  return err\\n}\",\"replaceProperty\":\"(obj, propName, descriptorOverrides = {}) => {\\n  return Object.defineProperty(obj, propName, {\\n    // Copy over the existing descriptors (writable, enumerable, configurable, etc)\\n    ...(Object.getOwnPropertyDescriptor(obj, propName) || {}),\\n    // Add our overrides (e.g. value, get())\\n    ...descriptorOverrides\\n  })\\n}\",\"preloadCache\":\"() => {\\n  if (utils.cache) {\\n    return\\n  }\\n  utils.cache = {\\n    // Used in our proxies\\n    Reflect: {\\n      get: Reflect.get.bind(Reflect),\\n      apply: Reflect.apply.bind(Reflect)\\n    },\\n    // Used in `makeNativeString`\\n    nativeToStringStr: Function.toString + '' // => `function toString() { [native code] }`\\n  }\\n}\",\"makeNativeString\":\"(name = '') => {\\n  return utils.cache.nativeToStringStr.replace('toString', name || '')\\n}\",\"patchToString\":\"(obj, str = '') => {\\n  const handler = {\\n    apply: function (target, ctx) {\\n      // This fixes e.g. `HTMLMediaElement.prototype.canPlayType.toString + \\\"\\\"`\\n      if (ctx === Function.prototype.toString) {\\n        return utils.makeNativeString('toString')\\n      }\\n      // `toString` targeted at our proxied Object detected\\n      if (ctx === obj) {\\n        // We either return the optional string verbatim or derive the most desired result automatically\\n        return str || utils.makeNativeString(obj.name)\\n      }\\n      // Check if the toString protype of the context is the same as the global prototype,\\n      // if not indicates that we are doing a check across different windows., e.g. the iframeWithdirect` test case\\n      const hasSameProto = Object.getPrototypeOf(\\n        Function.prototype.toString\\n      ).isPrototypeOf(ctx.toString) // eslint-disable-line no-prototype-builtins\\n      if (!hasSameProto) {\\n        // Pass the call on to the local Function.prototype.toString instead\\n        return ctx.toString()\\n      }\\n      return target.call(ctx)\\n    }\\n  }\\n\\n  const toStringProxy = new Proxy(\\n    Function.prototype.toString,\\n    utils.stripProxyFromErrors(handler)\\n  )\\n  utils.replaceProperty(Function.prototype, 'toString', {\\n    value: toStringProxy\\n  })\\n}\",\"patchToStringNested\":\"(obj = {}) => {\\n  return utils.execRecursively(obj, ['function'], utils.patchToString)\\n}\",\"redirectToString\":\"(proxyObj, originalObj) => {\\n  const handler = {\\n    apply: function (target, ctx) {\\n      // This fixes e.g. `HTMLMediaElement.prototype.canPlayType.toString + \\\"\\\"`\\n      if (ctx === Function.prototype.toString) {\\n        return utils.makeNativeString('toString')\\n      }\\n\\n      // `toString` targeted at our proxied Object detected\\n      if (ctx === proxyObj) {\\n        const fallback = () =>\\n          originalObj && originalObj.name\\n            ? utils.makeNativeString(originalObj.name)\\n            : utils.makeNativeString(proxyObj.name)\\n\\n        // Return the toString representation of our original object if possible\\n        return originalObj + '' || fallback()\\n      }\\n\\n      if (typeof ctx === 'undefined' || ctx === null) {\\n        return target.call(ctx)\\n      }\\n\\n      // Check if the toString protype of the context is the same as the global prototype,\\n      // if not indicates that we are doing a check across different windows., e.g. the iframeWithdirect` test case\\n      const hasSameProto = Object.getPrototypeOf(\\n        Function.prototype.toString\\n      ).isPrototypeOf(ctx.toString) // eslint-disable-line no-prototype-builtins\\n      if (!hasSameProto) {\\n        // Pass the call on to the local Function.prototype.toString instead\\n        return ctx.toString()\\n      }\\n\\n      return target.call(ctx)\\n    }\\n  }\\n\\n  const toStringProxy = new Proxy(\\n    Function.prototype.toString,\\n    utils.stripProxyFromErrors(handler)\\n  )\\n  utils.replaceProperty(Function.prototype, 'toString', {\\n    value: toStringProxy\\n  })\\n}\",\"replaceWithProxy\":\"(obj, propName, handler) => {\\n  const originalObj = obj[propName]\\n  const proxyObj = new Proxy(obj[propName], utils.stripProxyFromErrors(handler))\\n\\n  utils.replaceProperty(obj, propName, { value: proxyObj })\\n  utils.redirectToString(proxyObj, originalObj)\\n\\n  return true\\n}\",\"replaceGetterWithProxy\":\"(obj, propName, handler) => {\\n  const fn = Object.getOwnPropertyDescriptor(obj, propName).get\\n  const fnStr = fn.toString() // special getter function string\\n  const proxyObj = new Proxy(fn, utils.stripProxyFromErrors(handler))\\n\\n  utils.replaceProperty(obj, propName, { get: proxyObj })\\n  utils.patchToString(proxyObj, fnStr)\\n\\n  return true\\n}\",\"replaceGetterSetter\":\"(obj, propName, handlerGetterSetter) => {\\n  const ownPropertyDescriptor = Object.getOwnPropertyDescriptor(obj, propName)\\n  const handler = { ...ownPropertyDescriptor }\\n\\n  if (handlerGetterSetter.get !== undefined) {\\n    const nativeFn = ownPropertyDescriptor.get\\n    handler.get = function() {\\n      return handlerGetterSetter.get.call(this, nativeFn.bind(this))\\n    }\\n    utils.redirectToString(handler.get, nativeFn)\\n  }\\n\\n  if (handlerGetterSetter.set !== undefined) {\\n    const nativeFn = ownPropertyDescriptor.set\\n    handler.set = function(newValue) {\\n      handlerGetterSetter.set.call(this, newValue, nativeFn.bind(this))\\n    }\\n    utils.redirectToString(handler.set, nativeFn)\\n  }\\n\\n  Object.defineProperty(obj, propName, handler)\\n}\",\"mockWithProxy\":\"(obj, propName, pseudoTarget, handler) => {\\n  const proxyObj = new Proxy(pseudoTarget, utils.stripProxyFromErrors(handler))\\n\\n  utils.replaceProperty(obj, propName, { value: proxyObj })\\n  utils.patchToString(proxyObj)\\n\\n  return true\\n}\",\"createProxy\":\"(pseudoTarget, handler) => {\\n  const proxyObj = new Proxy(pseudoTarget, utils.stripProxyFromErrors(handler))\\n  utils.patchToString(proxyObj)\\n\\n  return proxyObj\\n}\",\"splitObjPath\":\"objPath => ({\\n  // Remove last dot entry (property) ==> `HTMLMediaElement.prototype`\\n  objName: objPath.split('.').slice(0, -1).join('.'),\\n  // Extract last dot entry ==> `canPlayType`\\n  propName: objPath.split('.').slice(-1)[0]\\n})\",\"replaceObjPathWithProxy\":\"(objPath, handler) => {\\n  const { objName, propName } = utils.splitObjPath(objPath)\\n  const obj = eval(objName) // eslint-disable-line no-eval\\n  return utils.replaceWithProxy(obj, propName, handler)\\n}\",\"execRecursively\":\"(obj = {}, typeFilter = [], fn) => {\\n  function recurse(obj) {\\n    for (const key in obj) {\\n      if (obj[key] === undefined) {\\n        continue\\n      }\\n      if (obj[key] && typeof obj[key] === 'object') {\\n        recurse(obj[key])\\n      } else {\\n        if (obj[key] && typeFilter.includes(typeof obj[key])) {\\n          fn.call(this, obj[key])\\n        }\\n      }\\n    }\\n  }\\n  recurse(obj)\\n  return obj\\n}\",\"stringifyFns\":\"(fnObj = { hello: () => 'world' }) => {\\n  // Object.fromEntries() ponyfill (in 6 lines) - supported only in Node v12+, modern browsers are fine\\n  // https://github.com/feross/fromentries\\n  function fromEntries(iterable) {\\n    return [...iterable].reduce((obj, [key, val]) => {\\n      obj[key] = val\\n      return obj\\n    }, {})\\n  }\\n  return (Object.fromEntries || fromEntries)(\\n    Object.entries(fnObj)\\n      .filter(([key, value]) => typeof value === 'function')\\n      .map(([key, value]) => [key, value.toString()]) // eslint-disable-line no-eval\\n  )\\n}\",\"materializeFns\":\"(fnStrObj = { hello: \\\"() => 'world'\\\" }) => {\\n  return Object.fromEntries(\\n    Object.entries(fnStrObj).map(([key, value]) => {\\n      if (value.startsWith('function')) {\\n        // some trickery is needed to make oldschool functions work :-)\\n        return [key, eval(`() => ${value}`)()] // eslint-disable-line no-eval\\n      } else {\\n        // arrow functions just work\\n        return [key, eval(value)] // eslint-disable-line no-eval\\n      }\\n    })\\n  )\\n}\",\"makeHandler\":\"() => ({\\n  // Used by simple `navigator` getter evasions\\n  getterValue: value => ({\\n    apply(target, ctx, args) {\\n      // Let's fetch the value first, to trigger and escalate potential errors\\n      // Illegal invocations like `navigator.__proto__.vendor` will throw here\\n      utils.cache.Reflect.apply(...arguments)\\n      return value\\n    }\\n  })\\n})\",\"arrayEquals\":\"(array1, array2) => {\\n  if (array1.length !== array2.length) {\\n    return false\\n  }\\n  for (let i = 0; i < array1.length; ++i) {\\n    if (array1[i] !== array2[i]) {\\n      return false\\n    }\\n  }\\n  return true\\n}\",\"memoize\":\"fn => {\\n  const cache = []\\n  return function(...args) {\\n    if (!cache.some(c => utils.arrayEquals(c.key, args))) {\\n      cache.push({ key: args, value: fn.apply(this, args) })\\n    }\\n    return cache.find(c => utils.arrayEquals(c.key, args)).value\\n  }\\n}\"},\"_mainFunction\":\"(utils, opts) => {\\n      const isSecure = document.location.protocol.startsWith('https')\\n\\n      // In headful on secure origins the permission should be \\\"default\\\", not \\\"denied\\\"\\n      if (isSecure) {\\n        utils.replaceGetterWithProxy(Notification, 'permission', {\\n          apply() {\\n            return 'default'\\n          }\\n        })\\n      }\\n\\n      // Another weird behavior:\\n      // On insecure origins in headful the state is \\\"denied\\\",\\n      // whereas in headless it's \\\"prompt\\\"\\n      if (!isSecure) {\\n        const handler = {\\n          apply(target, ctx, args) {\\n            const param = (args || [])[0]\\n\\n            const isNotifications =\\n              param && param.name && param.name === 'notifications'\\n            if (!isNotifications) {\\n              return utils.cache.Reflect.apply(...arguments)\\n            }\\n\\n            return Promise.resolve(\\n              Object.setPrototypeOf(\\n                {\\n                  state: 'denied',\\n                  onchange: null\\n                },\\n                PermissionStatus.prototype\\n              )\\n            )\\n          }\\n        }\\n        // Note: Don't use `Object.getPrototypeOf` here\\n        utils.replaceWithProxy(Permissions.prototype, 'query', handler)\\n      }\\n    }\",\"_args\":[{}]})"},"stack":[{"file":"/home/neetoci/neeto-chat-web/playwright-tests/node_modules/@bigbinary/neeto-playwright-commons/node_modules/playwright-extra/dist/index.esm.js","line":230,"column":32,"function":"Proxy.<anonymous>"}]}
{"type":"before","callId":"pw:api@22","parentId":"fixture@11","startTime":87020.848,"class":"Test","method":"step","apiName":"page.addInitScript","params":{"source":"(({ _utilsFns, _mainFunction, _args }) => {\n        // Add this point we cannot use our utililty functions as they're just strings, we need to materialize them first\n        const utils = Object.fromEntries(\n          Object.entries(_utilsFns).map(([key, value]) => [key, eval(value)]) // eslint-disable-line no-eval\n        )\n        utils.init()\n        return eval(_mainFunction)(utils, ..._args) // eslint-disable-line no-eval\n      })({\"_utilsFns\":{\"init\":\"() => {\\n  utils.preloadCache()\\n}\",\"stripProxyFromErrors\":\"(handler = {}) => {\\n  const newHandler = {\\n    setPrototypeOf: function (target, proto) {\\n      if (proto === null)\\n        throw new TypeError('Cannot convert object to primitive value')\\n      if (Object.getPrototypeOf(target) === Object.getPrototypeOf(proto)) {\\n        throw new TypeError('Cyclic __proto__ value')\\n      }\\n      return Reflect.setPrototypeOf(target, proto)\\n    }\\n  }\\n  // We wrap each trap in the handler in a try/catch and modify the error stack if they throw\\n  const traps = Object.getOwnPropertyNames(handler)\\n  traps.forEach(trap => {\\n    newHandler[trap] = function () {\\n      try {\\n        // Forward the call to the defined proxy handler\\n        return handler[trap].apply(this, arguments || [])\\n      } catch (err) {\\n        // Stack traces differ per browser, we only support chromium based ones currently\\n        if (!err || !err.stack || !err.stack.includes(`at `)) {\\n          throw err\\n        }\\n\\n        // When something throws within one of our traps the Proxy will show up in error stacks\\n        // An earlier implementation of this code would simply strip lines with a blacklist,\\n        // but it makes sense to be more surgical here and only remove lines related to our Proxy.\\n        // We try to use a known \\\"anchor\\\" line for that and strip it with everything above it.\\n        // If the anchor line cannot be found for some reason we fall back to our blacklist approach.\\n\\n        const stripWithBlacklist = (stack, stripFirstLine = true) => {\\n          const blacklist = [\\n            `at Reflect.${trap} `, // e.g. Reflect.get or Reflect.apply\\n            `at Object.${trap} `, // e.g. Object.get or Object.apply\\n            `at Object.newHandler.<computed> [as ${trap}] ` // caused by this very wrapper :-)\\n          ]\\n          return (\\n            err.stack\\n              .split('\\\\n')\\n              // Always remove the first (file) line in the stack (guaranteed to be our proxy)\\n              .filter((line, index) => !(index === 1 && stripFirstLine))\\n              // Check if the line starts with one of our blacklisted strings\\n              .filter(line => !blacklist.some(bl => line.trim().startsWith(bl)))\\n              .join('\\\\n')\\n          )\\n        }\\n\\n        const stripWithAnchor = (stack, anchor) => {\\n          const stackArr = stack.split('\\\\n')\\n          anchor = anchor || `at Object.newHandler.<computed> [as ${trap}] ` // Known first Proxy line in chromium\\n          const anchorIndex = stackArr.findIndex(line =>\\n            line.trim().startsWith(anchor)\\n          )\\n          if (anchorIndex === -1) {\\n            return false // 404, anchor not found\\n          }\\n          // Strip everything from the top until we reach the anchor line\\n          // Note: We're keeping the 1st line (zero index) as it's unrelated (e.g. `TypeError`)\\n          stackArr.splice(1, anchorIndex)\\n          return stackArr.join('\\\\n')\\n        }\\n\\n        // Special cases due to our nested toString proxies\\n        err.stack = err.stack.replace(\\n          'at Object.toString (',\\n          'at Function.toString ('\\n        )\\n        if ((err.stack || '').includes('at Function.toString (')) {\\n          err.stack = stripWithBlacklist(err.stack, false)\\n          throw err\\n        }\\n\\n        // Try using the anchor method, fallback to blacklist if necessary\\n        err.stack = stripWithAnchor(err.stack) || stripWithBlacklist(err.stack)\\n\\n        throw err // Re-throw our now sanitized error\\n      }\\n    }\\n  })\\n  return newHandler\\n}\",\"stripErrorWithAnchor\":\"(err, anchor) => {\\n  const stackArr = err.stack.split('\\\\n')\\n  const anchorIndex = stackArr.findIndex(line => line.trim().startsWith(anchor))\\n  if (anchorIndex === -1) {\\n    return err // 404, anchor not found\\n  }\\n  // Strip everything from the top until we reach the anchor line (remove anchor line as well)\\n  // Note: We're keeping the 1st line (zero index) as it's unrelated (e.g. `TypeError`)\\n  stackArr.splice(1, anchorIndex)\\n  err.stack = stackArr.join('\\\\n')\\n  return err\\n}\",\"replaceProperty\":\"(obj, propName, descriptorOverrides = {}) => {\\n  return Object.defineProperty(obj, propName, {\\n    // Copy over the existing descriptors (writable, enumerable, configurable, etc)\\n    ...(Object.getOwnPropertyDescriptor(obj, propName) || {}),\\n    // Add our overrides (e.g. value, get())\\n    ...descriptorOverrides\\n  })\\n}\",\"preloadCache\":\"() => {\\n  if (utils.cache) {\\n    return\\n  }\\n  utils.cache = {\\n    // Used in our proxies\\n    Reflect: {\\n      get: Reflect.get.bind(Reflect),\\n      apply: Reflect.apply.bind(Reflect)\\n    },\\n    // Used in `makeNativeString`\\n    nativeToStringStr: Function.toString + '' // => `function toString() { [native code] }`\\n  }\\n}\",\"makeNativeString\":\"(name = '') => {\\n  return utils.cache.nativeToStringStr.replace('toString', name || '')\\n}\",\"patchToString\":\"(obj, str = '') => {\\n  const handler = {\\n    apply: function (target, ctx) {\\n      // This fixes e.g. `HTMLMediaElement.prototype.canPlayType.toString + \\\"\\\"`\\n      if (ctx === Function.prototype.toString) {\\n        return utils.makeNativeString('toString')\\n      }\\n      // `toString` targeted at our proxied Object detected\\n      if (ctx === obj) {\\n        // We either return the optional string verbatim or derive the most desired result automatically\\n        return str || utils.makeNativeString(obj.name)\\n      }\\n      // Check if the toString protype of the context is the same as the global prototype,\\n      // if not indicates that we are doing a check across different windows., e.g. the iframeWithdirect` test case\\n      const hasSameProto = Object.getPrototypeOf(\\n        Function.prototype.toString\\n      ).isPrototypeOf(ctx.toString) // eslint-disable-line no-prototype-builtins\\n      if (!hasSameProto) {\\n        // Pass the call on to the local Function.prototype.toString instead\\n        return ctx.toString()\\n      }\\n      return target.call(ctx)\\n    }\\n  }\\n\\n  const toStringProxy = new Proxy(\\n    Function.prototype.toString,\\n    utils.stripProxyFromErrors(handler)\\n  )\\n  utils.replaceProperty(Function.prototype, 'toString', {\\n    value: toStringProxy\\n  })\\n}\",\"patchToStringNested\":\"(obj = {}) => {\\n  return utils.execRecursively(obj, ['function'], utils.patchToString)\\n}\",\"redirectToString\":\"(proxyObj, originalObj) => {\\n  const handler = {\\n    apply: function (target, ctx) {\\n      // This fixes e.g. `HTMLMediaElement.prototype.canPlayType.toString + \\\"\\\"`\\n      if (ctx === Function.prototype.toString) {\\n        return utils.makeNativeString('toString')\\n      }\\n\\n      // `toString` targeted at our proxied Object detected\\n      if (ctx === proxyObj) {\\n        const fallback = () =>\\n          originalObj && originalObj.name\\n            ? utils.makeNativeString(originalObj.name)\\n            : utils.makeNativeString(proxyObj.name)\\n\\n        // Return the toString representation of our original object if possible\\n        return originalObj + '' || fallback()\\n      }\\n\\n      if (typeof ctx === 'undefined' || ctx === null) {\\n        return target.call(ctx)\\n      }\\n\\n      // Check if the toString protype of the context is the same as the global prototype,\\n      // if not indicates that we are doing a check across different windows., e.g. the iframeWithdirect` test case\\n      const hasSameProto = Object.getPrototypeOf(\\n        Function.prototype.toString\\n      ).isPrototypeOf(ctx.toString) // eslint-disable-line no-prototype-builtins\\n      if (!hasSameProto) {\\n        // Pass the call on to the local Function.prototype.toString instead\\n        return ctx.toString()\\n      }\\n\\n      return target.call(ctx)\\n    }\\n  }\\n\\n  const toStringProxy = new Proxy(\\n    Function.prototype.toString,\\n    utils.stripProxyFromErrors(handler)\\n  )\\n  utils.replaceProperty(Function.prototype, 'toString', {\\n    value: toStringProxy\\n  })\\n}\",\"replaceWithProxy\":\"(obj, propName, handler) => {\\n  const originalObj = obj[propName]\\n  const proxyObj = new Proxy(obj[propName], utils.stripProxyFromErrors(handler))\\n\\n  utils.replaceProperty(obj, propName, { value: proxyObj })\\n  utils.redirectToString(proxyObj, originalObj)\\n\\n  return true\\n}\",\"replaceGetterWithProxy\":\"(obj, propName, handler) => {\\n  const fn = Object.getOwnPropertyDescriptor(obj, propName).get\\n  const fnStr = fn.toString() // special getter function string\\n  const proxyObj = new Proxy(fn, utils.stripProxyFromErrors(handler))\\n\\n  utils.replaceProperty(obj, propName, { get: proxyObj })\\n  utils.patchToString(proxyObj, fnStr)\\n\\n  return true\\n}\",\"replaceGetterSetter\":\"(obj, propName, handlerGetterSetter) => {\\n  const ownPropertyDescriptor = Object.getOwnPropertyDescriptor(obj, propName)\\n  const handler = { ...ownPropertyDescriptor }\\n\\n  if (handlerGetterSetter.get !== undefined) {\\n    const nativeFn = ownPropertyDescriptor.get\\n    handler.get = function() {\\n      return handlerGetterSetter.get.call(this, nativeFn.bind(this))\\n    }\\n    utils.redirectToString(handler.get, nativeFn)\\n  }\\n\\n  if (handlerGetterSetter.set !== undefined) {\\n    const nativeFn = ownPropertyDescriptor.set\\n    handler.set = function(newValue) {\\n      handlerGetterSetter.set.call(this, newValue, nativeFn.bind(this))\\n    }\\n    utils.redirectToString(handler.set, nativeFn)\\n  }\\n\\n  Object.defineProperty(obj, propName, handler)\\n}\",\"mockWithProxy\":\"(obj, propName, pseudoTarget, handler) => {\\n  const proxyObj = new Proxy(pseudoTarget, utils.stripProxyFromErrors(handler))\\n\\n  utils.replaceProperty(obj, propName, { value: proxyObj })\\n  utils.patchToString(proxyObj)\\n\\n  return true\\n}\",\"createProxy\":\"(pseudoTarget, handler) => {\\n  const proxyObj = new Proxy(pseudoTarget, utils.stripProxyFromErrors(handler))\\n  utils.patchToString(proxyObj)\\n\\n  return proxyObj\\n}\",\"splitObjPath\":\"objPath => ({\\n  // Remove last dot entry (property) ==> `HTMLMediaElement.prototype`\\n  objName: objPath.split('.').slice(0, -1).join('.'),\\n  // Extract last dot entry ==> `canPlayType`\\n  propName: objPath.split('.').slice(-1)[0]\\n})\",\"replaceObjPathWithProxy\":\"(objPath, handler) => {\\n  const { objName, propName } = utils.splitObjPath(objPath)\\n  const obj = eval(objName) // eslint-disable-line no-eval\\n  return utils.replaceWithProxy(obj, propName, handler)\\n}\",\"execRecursively\":\"(obj = {}, typeFilter = [], fn) => {\\n  function recurse(obj) {\\n    for (const key in obj) {\\n      if (obj[key] === undefined) {\\n        continue\\n      }\\n      if (obj[key] && typeof obj[key] === 'object') {\\n        recurse(obj[key])\\n      } else {\\n        if (obj[key] && typeFilter.includes(typeof obj[key])) {\\n          fn.call(this, obj[key])\\n        }\\n      }\\n    }\\n  }\\n  recurse(obj)\\n  return obj\\n}\",\"stringifyFns\":\"(fnObj = { hello: () => 'world' }) => {\\n  // Object.fromEntries() ponyfill (in 6 lines) - supported only in Node v12+, modern browsers are fine\\n  // https://github.com/feross/fromentries\\n  function fromEntries(iterable) {\\n    return [...iterable].reduce((obj, [key, val]) => {\\n      obj[key] = val\\n      return obj\\n    }, {})\\n  }\\n  return (Object.fromEntries || fromEntries)(\\n    Object.entries(fnObj)\\n      .filter(([key, value]) => typeof value === 'function')\\n      .map(([key, value]) => [key, value.toString()]) // eslint-disable-line no-eval\\n  )\\n}\",\"materializeFns\":\"(fnStrObj = { hello: \\\"() => 'world'\\\" }) => {\\n  return Object.fromEntries(\\n    Object.entries(fnStrObj).map(([key, value]) => {\\n      if (value.startsWith('function')) {\\n        // some trickery is needed to make oldschool functions work :-)\\n        return [key, eval(`() => ${value}`)()] // eslint-disable-line no-eval\\n      } else {\\n        // arrow functions just work\\n        return [key, eval(value)] // eslint-disable-line no-eval\\n      }\\n    })\\n  )\\n}\",\"makeHandler\":\"() => ({\\n  // Used by simple `navigator` getter evasions\\n  getterValue: value => ({\\n    apply(target, ctx, args) {\\n      // Let's fetch the value first, to trigger and escalate potential errors\\n      // Illegal invocations like `navigator.__proto__.vendor` will throw here\\n      utils.cache.Reflect.apply(...arguments)\\n      return value\\n    }\\n  })\\n})\",\"arrayEquals\":\"(array1, array2) => {\\n  if (array1.length !== array2.length) {\\n    return false\\n  }\\n  for (let i = 0; i < array1.length; ++i) {\\n    if (array1[i] !== array2[i]) {\\n      return false\\n    }\\n  }\\n  return true\\n}\",\"memoize\":\"fn => {\\n  const cache = []\\n  return function(...args) {\\n    if (!cache.some(c => utils.arrayEquals(c.key, args))) {\\n      cache.push({ key: args, value: fn.apply(this, args) })\\n    }\\n    return cache.find(c => utils.arrayEquals(c.key, args)).value\\n  }\\n}\"},\"_mainFunction\":\"(utils, { fns, data }) => {\\n        fns = utils.materializeFns(fns)\\n\\n        // That means we're running headful\\n        const hasPlugins = 'plugins' in navigator && navigator.plugins.length\\n        if (hasPlugins) {\\n          return // nothing to do here\\n        }\\n\\n        const mimeTypes = fns.generateMimeTypeArray(utils, fns)(data.mimeTypes)\\n        const plugins = fns.generatePluginArray(utils, fns)(data.plugins)\\n\\n        // Plugin and MimeType cross-reference each other, let's do that now\\n        // Note: We're looping through `data.plugins` here, not the generated `plugins`\\n        for (const pluginData of data.plugins) {\\n          pluginData.__mimeTypes.forEach((type, index) => {\\n            plugins[pluginData.name][index] = mimeTypes[type]\\n\\n            Object.defineProperty(plugins[pluginData.name], type, {\\n              value: mimeTypes[type],\\n              writable: false,\\n              enumerable: false, // Not enumerable\\n              configurable: true\\n            })\\n            Object.defineProperty(mimeTypes[type], 'enabledPlugin', {\\n              value:\\n                type === 'application/x-pnacl'\\n                  ? mimeTypes['application/x-nacl'].enabledPlugin // these reference the same plugin, so we need to re-use the Proxy in order to avoid leaks\\n                  : new Proxy(plugins[pluginData.name], {}), // Prevent circular references\\n              writable: false,\\n              enumerable: false, // Important: `JSON.stringify(navigator.plugins)`\\n              configurable: true\\n            })\\n          })\\n        }\\n\\n        const patchNavigator = (name, value) =>\\n          utils.replaceProperty(Object.getPrototypeOf(navigator), name, {\\n            get() {\\n              return value\\n            }\\n          })\\n\\n        patchNavigator('mimeTypes', mimeTypes)\\n        patchNavigator('plugins', plugins)\\n\\n        // All done\\n      }\",\"_args\":[{\"fns\":{\"generateMimeTypeArray\":\"(utils, fns) => mimeTypesData => {\\n  return fns.generateMagicArray(utils, fns)(\\n    mimeTypesData,\\n    MimeTypeArray.prototype,\\n    MimeType.prototype,\\n    'type'\\n  )\\n}\",\"generatePluginArray\":\"(utils, fns) => pluginsData => {\\n  return fns.generateMagicArray(utils, fns)(\\n    pluginsData,\\n    PluginArray.prototype,\\n    Plugin.prototype,\\n    'name'\\n  )\\n}\",\"generateMagicArray\":\"(utils, fns) =>\\n  function(\\n    dataArray = [],\\n    proto = MimeTypeArray.prototype,\\n    itemProto = MimeType.prototype,\\n    itemMainProp = 'type'\\n  ) {\\n    // Quick helper to set props with the same descriptors vanilla is using\\n    const defineProp = (obj, prop, value) =>\\n      Object.defineProperty(obj, prop, {\\n        value,\\n        writable: false,\\n        enumerable: false, // Important for mimeTypes & plugins: `JSON.stringify(navigator.mimeTypes)`\\n        configurable: true\\n      })\\n\\n    // Loop over our fake data and construct items\\n    const makeItem = data => {\\n      const item = {}\\n      for (const prop of Object.keys(data)) {\\n        if (prop.startsWith('__')) {\\n          continue\\n        }\\n        defineProp(item, prop, data[prop])\\n      }\\n      return patchItem(item, data)\\n    }\\n\\n    const patchItem = (item, data) => {\\n      let descriptor = Object.getOwnPropertyDescriptors(item)\\n\\n      // Special case: Plugins have a magic length property which is not enumerable\\n      // e.g. `navigator.plugins[i].length` should always be the length of the assigned mimeTypes\\n      if (itemProto === Plugin.prototype) {\\n        descriptor = {\\n          ...descriptor,\\n          length: {\\n            value: data.__mimeTypes.length,\\n            writable: false,\\n            enumerable: false,\\n            configurable: true // Important to be able to use the ownKeys trap in a Proxy to strip `length`\\n          }\\n        }\\n      }\\n\\n      // We need to spoof a specific `MimeType` or `Plugin` object\\n      const obj = Object.create(itemProto, descriptor)\\n\\n      // Virtually all property keys are not enumerable in vanilla\\n      const blacklist = [...Object.keys(data), 'length', 'enabledPlugin']\\n      return new Proxy(obj, {\\n        ownKeys(target) {\\n          return Reflect.ownKeys(target).filter(k => !blacklist.includes(k))\\n        },\\n        getOwnPropertyDescriptor(target, prop) {\\n          if (blacklist.includes(prop)) {\\n            return undefined\\n          }\\n          return Reflect.getOwnPropertyDescriptor(target, prop)\\n        }\\n      })\\n    }\\n\\n    const magicArray = []\\n\\n    // Loop through our fake data and use that to create convincing entities\\n    dataArray.forEach(data => {\\n      magicArray.push(makeItem(data))\\n    })\\n\\n    // Add direct property access  based on types (e.g. `obj['application/pdf']`) afterwards\\n    magicArray.forEach(entry => {\\n      defineProp(magicArray, entry[itemMainProp], entry)\\n    })\\n\\n    // This is the best way to fake the type to make sure this is false: `Array.isArray(navigator.mimeTypes)`\\n    const magicArrayObj = Object.create(proto, {\\n      ...Object.getOwnPropertyDescriptors(magicArray),\\n\\n      // There's one ugly quirk we unfortunately need to take care of:\\n      // The `MimeTypeArray` prototype has an enumerable `length` property,\\n      // but headful Chrome will still skip it when running `Object.getOwnPropertyNames(navigator.mimeTypes)`.\\n      // To strip it we need to make it first `configurable` and can then overlay a Proxy with an `ownKeys` trap.\\n      length: {\\n        value: magicArray.length,\\n        writable: false,\\n        enumerable: false,\\n        configurable: true // Important to be able to use the ownKeys trap in a Proxy to strip `length`\\n      }\\n    })\\n\\n    // Generate our functional function mocks :-)\\n    const functionMocks = fns.generateFunctionMocks(utils)(\\n      proto,\\n      itemMainProp,\\n      magicArray\\n    )\\n\\n    // We need to overlay our custom object with a JS Proxy\\n    const magicArrayObjProxy = new Proxy(magicArrayObj, {\\n      get(target, key = '') {\\n        // Redirect function calls to our custom proxied versions mocking the vanilla behavior\\n        if (key === 'item') {\\n          return functionMocks.item\\n        }\\n        if (key === 'namedItem') {\\n          return functionMocks.namedItem\\n        }\\n        if (proto === PluginArray.prototype && key === 'refresh') {\\n          return functionMocks.refresh\\n        }\\n        // Everything else can pass through as normal\\n        return utils.cache.Reflect.get(...arguments)\\n      },\\n      ownKeys(target) {\\n        // There are a couple of quirks where the original property demonstrates \\\"magical\\\" behavior that makes no sense\\n        // This can be witnessed when calling `Object.getOwnPropertyNames(navigator.mimeTypes)` and the absense of `length`\\n        // My guess is that it has to do with the recent change of not allowing data enumeration and this being implemented weirdly\\n        // For that reason we just completely fake the available property names based on our data to match what regular Chrome is doing\\n        // Specific issues when not patching this: `length` property is available, direct `types` props (e.g. `obj['application/pdf']`) are missing\\n        const keys = []\\n        const typeProps = magicArray.map(mt => mt[itemMainProp])\\n        typeProps.forEach((_, i) => keys.push(`${i}`))\\n        typeProps.forEach(propName => keys.push(propName))\\n        return keys\\n      },\\n      getOwnPropertyDescriptor(target, prop) {\\n        if (prop === 'length') {\\n          return undefined\\n        }\\n        return Reflect.getOwnPropertyDescriptor(target, prop)\\n      }\\n    })\\n\\n    return magicArrayObjProxy\\n  }\",\"generateFunctionMocks\":\"utils => (\\n  proto,\\n  itemMainProp,\\n  dataArray\\n) => ({\\n  /** Returns the MimeType object with the specified index. */\\n  item: utils.createProxy(proto.item, {\\n    apply(target, ctx, args) {\\n      if (!args.length) {\\n        throw new TypeError(\\n          `Failed to execute 'item' on '${\\n            proto[Symbol.toStringTag]\\n          }': 1 argument required, but only 0 present.`\\n        )\\n      }\\n      // Special behavior alert:\\n      // - Vanilla tries to cast strings to Numbers (only integers!) and use them as property index lookup\\n      // - If anything else than an integer (including as string) is provided it will return the first entry\\n      const isInteger = args[0] && Number.isInteger(Number(args[0])) // Cast potential string to number first, then check for integer\\n      // Note: Vanilla never returns `undefined`\\n      return (isInteger ? dataArray[Number(args[0])] : dataArray[0]) || null\\n    }\\n  }),\\n  /** Returns the MimeType object with the specified name. */\\n  namedItem: utils.createProxy(proto.namedItem, {\\n    apply(target, ctx, args) {\\n      if (!args.length) {\\n        throw new TypeError(\\n          `Failed to execute 'namedItem' on '${\\n            proto[Symbol.toStringTag]\\n          }': 1 argument required, but only 0 present.`\\n        )\\n      }\\n      return dataArray.find(mt => mt[itemMainProp] === args[0]) || null // Not `undefined`!\\n    }\\n  }),\\n  /** Does nothing and shall return nothing */\\n  refresh: proto.refresh\\n    ? utils.createProxy(proto.refresh, {\\n        apply(target, ctx, args) {\\n          return undefined\\n        }\\n      })\\n    : undefined\\n})\"},\"data\":{\"mimeTypes\":[{\"type\":\"application/pdf\",\"suffixes\":\"pdf\",\"description\":\"\",\"__pluginName\":\"Chrome PDF Viewer\"},{\"type\":\"application/x-google-chrome-pdf\",\"suffixes\":\"pdf\",\"description\":\"Portable Document Format\",\"__pluginName\":\"Chrome PDF Plugin\"},{\"type\":\"application/x-nacl\",\"suffixes\":\"\",\"description\":\"Native Client Executable\",\"__pluginName\":\"Native Client\"},{\"type\":\"application/x-pnacl\",\"suffixes\":\"\",\"description\":\"Portable Native Client Executable\",\"__pluginName\":\"Native Client\"}],\"plugins\":[{\"name\":\"Chrome PDF Plugin\",\"filename\":\"internal-pdf-viewer\",\"description\":\"Portable Document Format\",\"__mimeTypes\":[\"application/x-google-chrome-pdf\"]},{\"name\":\"Chrome PDF Viewer\",\"filename\":\"mhjfbmdgcfjbbpaeojofohoefgiehjai\",\"description\":\"\",\"__mimeTypes\":[\"application/pdf\"]},{\"name\":\"Native Client\",\"filename\":\"internal-nacl-plugin\",\"description\":\"\",\"__mimeTypes\":[\"application/x-nacl\",\"application/x-pnacl\"]}]}}]})"},"stack":[{"file":"/home/neetoci/neeto-chat-web/playwright-tests/node_modules/@bigbinary/neeto-playwright-commons/node_modules/playwright-extra/dist/index.esm.js","line":230,"column":32,"function":"Proxy.<anonymous>"}]}
{"type":"before","callId":"pw:api@23","parentId":"fixture@11","startTime":87021.762,"class":"Test","method":"step","apiName":"page.addInitScript","params":{"source":"(() => {\n      if (navigator.webdriver === false) {\n        // Post Chrome 89.0.4339.0 and already good\n      } else if (navigator.webdriver === undefined) {\n        // Pre Chrome 89.0.4339.0 and already good\n      } else {\n        // Pre Chrome 88.0.4291.0 and needs patching\n        delete Object.getPrototypeOf(navigator).webdriver\n      }\n    })(undefined)"},"stack":[{"file":"/home/neetoci/neeto-chat-web/playwright-tests/node_modules/@bigbinary/neeto-playwright-commons/node_modules/playwright-extra/dist/index.esm.js","line":230,"column":32,"function":"Proxy.<anonymous>"}]}
{"type":"before","callId":"pw:api@24","parentId":"fixture@11","startTime":87022.248,"class":"Test","method":"step","apiName":"page.addInitScript","params":{"source":"(({ _utilsFns, _mainFunction, _args }) => {\n        // Add this point we cannot use our utililty functions as they're just strings, we need to materialize them first\n        const utils = Object.fromEntries(\n          Object.entries(_utilsFns).map(([key, value]) => [key, eval(value)]) // eslint-disable-line no-eval\n        )\n        utils.init()\n        return eval(_mainFunction)(utils, ..._args) // eslint-disable-line no-eval\n      })({\"_utilsFns\":{\"init\":\"() => {\\n  utils.preloadCache()\\n}\",\"stripProxyFromErrors\":\"(handler = {}) => {\\n  const newHandler = {\\n    setPrototypeOf: function (target, proto) {\\n      if (proto === null)\\n        throw new TypeError('Cannot convert object to primitive value')\\n      if (Object.getPrototypeOf(target) === Object.getPrototypeOf(proto)) {\\n        throw new TypeError('Cyclic __proto__ value')\\n      }\\n      return Reflect.setPrototypeOf(target, proto)\\n    }\\n  }\\n  // We wrap each trap in the handler in a try/catch and modify the error stack if they throw\\n  const traps = Object.getOwnPropertyNames(handler)\\n  traps.forEach(trap => {\\n    newHandler[trap] = function () {\\n      try {\\n        // Forward the call to the defined proxy handler\\n        return handler[trap].apply(this, arguments || [])\\n      } catch (err) {\\n        // Stack traces differ per browser, we only support chromium based ones currently\\n        if (!err || !err.stack || !err.stack.includes(`at `)) {\\n          throw err\\n        }\\n\\n        // When something throws within one of our traps the Proxy will show up in error stacks\\n        // An earlier implementation of this code would simply strip lines with a blacklist,\\n        // but it makes sense to be more surgical here and only remove lines related to our Proxy.\\n        // We try to use a known \\\"anchor\\\" line for that and strip it with everything above it.\\n        // If the anchor line cannot be found for some reason we fall back to our blacklist approach.\\n\\n        const stripWithBlacklist = (stack, stripFirstLine = true) => {\\n          const blacklist = [\\n            `at Reflect.${trap} `, // e.g. Reflect.get or Reflect.apply\\n            `at Object.${trap} `, // e.g. Object.get or Object.apply\\n            `at Object.newHandler.<computed> [as ${trap}] ` // caused by this very wrapper :-)\\n          ]\\n          return (\\n            err.stack\\n              .split('\\\\n')\\n              // Always remove the first (file) line in the stack (guaranteed to be our proxy)\\n              .filter((line, index) => !(index === 1 && stripFirstLine))\\n              // Check if the line starts with one of our blacklisted strings\\n              .filter(line => !blacklist.some(bl => line.trim().startsWith(bl)))\\n              .join('\\\\n')\\n          )\\n        }\\n\\n        const stripWithAnchor = (stack, anchor) => {\\n          const stackArr = stack.split('\\\\n')\\n          anchor = anchor || `at Object.newHandler.<computed> [as ${trap}] ` // Known first Proxy line in chromium\\n          const anchorIndex = stackArr.findIndex(line =>\\n            line.trim().startsWith(anchor)\\n          )\\n          if (anchorIndex === -1) {\\n            return false // 404, anchor not found\\n          }\\n          // Strip everything from the top until we reach the anchor line\\n          // Note: We're keeping the 1st line (zero index) as it's unrelated (e.g. `TypeError`)\\n          stackArr.splice(1, anchorIndex)\\n          return stackArr.join('\\\\n')\\n        }\\n\\n        // Special cases due to our nested toString proxies\\n        err.stack = err.stack.replace(\\n          'at Object.toString (',\\n          'at Function.toString ('\\n        )\\n        if ((err.stack || '').includes('at Function.toString (')) {\\n          err.stack = stripWithBlacklist(err.stack, false)\\n          throw err\\n        }\\n\\n        // Try using the anchor method, fallback to blacklist if necessary\\n        err.stack = stripWithAnchor(err.stack) || stripWithBlacklist(err.stack)\\n\\n        throw err // Re-throw our now sanitized error\\n      }\\n    }\\n  })\\n  return newHandler\\n}\",\"stripErrorWithAnchor\":\"(err, anchor) => {\\n  const stackArr = err.stack.split('\\\\n')\\n  const anchorIndex = stackArr.findIndex(line => line.trim().startsWith(anchor))\\n  if (anchorIndex === -1) {\\n    return err // 404, anchor not found\\n  }\\n  // Strip everything from the top until we reach the anchor line (remove anchor line as well)\\n  // Note: We're keeping the 1st line (zero index) as it's unrelated (e.g. `TypeError`)\\n  stackArr.splice(1, anchorIndex)\\n  err.stack = stackArr.join('\\\\n')\\n  return err\\n}\",\"replaceProperty\":\"(obj, propName, descriptorOverrides = {}) => {\\n  return Object.defineProperty(obj, propName, {\\n    // Copy over the existing descriptors (writable, enumerable, configurable, etc)\\n    ...(Object.getOwnPropertyDescriptor(obj, propName) || {}),\\n    // Add our overrides (e.g. value, get())\\n    ...descriptorOverrides\\n  })\\n}\",\"preloadCache\":\"() => {\\n  if (utils.cache) {\\n    return\\n  }\\n  utils.cache = {\\n    // Used in our proxies\\n    Reflect: {\\n      get: Reflect.get.bind(Reflect),\\n      apply: Reflect.apply.bind(Reflect)\\n    },\\n    // Used in `makeNativeString`\\n    nativeToStringStr: Function.toString + '' // => `function toString() { [native code] }`\\n  }\\n}\",\"makeNativeString\":\"(name = '') => {\\n  return utils.cache.nativeToStringStr.replace('toString', name || '')\\n}\",\"patchToString\":\"(obj, str = '') => {\\n  const handler = {\\n    apply: function (target, ctx) {\\n      // This fixes e.g. `HTMLMediaElement.prototype.canPlayType.toString + \\\"\\\"`\\n      if (ctx === Function.prototype.toString) {\\n        return utils.makeNativeString('toString')\\n      }\\n      // `toString` targeted at our proxied Object detected\\n      if (ctx === obj) {\\n        // We either return the optional string verbatim or derive the most desired result automatically\\n        return str || utils.makeNativeString(obj.name)\\n      }\\n      // Check if the toString protype of the context is the same as the global prototype,\\n      // if not indicates that we are doing a check across different windows., e.g. the iframeWithdirect` test case\\n      const hasSameProto = Object.getPrototypeOf(\\n        Function.prototype.toString\\n      ).isPrototypeOf(ctx.toString) // eslint-disable-line no-prototype-builtins\\n      if (!hasSameProto) {\\n        // Pass the call on to the local Function.prototype.toString instead\\n        return ctx.toString()\\n      }\\n      return target.call(ctx)\\n    }\\n  }\\n\\n  const toStringProxy = new Proxy(\\n    Function.prototype.toString,\\n    utils.stripProxyFromErrors(handler)\\n  )\\n  utils.replaceProperty(Function.prototype, 'toString', {\\n    value: toStringProxy\\n  })\\n}\",\"patchToStringNested\":\"(obj = {}) => {\\n  return utils.execRecursively(obj, ['function'], utils.patchToString)\\n}\",\"redirectToString\":\"(proxyObj, originalObj) => {\\n  const handler = {\\n    apply: function (target, ctx) {\\n      // This fixes e.g. `HTMLMediaElement.prototype.canPlayType.toString + \\\"\\\"`\\n      if (ctx === Function.prototype.toString) {\\n        return utils.makeNativeString('toString')\\n      }\\n\\n      // `toString` targeted at our proxied Object detected\\n      if (ctx === proxyObj) {\\n        const fallback = () =>\\n          originalObj && originalObj.name\\n            ? utils.makeNativeString(originalObj.name)\\n            : utils.makeNativeString(proxyObj.name)\\n\\n        // Return the toString representation of our original object if possible\\n        return originalObj + '' || fallback()\\n      }\\n\\n      if (typeof ctx === 'undefined' || ctx === null) {\\n        return target.call(ctx)\\n      }\\n\\n      // Check if the toString protype of the context is the same as the global prototype,\\n      // if not indicates that we are doing a check across different windows., e.g. the iframeWithdirect` test case\\n      const hasSameProto = Object.getPrototypeOf(\\n        Function.prototype.toString\\n      ).isPrototypeOf(ctx.toString) // eslint-disable-line no-prototype-builtins\\n      if (!hasSameProto) {\\n        // Pass the call on to the local Function.prototype.toString instead\\n        return ctx.toString()\\n      }\\n\\n      return target.call(ctx)\\n    }\\n  }\\n\\n  const toStringProxy = new Proxy(\\n    Function.prototype.toString,\\n    utils.stripProxyFromErrors(handler)\\n  )\\n  utils.replaceProperty(Function.prototype, 'toString', {\\n    value: toStringProxy\\n  })\\n}\",\"replaceWithProxy\":\"(obj, propName, handler) => {\\n  const originalObj = obj[propName]\\n  const proxyObj = new Proxy(obj[propName], utils.stripProxyFromErrors(handler))\\n\\n  utils.replaceProperty(obj, propName, { value: proxyObj })\\n  utils.redirectToString(proxyObj, originalObj)\\n\\n  return true\\n}\",\"replaceGetterWithProxy\":\"(obj, propName, handler) => {\\n  const fn = Object.getOwnPropertyDescriptor(obj, propName).get\\n  const fnStr = fn.toString() // special getter function string\\n  const proxyObj = new Proxy(fn, utils.stripProxyFromErrors(handler))\\n\\n  utils.replaceProperty(obj, propName, { get: proxyObj })\\n  utils.patchToString(proxyObj, fnStr)\\n\\n  return true\\n}\",\"replaceGetterSetter\":\"(obj, propName, handlerGetterSetter) => {\\n  const ownPropertyDescriptor = Object.getOwnPropertyDescriptor(obj, propName)\\n  const handler = { ...ownPropertyDescriptor }\\n\\n  if (handlerGetterSetter.get !== undefined) {\\n    const nativeFn = ownPropertyDescriptor.get\\n    handler.get = function() {\\n      return handlerGetterSetter.get.call(this, nativeFn.bind(this))\\n    }\\n    utils.redirectToString(handler.get, nativeFn)\\n  }\\n\\n  if (handlerGetterSetter.set !== undefined) {\\n    const nativeFn = ownPropertyDescriptor.set\\n    handler.set = function(newValue) {\\n      handlerGetterSetter.set.call(this, newValue, nativeFn.bind(this))\\n    }\\n    utils.redirectToString(handler.set, nativeFn)\\n  }\\n\\n  Object.defineProperty(obj, propName, handler)\\n}\",\"mockWithProxy\":\"(obj, propName, pseudoTarget, handler) => {\\n  const proxyObj = new Proxy(pseudoTarget, utils.stripProxyFromErrors(handler))\\n\\n  utils.replaceProperty(obj, propName, { value: proxyObj })\\n  utils.patchToString(proxyObj)\\n\\n  return true\\n}\",\"createProxy\":\"(pseudoTarget, handler) => {\\n  const proxyObj = new Proxy(pseudoTarget, utils.stripProxyFromErrors(handler))\\n  utils.patchToString(proxyObj)\\n\\n  return proxyObj\\n}\",\"splitObjPath\":\"objPath => ({\\n  // Remove last dot entry (property) ==> `HTMLMediaElement.prototype`\\n  objName: objPath.split('.').slice(0, -1).join('.'),\\n  // Extract last dot entry ==> `canPlayType`\\n  propName: objPath.split('.').slice(-1)[0]\\n})\",\"replaceObjPathWithProxy\":\"(objPath, handler) => {\\n  const { objName, propName } = utils.splitObjPath(objPath)\\n  const obj = eval(objName) // eslint-disable-line no-eval\\n  return utils.replaceWithProxy(obj, propName, handler)\\n}\",\"execRecursively\":\"(obj = {}, typeFilter = [], fn) => {\\n  function recurse(obj) {\\n    for (const key in obj) {\\n      if (obj[key] === undefined) {\\n        continue\\n      }\\n      if (obj[key] && typeof obj[key] === 'object') {\\n        recurse(obj[key])\\n      } else {\\n        if (obj[key] && typeFilter.includes(typeof obj[key])) {\\n          fn.call(this, obj[key])\\n        }\\n      }\\n    }\\n  }\\n  recurse(obj)\\n  return obj\\n}\",\"stringifyFns\":\"(fnObj = { hello: () => 'world' }) => {\\n  // Object.fromEntries() ponyfill (in 6 lines) - supported only in Node v12+, modern browsers are fine\\n  // https://github.com/feross/fromentries\\n  function fromEntries(iterable) {\\n    return [...iterable].reduce((obj, [key, val]) => {\\n      obj[key] = val\\n      return obj\\n    }, {})\\n  }\\n  return (Object.fromEntries || fromEntries)(\\n    Object.entries(fnObj)\\n      .filter(([key, value]) => typeof value === 'function')\\n      .map(([key, value]) => [key, value.toString()]) // eslint-disable-line no-eval\\n  )\\n}\",\"materializeFns\":\"(fnStrObj = { hello: \\\"() => 'world'\\\" }) => {\\n  return Object.fromEntries(\\n    Object.entries(fnStrObj).map(([key, value]) => {\\n      if (value.startsWith('function')) {\\n        // some trickery is needed to make oldschool functions work :-)\\n        return [key, eval(`() => ${value}`)()] // eslint-disable-line no-eval\\n      } else {\\n        // arrow functions just work\\n        return [key, eval(value)] // eslint-disable-line no-eval\\n      }\\n    })\\n  )\\n}\",\"makeHandler\":\"() => ({\\n  // Used by simple `navigator` getter evasions\\n  getterValue: value => ({\\n    apply(target, ctx, args) {\\n      // Let's fetch the value first, to trigger and escalate potential errors\\n      // Illegal invocations like `navigator.__proto__.vendor` will throw here\\n      utils.cache.Reflect.apply(...arguments)\\n      return value\\n    }\\n  })\\n})\",\"arrayEquals\":\"(array1, array2) => {\\n  if (array1.length !== array2.length) {\\n    return false\\n  }\\n  for (let i = 0; i < array1.length; ++i) {\\n    if (array1[i] !== array2[i]) {\\n      return false\\n    }\\n  }\\n  return true\\n}\",\"memoize\":\"fn => {\\n  const cache = []\\n  return function(...args) {\\n    if (!cache.some(c => utils.arrayEquals(c.key, args))) {\\n      cache.push({ key: args, value: fn.apply(this, args) })\\n    }\\n    return cache.find(c => utils.arrayEquals(c.key, args)).value\\n  }\\n}\"},\"_mainFunction\":\"(utils, opts) => {\\n      const getParameterProxyHandler = {\\n        apply: function(target, ctx, args) {\\n          const param = (args || [])[0]\\n          const result = utils.cache.Reflect.apply(target, ctx, args)\\n          // UNMASKED_VENDOR_WEBGL\\n          if (param === 37445) {\\n            return opts.vendor || 'Intel Inc.' // default in headless: Google Inc.\\n          }\\n          // UNMASKED_RENDERER_WEBGL\\n          if (param === 37446) {\\n            return opts.renderer || 'Intel Iris OpenGL Engine' // default in headless: Google SwiftShader\\n          }\\n          return result\\n        }\\n      }\\n\\n      // There's more than one WebGL rendering context\\n      // https://developer.mozilla.org/en-US/docs/Web/API/WebGL2RenderingContext#Browser_compatibility\\n      // To find out the original values here: Object.getOwnPropertyDescriptors(WebGLRenderingContext.prototype.getParameter)\\n      const addProxy = (obj, propName) => {\\n        utils.replaceWithProxy(obj, propName, getParameterProxyHandler)\\n      }\\n      // For whatever weird reason loops don't play nice with Object.defineProperty, here's the next best thing:\\n      addProxy(WebGLRenderingContext.prototype, 'getParameter')\\n      addProxy(WebGL2RenderingContext.prototype, 'getParameter')\\n    }\",\"_args\":[{}]})"},"stack":[{"file":"/home/neetoci/neeto-chat-web/playwright-tests/node_modules/@bigbinary/neeto-playwright-commons/node_modules/playwright-extra/dist/index.esm.js","line":230,"column":32,"function":"Proxy.<anonymous>"}]}
{"type":"before","callId":"pw:api@25","parentId":"fixture@11","startTime":87023.091,"class":"Test","method":"step","apiName":"page.addInitScript","params":{"source":"(() => {\n      try {\n        if (window.outerWidth && window.outerHeight) {\n          return // nothing to do here\n        }\n        const windowFrame = 85 // probably OS and WM dependent\n        window.outerWidth = window.innerWidth\n        window.outerHeight = window.innerHeight + windowFrame\n      } catch (err) {}\n    })(undefined)"},"stack":[{"file":"/home/neetoci/neeto-chat-web/playwright-tests/node_modules/@bigbinary/neeto-playwright-commons/node_modules/playwright-extra/dist/index.esm.js","line":230,"column":32,"function":"Proxy.<anonymous>"}]}
{"type":"before","callId":"pw:api@26","parentId":"fixture@11","startTime":87027.5,"class":"Test","method":"step","apiName":"page.addInitScript","params":{"source":"(({ _utilsFns, _mainFunction, _args }) => {\n        // Add this point we cannot use our utililty functions as they're just strings, we need to materialize them first\n        const utils = Object.fromEntries(\n          Object.entries(_utilsFns).map(([key, value]) => [key, eval(value)]) // eslint-disable-line no-eval\n        )\n        utils.init()\n        return eval(_mainFunction)(utils, ..._args) // eslint-disable-line no-eval\n      })({\"_utilsFns\":{\"init\":\"() => {\\n  utils.preloadCache()\\n}\",\"stripProxyFromErrors\":\"(handler = {}) => {\\n  const newHandler = {\\n    setPrototypeOf: function (target, proto) {\\n      if (proto === null)\\n        throw new TypeError('Cannot convert object to primitive value')\\n      if (Object.getPrototypeOf(target) === Object.getPrototypeOf(proto)) {\\n        throw new TypeError('Cyclic __proto__ value')\\n      }\\n      return Reflect.setPrototypeOf(target, proto)\\n    }\\n  }\\n  // We wrap each trap in the handler in a try/catch and modify the error stack if they throw\\n  const traps = Object.getOwnPropertyNames(handler)\\n  traps.forEach(trap => {\\n    newHandler[trap] = function () {\\n      try {\\n        // Forward the call to the defined proxy handler\\n        return handler[trap].apply(this, arguments || [])\\n      } catch (err) {\\n        // Stack traces differ per browser, we only support chromium based ones currently\\n        if (!err || !err.stack || !err.stack.includes(`at `)) {\\n          throw err\\n        }\\n\\n        // When something throws within one of our traps the Proxy will show up in error stacks\\n        // An earlier implementation of this code would simply strip lines with a blacklist,\\n        // but it makes sense to be more surgical here and only remove lines related to our Proxy.\\n        // We try to use a known \\\"anchor\\\" line for that and strip it with everything above it.\\n        // If the anchor line cannot be found for some reason we fall back to our blacklist approach.\\n\\n        const stripWithBlacklist = (stack, stripFirstLine = true) => {\\n          const blacklist = [\\n            `at Reflect.${trap} `, // e.g. Reflect.get or Reflect.apply\\n            `at Object.${trap} `, // e.g. Object.get or Object.apply\\n            `at Object.newHandler.<computed> [as ${trap}] ` // caused by this very wrapper :-)\\n          ]\\n          return (\\n            err.stack\\n              .split('\\\\n')\\n              // Always remove the first (file) line in the stack (guaranteed to be our proxy)\\n              .filter((line, index) => !(index === 1 && stripFirstLine))\\n              // Check if the line starts with one of our blacklisted strings\\n              .filter(line => !blacklist.some(bl => line.trim().startsWith(bl)))\\n              .join('\\\\n')\\n          )\\n        }\\n\\n        const stripWithAnchor = (stack, anchor) => {\\n          const stackArr = stack.split('\\\\n')\\n          anchor = anchor || `at Object.newHandler.<computed> [as ${trap}] ` // Known first Proxy line in chromium\\n          const anchorIndex = stackArr.findIndex(line =>\\n            line.trim().startsWith(anchor)\\n          )\\n          if (anchorIndex === -1) {\\n            return false // 404, anchor not found\\n          }\\n          // Strip everything from the top until we reach the anchor line\\n          // Note: We're keeping the 1st line (zero index) as it's unrelated (e.g. `TypeError`)\\n          stackArr.splice(1, anchorIndex)\\n          return stackArr.join('\\\\n')\\n        }\\n\\n        // Special cases due to our nested toString proxies\\n        err.stack = err.stack.replace(\\n          'at Object.toString (',\\n          'at Function.toString ('\\n        )\\n        if ((err.stack || '').includes('at Function.toString (')) {\\n          err.stack = stripWithBlacklist(err.stack, false)\\n          throw err\\n        }\\n\\n        // Try using the anchor method, fallback to blacklist if necessary\\n        err.stack = stripWithAnchor(err.stack) || stripWithBlacklist(err.stack)\\n\\n        throw err // Re-throw our now sanitized error\\n      }\\n    }\\n  })\\n  return newHandler\\n}\",\"stripErrorWithAnchor\":\"(err, anchor) => {\\n  const stackArr = err.stack.split('\\\\n')\\n  const anchorIndex = stackArr.findIndex(line => line.trim().startsWith(anchor))\\n  if (anchorIndex === -1) {\\n    return err // 404, anchor not found\\n  }\\n  // Strip everything from the top until we reach the anchor line (remove anchor line as well)\\n  // Note: We're keeping the 1st line (zero index) as it's unrelated (e.g. `TypeError`)\\n  stackArr.splice(1, anchorIndex)\\n  err.stack = stackArr.join('\\\\n')\\n  return err\\n}\",\"replaceProperty\":\"(obj, propName, descriptorOverrides = {}) => {\\n  return Object.defineProperty(obj, propName, {\\n    // Copy over the existing descriptors (writable, enumerable, configurable, etc)\\n    ...(Object.getOwnPropertyDescriptor(obj, propName) || {}),\\n    // Add our overrides (e.g. value, get())\\n    ...descriptorOverrides\\n  })\\n}\",\"preloadCache\":\"() => {\\n  if (utils.cache) {\\n    return\\n  }\\n  utils.cache = {\\n    // Used in our proxies\\n    Reflect: {\\n      get: Reflect.get.bind(Reflect),\\n      apply: Reflect.apply.bind(Reflect)\\n    },\\n    // Used in `makeNativeString`\\n    nativeToStringStr: Function.toString + '' // => `function toString() { [native code] }`\\n  }\\n}\",\"makeNativeString\":\"(name = '') => {\\n  return utils.cache.nativeToStringStr.replace('toString', name || '')\\n}\",\"patchToString\":\"(obj, str = '') => {\\n  const handler = {\\n    apply: function (target, ctx) {\\n      // This fixes e.g. `HTMLMediaElement.prototype.canPlayType.toString + \\\"\\\"`\\n      if (ctx === Function.prototype.toString) {\\n        return utils.makeNativeString('toString')\\n      }\\n      // `toString` targeted at our proxied Object detected\\n      if (ctx === obj) {\\n        // We either return the optional string verbatim or derive the most desired result automatically\\n        return str || utils.makeNativeString(obj.name)\\n      }\\n      // Check if the toString protype of the context is the same as the global prototype,\\n      // if not indicates that we are doing a check across different windows., e.g. the iframeWithdirect` test case\\n      const hasSameProto = Object.getPrototypeOf(\\n        Function.prototype.toString\\n      ).isPrototypeOf(ctx.toString) // eslint-disable-line no-prototype-builtins\\n      if (!hasSameProto) {\\n        // Pass the call on to the local Function.prototype.toString instead\\n        return ctx.toString()\\n      }\\n      return target.call(ctx)\\n    }\\n  }\\n\\n  const toStringProxy = new Proxy(\\n    Function.prototype.toString,\\n    utils.stripProxyFromErrors(handler)\\n  )\\n  utils.replaceProperty(Function.prototype, 'toString', {\\n    value: toStringProxy\\n  })\\n}\",\"patchToStringNested\":\"(obj = {}) => {\\n  return utils.execRecursively(obj, ['function'], utils.patchToString)\\n}\",\"redirectToString\":\"(proxyObj, originalObj) => {\\n  const handler = {\\n    apply: function (target, ctx) {\\n      // This fixes e.g. `HTMLMediaElement.prototype.canPlayType.toString + \\\"\\\"`\\n      if (ctx === Function.prototype.toString) {\\n        return utils.makeNativeString('toString')\\n      }\\n\\n      // `toString` targeted at our proxied Object detected\\n      if (ctx === proxyObj) {\\n        const fallback = () =>\\n          originalObj && originalObj.name\\n            ? utils.makeNativeString(originalObj.name)\\n            : utils.makeNativeString(proxyObj.name)\\n\\n        // Return the toString representation of our original object if possible\\n        return originalObj + '' || fallback()\\n      }\\n\\n      if (typeof ctx === 'undefined' || ctx === null) {\\n        return target.call(ctx)\\n      }\\n\\n      // Check if the toString protype of the context is the same as the global prototype,\\n      // if not indicates that we are doing a check across different windows., e.g. the iframeWithdirect` test case\\n      const hasSameProto = Object.getPrototypeOf(\\n        Function.prototype.toString\\n      ).isPrototypeOf(ctx.toString) // eslint-disable-line no-prototype-builtins\\n      if (!hasSameProto) {\\n        // Pass the call on to the local Function.prototype.toString instead\\n        return ctx.toString()\\n      }\\n\\n      return target.call(ctx)\\n    }\\n  }\\n\\n  const toStringProxy = new Proxy(\\n    Function.prototype.toString,\\n    utils.stripProxyFromErrors(handler)\\n  )\\n  utils.replaceProperty(Function.prototype, 'toString', {\\n    value: toStringProxy\\n  })\\n}\",\"replaceWithProxy\":\"(obj, propName, handler) => {\\n  const originalObj = obj[propName]\\n  const proxyObj = new Proxy(obj[propName], utils.stripProxyFromErrors(handler))\\n\\n  utils.replaceProperty(obj, propName, { value: proxyObj })\\n  utils.redirectToString(proxyObj, originalObj)\\n\\n  return true\\n}\",\"replaceGetterWithProxy\":\"(obj, propName, handler) => {\\n  const fn = Object.getOwnPropertyDescriptor(obj, propName).get\\n  const fnStr = fn.toString() // special getter function string\\n  const proxyObj = new Proxy(fn, utils.stripProxyFromErrors(handler))\\n\\n  utils.replaceProperty(obj, propName, { get: proxyObj })\\n  utils.patchToString(proxyObj, fnStr)\\n\\n  return true\\n}\",\"replaceGetterSetter\":\"(obj, propName, handlerGetterSetter) => {\\n  const ownPropertyDescriptor = Object.getOwnPropertyDescriptor(obj, propName)\\n  const handler = { ...ownPropertyDescriptor }\\n\\n  if (handlerGetterSetter.get !== undefined) {\\n    const nativeFn = ownPropertyDescriptor.get\\n    handler.get = function() {\\n      return handlerGetterSetter.get.call(this, nativeFn.bind(this))\\n    }\\n    utils.redirectToString(handler.get, nativeFn)\\n  }\\n\\n  if (handlerGetterSetter.set !== undefined) {\\n    const nativeFn = ownPropertyDescriptor.set\\n    handler.set = function(newValue) {\\n      handlerGetterSetter.set.call(this, newValue, nativeFn.bind(this))\\n    }\\n    utils.redirectToString(handler.set, nativeFn)\\n  }\\n\\n  Object.defineProperty(obj, propName, handler)\\n}\",\"mockWithProxy\":\"(obj, propName, pseudoTarget, handler) => {\\n  const proxyObj = new Proxy(pseudoTarget, utils.stripProxyFromErrors(handler))\\n\\n  utils.replaceProperty(obj, propName, { value: proxyObj })\\n  utils.patchToString(proxyObj)\\n\\n  return true\\n}\",\"createProxy\":\"(pseudoTarget, handler) => {\\n  const proxyObj = new Proxy(pseudoTarget, utils.stripProxyFromErrors(handler))\\n  utils.patchToString(proxyObj)\\n\\n  return proxyObj\\n}\",\"splitObjPath\":\"objPath => ({\\n  // Remove last dot entry (property) ==> `HTMLMediaElement.prototype`\\n  objName: objPath.split('.').slice(0, -1).join('.'),\\n  // Extract last dot entry ==> `canPlayType`\\n  propName: objPath.split('.').slice(-1)[0]\\n})\",\"replaceObjPathWithProxy\":\"(objPath, handler) => {\\n  const { objName, propName } = utils.splitObjPath(objPath)\\n  const obj = eval(objName) // eslint-disable-line no-eval\\n  return utils.replaceWithProxy(obj, propName, handler)\\n}\",\"execRecursively\":\"(obj = {}, typeFilter = [], fn) => {\\n  function recurse(obj) {\\n    for (const key in obj) {\\n      if (obj[key] === undefined) {\\n        continue\\n      }\\n      if (obj[key] && typeof obj[key] === 'object') {\\n        recurse(obj[key])\\n      } else {\\n        if (obj[key] && typeFilter.includes(typeof obj[key])) {\\n          fn.call(this, obj[key])\\n        }\\n      }\\n    }\\n  }\\n  recurse(obj)\\n  return obj\\n}\",\"stringifyFns\":\"(fnObj = { hello: () => 'world' }) => {\\n  // Object.fromEntries() ponyfill (in 6 lines) - supported only in Node v12+, modern browsers are fine\\n  // https://github.com/feross/fromentries\\n  function fromEntries(iterable) {\\n    return [...iterable].reduce((obj, [key, val]) => {\\n      obj[key] = val\\n      return obj\\n    }, {})\\n  }\\n  return (Object.fromEntries || fromEntries)(\\n    Object.entries(fnObj)\\n      .filter(([key, value]) => typeof value === 'function')\\n      .map(([key, value]) => [key, value.toString()]) // eslint-disable-line no-eval\\n  )\\n}\",\"materializeFns\":\"(fnStrObj = { hello: \\\"() => 'world'\\\" }) => {\\n  return Object.fromEntries(\\n    Object.entries(fnStrObj).map(([key, value]) => {\\n      if (value.startsWith('function')) {\\n        // some trickery is needed to make oldschool functions work :-)\\n        return [key, eval(`() => ${value}`)()] // eslint-disable-line no-eval\\n      } else {\\n        // arrow functions just work\\n        return [key, eval(value)] // eslint-disable-line no-eval\\n      }\\n    })\\n  )\\n}\",\"makeHandler\":\"() => ({\\n  // Used by simple `navigator` getter evasions\\n  getterValue: value => ({\\n    apply(target, ctx, args) {\\n      // Let's fetch the value first, to trigger and escalate potential errors\\n      // Illegal invocations like `navigator.__proto__.vendor` will throw here\\n      utils.cache.Reflect.apply(...arguments)\\n      return value\\n    }\\n  })\\n})\",\"arrayEquals\":\"(array1, array2) => {\\n  if (array1.length !== array2.length) {\\n    return false\\n  }\\n  for (let i = 0; i < array1.length; ++i) {\\n    if (array1[i] !== array2[i]) {\\n      return false\\n    }\\n  }\\n  return true\\n}\",\"memoize\":\"fn => {\\n  const cache = []\\n  return function(...args) {\\n    if (!cache.some(c => utils.arrayEquals(c.key, args))) {\\n      cache.push({ key: args, value: fn.apply(this, args) })\\n    }\\n    return cache.find(c => utils.arrayEquals(c.key, args)).value\\n  }\\n}\"},\"_mainFunction\":\"(utils, opts) => {\\n      try {\\n        // Adds a contentWindow proxy to the provided iframe element\\n        const addContentWindowProxy = iframe => {\\n          const contentWindowProxy = {\\n            get(target, key) {\\n              // Now to the interesting part:\\n              // We actually make this thing behave like a regular iframe window,\\n              // by intercepting calls to e.g. `.self` and redirect it to the correct thing. :)\\n              // That makes it possible for these assertions to be correct:\\n              // iframe.contentWindow.self === window.top // must be false\\n              if (key === 'self') {\\n                return this\\n              }\\n              // iframe.contentWindow.frameElement === iframe // must be true\\n              if (key === 'frameElement') {\\n                return iframe\\n              }\\n              // Intercept iframe.contentWindow[0] to hide the property 0 added by the proxy.\\n              if (key === '0') {\\n                return undefined\\n              }\\n              return Reflect.get(target, key)\\n            }\\n          }\\n\\n          if (!iframe.contentWindow) {\\n            const proxy = new Proxy(window, contentWindowProxy)\\n            Object.defineProperty(iframe, 'contentWindow', {\\n              get() {\\n                return proxy\\n              },\\n              set(newValue) {\\n                return newValue // contentWindow is immutable\\n              },\\n              enumerable: true,\\n              configurable: false\\n            })\\n          }\\n        }\\n\\n        // Handles iframe element creation, augments `srcdoc` property so we can intercept further\\n        const handleIframeCreation = (target, thisArg, args) => {\\n          const iframe = target.apply(thisArg, args)\\n\\n          // We need to keep the originals around\\n          const _iframe = iframe\\n          const _srcdoc = _iframe.srcdoc\\n\\n          // Add hook for the srcdoc property\\n          // We need to be very surgical here to not break other iframes by accident\\n          Object.defineProperty(iframe, 'srcdoc', {\\n            configurable: true, // Important, so we can reset this later\\n            get: function() {\\n              return _srcdoc\\n            },\\n            set: function(newValue) {\\n              addContentWindowProxy(this)\\n              // Reset property, the hook is only needed once\\n              Object.defineProperty(iframe, 'srcdoc', {\\n                configurable: false,\\n                writable: false,\\n                value: _srcdoc\\n              })\\n              _iframe.srcdoc = newValue\\n            }\\n          })\\n          return iframe\\n        }\\n\\n        // Adds a hook to intercept iframe creation events\\n        const addIframeCreationSniffer = () => {\\n          /* global document */\\n          const createElementHandler = {\\n            // Make toString() native\\n            get(target, key) {\\n              return Reflect.get(target, key)\\n            },\\n            apply: function(target, thisArg, args) {\\n              const isIframe =\\n                args && args.length && `${args[0]}`.toLowerCase() === 'iframe'\\n              if (!isIframe) {\\n                // Everything as usual\\n                return target.apply(thisArg, args)\\n              } else {\\n                return handleIframeCreation(target, thisArg, args)\\n              }\\n            }\\n          }\\n          // All this just due to iframes with srcdoc bug\\n          utils.replaceWithProxy(\\n            document,\\n            'createElement',\\n            createElementHandler\\n          )\\n        }\\n\\n        // Let's go\\n        addIframeCreationSniffer()\\n      } catch (err) {\\n        // console.warn(err)\\n      }\\n    }\",\"_args\":[]})"},"stack":[{"file":"/home/neetoci/neeto-chat-web/playwright-tests/node_modules/@bigbinary/neeto-playwright-commons/node_modules/playwright-extra/dist/index.esm.js","line":230,"column":32,"function":"Proxy.<anonymous>"}]}
{"type":"after","callId":"pw:api@12","endTime":87027.744,"annotations":[]}
{"type":"before","callId":"pw:api@27","parentId":"fixture@11","startTime":87028.697,"class":"Test","method":"step","apiName":"page.goto","params":{"url":"about:blank","waitUntil":"load"},"stack":[{"file":"/home/neetoci/neeto-chat-web/playwright-tests/node_modules/@bigbinary/neeto-playwright-commons/node_modules/playwright-extra/dist/index.esm.js","line":779,"column":28,"function":"BrowserContext.newPage"}]}
{"type":"after","callId":"pw:api@13","endTime":87055.958,"annotations":[]}
{"type":"before","callId":"pw:api@28","parentId":"fixture@11","startTime":87057.16,"class":"Test","method":"step","apiName":"cdpSession.send","params":{"method":"Browser.getVersion","params":"undefined"},"stack":[{"file":"/home/neetoci/neeto-chat-web/playwright-tests/node_modules/@bigbinary/neeto-playwright-commons/node_modules/playwright-extra/dist/index.esm.js","line":263,"column":48,"function":"Proxy.<anonymous>"}]}
{"type":"after","callId":"pw:api@14","endTime":87057.354,"annotations":[]}
{"type":"after","callId":"pw:api@15","endTime":87057.418,"annotations":[]}
{"type":"after","callId":"pw:api@16","endTime":87057.485,"annotations":[]}
{"type":"after","callId":"pw:api@17","endTime":87057.53,"annotations":[]}
{"type":"after","callId":"pw:api@18","endTime":87057.579,"annotations":[]}
{"type":"after","callId":"pw:api@19","endTime":87057.626,"annotations":[]}
{"type":"after","callId":"pw:api@20","endTime":87057.673,"annotations":[]}
{"type":"after","callId":"pw:api@21","endTime":87057.72,"annotations":[]}
{"type":"after","callId":"pw:api@22","endTime":87057.769,"annotations":[]}
{"type":"after","callId":"pw:api@23","endTime":87057.817,"annotations":[]}
{"type":"after","callId":"pw:api@24","endTime":87057.865,"annotations":[]}
{"type":"after","callId":"pw:api@25","endTime":87057.905,"annotations":[]}
{"type":"after","callId":"pw:api@26","endTime":87058.862,"annotations":[]}
{"type":"after","callId":"pw:api@28","endTime":87061.278,"annotations":[]}
{"type":"before","callId":"pw:api@29","parentId":"fixture@11","startTime":87062.542,"class":"Test","method":"step","apiName":"browserContext.newCDPSession","params":{"page":"Object"},"stack":[{"file":"/home/neetoci/neeto-chat-web/playwright-tests/node_modules/@bigbinary/neeto-playwright-commons/node_modules/playwright-extra/dist/index.esm.js","line":148,"column":33,"function":"getPageCDPSession"}]}
{"type":"after","callId":"pw:api@29","endTime":87064.836,"annotations":[]}
{"type":"before","callId":"pw:api@30","parentId":"fixture@11","startTime":87065.285,"class":"Test","method":"step","apiName":"cdpSession.send","params":{"method":"Network.setUserAgentOverride","params":"Object"},"stack":[{"file":"/home/neetoci/neeto-chat-web/playwright-tests/node_modules/@bigbinary/neeto-playwright-commons/node_modules/playwright-extra/dist/index.esm.js","line":188,"column":46,"function":"Object.send"}]}
{"type":"after","callId":"pw:api@30","endTime":87128.675,"annotations":[]}
{"type":"after","callId":"pw:api@27","endTime":87130.418,"annotations":[]}
{"type":"after","callId":"fixture@11","endTime":87130.576,"annotations":[]}
{"type":"before","callId":"fixture@31","parentId":"hook@2","startTime":87131.166,"class":"Test","method":"step","apiName":"fixture: page","params":{},"stack":[{"file":"/home/neetoci/neeto-chat-web/playwright-tests/e2e/fixtures/index.ts","line":7,"column":4}]}
{"type":"before","callId":"pw:api@32","parentId":"fixture@31","startTime":87132.819,"class":"Test","method":"step","apiName":"page.goto","params":{"url":"/","timeout":"20000","waitUntil":"load"},"stack":[{"file":"/home/neetoci/neeto-chat-web/playwright-tests/node_modules/@bigbinary/neeto-playwright-commons/build/compiled/fixtures/commands.js","line":11,"column":20,"function":"Object.page"}]}
{"type":"after","callId":"pw:api@32","endTime":91424.317,"annotations":[]}
{"type":"before","callId":"pw:api@33","parentId":"fixture@31","startTime":91426.252,"class":"Test","method":"step","apiName":"page.waitForLoadState","params":{"info":"Object"},"stack":[{"file":"/home/neetoci/neeto-chat-web/playwright-tests/node_modules/@bigbinary/neeto-playwright-commons/build/compiled/fixtures/commands.js","line":12,"column":20,"function":"Object.page"}]}
{"type":"after","callId":"pw:api@33","endTime":91427.206,"annotations":[]}
{"type":"after","callId":"fixture@31","endTime":91427.269,"annotations":[]}
{"type":"before","callId":"fixture@34","parentId":"hook@2","startTime":91427.761,"class":"Test","method":"step","apiName":"fixture: request","params":{},"stack":[]}
{"type":"before","callId":"pw:api@35","parentId":"fixture@34","startTime":91438.214,"class":"Test","method":"step","apiName":"apiRequest.newContext","params":{"acceptDownloads":"true","bypassCSP":"false","colorScheme":"light","deviceScaleFactor":"1","geolocation":"Object","hasTouch":"false","ignoreHTTPSErrors":"false","isMobile":"false","javaScriptEnabled":"true","locale":"en-US","offline":"false","permissions":"[geolocation]","storageState":"Object","timezoneId":"Asia/Calcutta","userAgent":"Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/136.0.7103.25 Safari/537.36","viewport":"Object","baseURL":"https://cpt-chat-05300403215823.neetochat.net","serviceWorkers":"allow","timeout":"10000","extraHTTPHeaders":"undefined","tracesDir":"/home/neetoci/neeto-chat-web/playwright-tests/test-results/.playwright-artifacts-5/traces","clientCertificates":"undefined"},"stack":[]}
{"type":"after","callId":"pw:api@35","endTime":91440.55,"annotations":[]}
{"type":"after","callId":"fixture@34","endTime":91460.702,"annotations":[]}
{"type":"before","callId":"fixture@36","parentId":"hook@2","startTime":91461.152,"class":"Test","method":"step","apiName":"fixture: neetoPlaywrightUtilities","params":{},"stack":[{"file":"/home/neetoci/neeto-chat-web/playwright-tests/e2e/fixtures/index.ts","line":7,"column":4}]}
{"type":"after","callId":"fixture@36","endTime":91462.065,"annotations":[]}
{"type":"before","callId":"fixture@37","parentId":"hook@2","startTime":91462.36,"class":"Test","method":"step","apiName":"fixture: slackPage","params":{},"stack":[{"file":"/home/neetoci/neeto-chat-web/playwright-tests/e2e/fixtures/index.ts","line":9,"column":4}]}
{"type":"after","callId":"fixture@37","endTime":91511.76,"annotations":[]}
{"type":"before","callId":"fixture@38","parentId":"hook@2","startTime":91513.46,"class":"Test","method":"step","apiName":"fixture: automationRulesPage","params":{},"stack":[{"file":"/home/neetoci/neeto-chat-web/playwright-tests/e2e/fixtures/index.ts","line":9,"column":4}]}
{"type":"after","callId":"fixture@38","endTime":91515.246,"annotations":[]}
{"type":"before","callId":"fixture@39","parentId":"hook@2","startTime":91515.723,"class":"Test","method":"step","apiName":"fixture: t","params":{},"stack":[{"file":"/home/neetoci/neeto-chat-web/playwright-tests/e2e/fixtures/index.ts","line":8,"column":4}]}
{"type":"after","callId":"fixture@39","endTime":91516.134,"annotations":[]}
{"type":"before","callId":"fixture@40","parentId":"hook@2","startTime":91516.712,"class":"Test","method":"step","apiName":"fixture: contactApis","params":{},"stack":[{"file":"/home/neetoci/neeto-chat-web/playwright-tests/e2e/fixtures/index.ts","line":9,"column":4}]}
{"type":"after","callId":"fixture@40","endTime":91517.295,"annotations":[]}
{"type":"before","callId":"test.step@41","parentId":"hook@2","startTime":91518.526,"class":"Test","method":"step","apiName":"Step 1: Create a new contact user","params":{},"stack":[{"file":"/home/neetoci/neeto-chat-web/playwright-tests/e2e/tests/integrations/slack.spec.ts","line":30,"column":18}]}
{"type":"before","callId":"pw:api@42","parentId":"test.step@41","startTime":91522.253,"class":"Test","method":"step","apiName":"locator.getAttribute","params":{"selector":"[name='csrf-token']","name":"content","strict":"true"},"stack":[{"file":"/home/neetoci/neeto-chat-web/playwright-tests/node_modules/@bigbinary/neeto-playwright-commons/build/compiled/utils/commands.js","line":16,"column":18,"function":"CustomCommands.initializeCsrfToken"}]}
{"type":"after","callId":"pw:api@42","endTime":91851.218,"annotations":[]}
{"type":"before","callId":"pw:api@43","parentId":"test.step@41","startTime":91853.644,"class":"Test","method":"step","apiName":"apiRequestContext.post","params":{"url":"/api/v1/insights/visitors","params":"undefined","encodedParams":"undefined","method":"POST","headers":"[Object, Object]","postData":"undefined","jsonData":"{\"visitor\":{\"email\":\"Ozella_Schowalter61@example.org\",\"name\":\"Ora Barrows\",\"visitor_token\":\"4d7d5720-263b-4142-849f-a4b6fa127618\",\"traits\":{\"plan\":\"trial\",\"language\":\"English\",\"country\":\"India\",\"created_at\":\"2025-05-30T04:04:46.728Z\"}}}","formData":"undefined","multipartData":"undefined","timeout":"undefined","failOnStatusCode":"true","ignoreHTTPSErrors":"undefined","maxRedirects":"undefined","maxRetries":"undefined","__testHookLookup":"undefined"},"stack":[{"file":"/home/neetoci/neeto-chat-web/playwright-tests/node_modules/@bigbinary/neeto-playwright-commons/build/compiled/utils/commands.js","line":113,"column":46,"function":"CustomCommands.apiRequest"}]}
{"type":"after","callId":"pw:api@43","endTime":92129.51,"annotations":[]}
{"type":"after","callId":"test.step@41","endTime":92129.617,"annotations":[]}
{"type":"before","callId":"test.step@44","parentId":"hook@2","startTime":92130.238,"class":"Test","method":"step","apiName":"Step 2: Login to Slack and open WebApp in new tab","params":{},"stack":[{"file":"/home/neetoci/neeto-chat-web/playwright-tests/e2e/tests/integrations/slack.spec.ts","line":34,"column":18}]}
{"type":"before","callId":"pw:api@45","parentId":"test.step@44","startTime":92131.795,"class":"Test","method":"step","apiName":"browserContext.newPage","params":{},"stack":[{"file":"/home/neetoci/neeto-chat-web/playwright-tests/node_modules/@bigbinary/neeto-playwright-commons/node_modules/playwright-extra/dist/index.esm.js","line":778,"column":51,"function":"BrowserContext.newPage"}]}
{"type":"before","callId":"pw:api@46","parentId":"hook@2","startTime":92237.273,"class":"Test","method":"step","apiName":"page.addInitScript","params":{"source":"(({ _utilsFns, _mainFunction, _args }) => {\n        // Add this point we cannot use our utililty functions as they're just strings, we need to materialize them first\n        const utils = Object.fromEntries(\n          Object.entries(_utilsFns).map(([key, value]) => [key, eval(value)]) // eslint-disable-line no-eval\n        )\n        utils.init()\n        return eval(_mainFunction)(utils, ..._args) // eslint-disable-line no-eval\n      })({\"_utilsFns\":{\"init\":\"() => {\\n  utils.preloadCache()\\n}\",\"stripProxyFromErrors\":\"(handler = {}) => {\\n  const newHandler = {\\n    setPrototypeOf: function (target, proto) {\\n      if (proto === null)\\n        throw new TypeError('Cannot convert object to primitive value')\\n      if (Object.getPrototypeOf(target) === Object.getPrototypeOf(proto)) {\\n        throw new TypeError('Cyclic __proto__ value')\\n      }\\n      return Reflect.setPrototypeOf(target, proto)\\n    }\\n  }\\n  // We wrap each trap in the handler in a try/catch and modify the error stack if they throw\\n  const traps = Object.getOwnPropertyNames(handler)\\n  traps.forEach(trap => {\\n    newHandler[trap] = function () {\\n      try {\\n        // Forward the call to the defined proxy handler\\n        return handler[trap].apply(this, arguments || [])\\n      } catch (err) {\\n        // Stack traces differ per browser, we only support chromium based ones currently\\n        if (!err || !err.stack || !err.stack.includes(`at `)) {\\n          throw err\\n        }\\n\\n        // When something throws within one of our traps the Proxy will show up in error stacks\\n        // An earlier implementation of this code would simply strip lines with a blacklist,\\n        // but it makes sense to be more surgical here and only remove lines related to our Proxy.\\n        // We try to use a known \\\"anchor\\\" line for that and strip it with everything above it.\\n        // If the anchor line cannot be found for some reason we fall back to our blacklist approach.\\n\\n        const stripWithBlacklist = (stack, stripFirstLine = true) => {\\n          const blacklist = [\\n            `at Reflect.${trap} `, // e.g. Reflect.get or Reflect.apply\\n            `at Object.${trap} `, // e.g. Object.get or Object.apply\\n            `at Object.newHandler.<computed> [as ${trap}] ` // caused by this very wrapper :-)\\n          ]\\n          return (\\n            err.stack\\n              .split('\\\\n')\\n              // Always remove the first (file) line in the stack (guaranteed to be our proxy)\\n              .filter((line, index) => !(index === 1 && stripFirstLine))\\n              // Check if the line starts with one of our blacklisted strings\\n              .filter(line => !blacklist.some(bl => line.trim().startsWith(bl)))\\n              .join('\\\\n')\\n          )\\n        }\\n\\n        const stripWithAnchor = (stack, anchor) => {\\n          const stackArr = stack.split('\\\\n')\\n          anchor = anchor || `at Object.newHandler.<computed> [as ${trap}] ` // Known first Proxy line in chromium\\n          const anchorIndex = stackArr.findIndex(line =>\\n            line.trim().startsWith(anchor)\\n          )\\n          if (anchorIndex === -1) {\\n            return false // 404, anchor not found\\n          }\\n          // Strip everything from the top until we reach the anchor line\\n          // Note: We're keeping the 1st line (zero index) as it's unrelated (e.g. `TypeError`)\\n          stackArr.splice(1, anchorIndex)\\n          return stackArr.join('\\\\n')\\n        }\\n\\n        // Special cases due to our nested toString proxies\\n        err.stack = err.stack.replace(\\n          'at Object.toString (',\\n          'at Function.toString ('\\n        )\\n        if ((err.stack || '').includes('at Function.toString (')) {\\n          err.stack = stripWithBlacklist(err.stack, false)\\n          throw err\\n        }\\n\\n        // Try using the anchor method, fallback to blacklist if necessary\\n        err.stack = stripWithAnchor(err.stack) || stripWithBlacklist(err.stack)\\n\\n        throw err // Re-throw our now sanitized error\\n      }\\n    }\\n  })\\n  return newHandler\\n}\",\"stripErrorWithAnchor\":\"(err, anchor) => {\\n  const stackArr = err.stack.split('\\\\n')\\n  const anchorIndex = stackArr.findIndex(line => line.trim().startsWith(anchor))\\n  if (anchorIndex === -1) {\\n    return err // 404, anchor not found\\n  }\\n  // Strip everything from the top until we reach the anchor line (remove anchor line as well)\\n  // Note: We're keeping the 1st line (zero index) as it's unrelated (e.g. `TypeError`)\\n  stackArr.splice(1, anchorIndex)\\n  err.stack = stackArr.join('\\\\n')\\n  return err\\n}\",\"replaceProperty\":\"(obj, propName, descriptorOverrides = {}) => {\\n  return Object.defineProperty(obj, propName, {\\n    // Copy over the existing descriptors (writable, enumerable, configurable, etc)\\n    ...(Object.getOwnPropertyDescriptor(obj, propName) || {}),\\n    // Add our overrides (e.g. value, get())\\n    ...descriptorOverrides\\n  })\\n}\",\"preloadCache\":\"() => {\\n  if (utils.cache) {\\n    return\\n  }\\n  utils.cache = {\\n    // Used in our proxies\\n    Reflect: {\\n      get: Reflect.get.bind(Reflect),\\n      apply: Reflect.apply.bind(Reflect)\\n    },\\n    // Used in `makeNativeString`\\n    nativeToStringStr: Function.toString + '' // => `function toString() { [native code] }`\\n  }\\n}\",\"makeNativeString\":\"(name = '') => {\\n  return utils.cache.nativeToStringStr.replace('toString', name || '')\\n}\",\"patchToString\":\"(obj, str = '') => {\\n  const handler = {\\n    apply: function (target, ctx) {\\n      // This fixes e.g. `HTMLMediaElement.prototype.canPlayType.toString + \\\"\\\"`\\n      if (ctx === Function.prototype.toString) {\\n        return utils.makeNativeString('toString')\\n      }\\n      // `toString` targeted at our proxied Object detected\\n      if (ctx === obj) {\\n        // We either return the optional string verbatim or derive the most desired result automatically\\n        return str || utils.makeNativeString(obj.name)\\n      }\\n      // Check if the toString protype of the context is the same as the global prototype,\\n      // if not indicates that we are doing a check across different windows., e.g. the iframeWithdirect` test case\\n      const hasSameProto = Object.getPrototypeOf(\\n        Function.prototype.toString\\n      ).isPrototypeOf(ctx.toString) // eslint-disable-line no-prototype-builtins\\n      if (!hasSameProto) {\\n        // Pass the call on to the local Function.prototype.toString instead\\n        return ctx.toString()\\n      }\\n      return target.call(ctx)\\n    }\\n  }\\n\\n  const toStringProxy = new Proxy(\\n    Function.prototype.toString,\\n    utils.stripProxyFromErrors(handler)\\n  )\\n  utils.replaceProperty(Function.prototype, 'toString', {\\n    value: toStringProxy\\n  })\\n}\",\"patchToStringNested\":\"(obj = {}) => {\\n  return utils.execRecursively(obj, ['function'], utils.patchToString)\\n}\",\"redirectToString\":\"(proxyObj, originalObj) => {\\n  const handler = {\\n    apply: function (target, ctx) {\\n      // This fixes e.g. `HTMLMediaElement.prototype.canPlayType.toString + \\\"\\\"`\\n      if (ctx === Function.prototype.toString) {\\n        return utils.makeNativeString('toString')\\n      }\\n\\n      // `toString` targeted at our proxied Object detected\\n      if (ctx === proxyObj) {\\n        const fallback = () =>\\n          originalObj && originalObj.name\\n            ? utils.makeNativeString(originalObj.name)\\n            : utils.makeNativeString(proxyObj.name)\\n\\n        // Return the toString representation of our original object if possible\\n        return originalObj + '' || fallback()\\n      }\\n\\n      if (typeof ctx === 'undefined' || ctx === null) {\\n        return target.call(ctx)\\n      }\\n\\n      // Check if the toString protype of the context is the same as the global prototype,\\n      // if not indicates that we are doing a check across different windows., e.g. the iframeWithdirect` test case\\n      const hasSameProto = Object.getPrototypeOf(\\n        Function.prototype.toString\\n      ).isPrototypeOf(ctx.toString) // eslint-disable-line no-prototype-builtins\\n      if (!hasSameProto) {\\n        // Pass the call on to the local Function.prototype.toString instead\\n        return ctx.toString()\\n      }\\n\\n      return target.call(ctx)\\n    }\\n  }\\n\\n  const toStringProxy = new Proxy(\\n    Function.prototype.toString,\\n    utils.stripProxyFromErrors(handler)\\n  )\\n  utils.replaceProperty(Function.prototype, 'toString', {\\n    value: toStringProxy\\n  })\\n}\",\"replaceWithProxy\":\"(obj, propName, handler) => {\\n  const originalObj = obj[propName]\\n  const proxyObj = new Proxy(obj[propName], utils.stripProxyFromErrors(handler))\\n\\n  utils.replaceProperty(obj, propName, { value: proxyObj })\\n  utils.redirectToString(proxyObj, originalObj)\\n\\n  return true\\n}\",\"replaceGetterWithProxy\":\"(obj, propName, handler) => {\\n  const fn = Object.getOwnPropertyDescriptor(obj, propName).get\\n  const fnStr = fn.toString() // special getter function string\\n  const proxyObj = new Proxy(fn, utils.stripProxyFromErrors(handler))\\n\\n  utils.replaceProperty(obj, propName, { get: proxyObj })\\n  utils.patchToString(proxyObj, fnStr)\\n\\n  return true\\n}\",\"replaceGetterSetter\":\"(obj, propName, handlerGetterSetter) => {\\n  const ownPropertyDescriptor = Object.getOwnPropertyDescriptor(obj, propName)\\n  const handler = { ...ownPropertyDescriptor }\\n\\n  if (handlerGetterSetter.get !== undefined) {\\n    const nativeFn = ownPropertyDescriptor.get\\n    handler.get = function() {\\n      return handlerGetterSetter.get.call(this, nativeFn.bind(this))\\n    }\\n    utils.redirectToString(handler.get, nativeFn)\\n  }\\n\\n  if (handlerGetterSetter.set !== undefined) {\\n    const nativeFn = ownPropertyDescriptor.set\\n    handler.set = function(newValue) {\\n      handlerGetterSetter.set.call(this, newValue, nativeFn.bind(this))\\n    }\\n    utils.redirectToString(handler.set, nativeFn)\\n  }\\n\\n  Object.defineProperty(obj, propName, handler)\\n}\",\"mockWithProxy\":\"(obj, propName, pseudoTarget, handler) => {\\n  const proxyObj = new Proxy(pseudoTarget, utils.stripProxyFromErrors(handler))\\n\\n  utils.replaceProperty(obj, propName, { value: proxyObj })\\n  utils.patchToString(proxyObj)\\n\\n  return true\\n}\",\"createProxy\":\"(pseudoTarget, handler) => {\\n  const proxyObj = new Proxy(pseudoTarget, utils.stripProxyFromErrors(handler))\\n  utils.patchToString(proxyObj)\\n\\n  return proxyObj\\n}\",\"splitObjPath\":\"objPath => ({\\n  // Remove last dot entry (property) ==> `HTMLMediaElement.prototype`\\n  objName: objPath.split('.').slice(0, -1).join('.'),\\n  // Extract last dot entry ==> `canPlayType`\\n  propName: objPath.split('.').slice(-1)[0]\\n})\",\"replaceObjPathWithProxy\":\"(objPath, handler) => {\\n  const { objName, propName } = utils.splitObjPath(objPath)\\n  const obj = eval(objName) // eslint-disable-line no-eval\\n  return utils.replaceWithProxy(obj, propName, handler)\\n}\",\"execRecursively\":\"(obj = {}, typeFilter = [], fn) => {\\n  function recurse(obj) {\\n    for (const key in obj) {\\n      if (obj[key] === undefined) {\\n        continue\\n      }\\n      if (obj[key] && typeof obj[key] === 'object') {\\n        recurse(obj[key])\\n      } else {\\n        if (obj[key] && typeFilter.includes(typeof obj[key])) {\\n          fn.call(this, obj[key])\\n        }\\n      }\\n    }\\n  }\\n  recurse(obj)\\n  return obj\\n}\",\"stringifyFns\":\"(fnObj = { hello: () => 'world' }) => {\\n  // Object.fromEntries() ponyfill (in 6 lines) - supported only in Node v12+, modern browsers are fine\\n  // https://github.com/feross/fromentries\\n  function fromEntries(iterable) {\\n    return [...iterable].reduce((obj, [key, val]) => {\\n      obj[key] = val\\n      return obj\\n    }, {})\\n  }\\n  return (Object.fromEntries || fromEntries)(\\n    Object.entries(fnObj)\\n      .filter(([key, value]) => typeof value === 'function')\\n      .map(([key, value]) => [key, value.toString()]) // eslint-disable-line no-eval\\n  )\\n}\",\"materializeFns\":\"(fnStrObj = { hello: \\\"() => 'world'\\\" }) => {\\n  return Object.fromEntries(\\n    Object.entries(fnStrObj).map(([key, value]) => {\\n      if (value.startsWith('function')) {\\n        // some trickery is needed to make oldschool functions work :-)\\n        return [key, eval(`() => ${value}`)()] // eslint-disable-line no-eval\\n      } else {\\n        // arrow functions just work\\n        return [key, eval(value)] // eslint-disable-line no-eval\\n      }\\n    })\\n  )\\n}\",\"makeHandler\":\"() => ({\\n  // Used by simple `navigator` getter evasions\\n  getterValue: value => ({\\n    apply(target, ctx, args) {\\n      // Let's fetch the value first, to trigger and escalate potential errors\\n      // Illegal invocations like `navigator.__proto__.vendor` will throw here\\n      utils.cache.Reflect.apply(...arguments)\\n      return value\\n    }\\n  })\\n})\",\"arrayEquals\":\"(array1, array2) => {\\n  if (array1.length !== array2.length) {\\n    return false\\n  }\\n  for (let i = 0; i < array1.length; ++i) {\\n    if (array1[i] !== array2[i]) {\\n      return false\\n    }\\n  }\\n  return true\\n}\",\"memoize\":\"fn => {\\n  const cache = []\\n  return function(...args) {\\n    if (!cache.some(c => utils.arrayEquals(c.key, args))) {\\n      cache.push({ key: args, value: fn.apply(this, args) })\\n    }\\n    return cache.find(c => utils.arrayEquals(c.key, args)).value\\n  }\\n}\"},\"_mainFunction\":\"utils => {\\n      if (!window.chrome) {\\n        // Use the exact property descriptor found in headful Chrome\\n        // fetch it via `Object.getOwnPropertyDescriptor(window, 'chrome')`\\n        Object.defineProperty(window, 'chrome', {\\n          writable: true,\\n          enumerable: true,\\n          configurable: false, // note!\\n          value: {} // We'll extend that later\\n        })\\n      }\\n\\n      // That means we're running headful and don't need to mock anything\\n      if ('app' in window.chrome) {\\n        return // Nothing to do here\\n      }\\n\\n      const makeError = {\\n        ErrorInInvocation: fn => {\\n          const err = new TypeError(`Error in invocation of app.${fn}()`)\\n          return utils.stripErrorWithAnchor(\\n            err,\\n            `at ${fn} (eval at <anonymous>`\\n          )\\n        }\\n      }\\n\\n      // There's a some static data in that property which doesn't seem to change,\\n      // we should periodically check for updates: `JSON.stringify(window.app, null, 2)`\\n      const STATIC_DATA = JSON.parse(\\n        `\\n{\\n  \\\"isInstalled\\\": false,\\n  \\\"InstallState\\\": {\\n    \\\"DISABLED\\\": \\\"disabled\\\",\\n    \\\"INSTALLED\\\": \\\"installed\\\",\\n    \\\"NOT_INSTALLED\\\": \\\"not_installed\\\"\\n  },\\n  \\\"RunningState\\\": {\\n    \\\"CANNOT_RUN\\\": \\\"cannot_run\\\",\\n    \\\"READY_TO_RUN\\\": \\\"ready_to_run\\\",\\n    \\\"RUNNING\\\": \\\"running\\\"\\n  }\\n}\\n        `.trim()\\n      )\\n\\n      window.chrome.app = {\\n        ...STATIC_DATA,\\n\\n        get isInstalled() {\\n          return false\\n        },\\n\\n        getDetails: function getDetails() {\\n          if (arguments.length) {\\n            throw makeError.ErrorInInvocation(`getDetails`)\\n          }\\n          return null\\n        },\\n        getIsInstalled: function getDetails() {\\n          if (arguments.length) {\\n            throw makeError.ErrorInInvocation(`getIsInstalled`)\\n          }\\n          return false\\n        },\\n        runningState: function getDetails() {\\n          if (arguments.length) {\\n            throw makeError.ErrorInInvocation(`runningState`)\\n          }\\n          return 'cannot_run'\\n        }\\n      }\\n      utils.patchToStringNested(window.chrome.app)\\n    }\",\"_args\":[]})"},"stack":[{"file":"/home/neetoci/neeto-chat-web/playwright-tests/node_modules/@bigbinary/neeto-playwright-commons/node_modules/playwright-extra/dist/index.esm.js","line":230,"column":32,"function":"Proxy.<anonymous>"}]}
{"type":"before","callId":"pw:api@47","parentId":"hook@2","startTime":92239.341,"class":"Test","method":"step","apiName":"page.addInitScript","params":{"source":"(({ _utilsFns, _mainFunction, _args }) => {\n        // Add this point we cannot use our utililty functions as they're just strings, we need to materialize them first\n        const utils = Object.fromEntries(\n          Object.entries(_utilsFns).map(([key, value]) => [key, eval(value)]) // eslint-disable-line no-eval\n        )\n        utils.init()\n        return eval(_mainFunction)(utils, ..._args) // eslint-disable-line no-eval\n      })({\"_utilsFns\":{\"init\":\"() => {\\n  utils.preloadCache()\\n}\",\"stripProxyFromErrors\":\"(handler = {}) => {\\n  const newHandler = {\\n    setPrototypeOf: function (target, proto) {\\n      if (proto === null)\\n        throw new TypeError('Cannot convert object to primitive value')\\n      if (Object.getPrototypeOf(target) === Object.getPrototypeOf(proto)) {\\n        throw new TypeError('Cyclic __proto__ value')\\n      }\\n      return Reflect.setPrototypeOf(target, proto)\\n    }\\n  }\\n  // We wrap each trap in the handler in a try/catch and modify the error stack if they throw\\n  const traps = Object.getOwnPropertyNames(handler)\\n  traps.forEach(trap => {\\n    newHandler[trap] = function () {\\n      try {\\n        // Forward the call to the defined proxy handler\\n        return handler[trap].apply(this, arguments || [])\\n      } catch (err) {\\n        // Stack traces differ per browser, we only support chromium based ones currently\\n        if (!err || !err.stack || !err.stack.includes(`at `)) {\\n          throw err\\n        }\\n\\n        // When something throws within one of our traps the Proxy will show up in error stacks\\n        // An earlier implementation of this code would simply strip lines with a blacklist,\\n        // but it makes sense to be more surgical here and only remove lines related to our Proxy.\\n        // We try to use a known \\\"anchor\\\" line for that and strip it with everything above it.\\n        // If the anchor line cannot be found for some reason we fall back to our blacklist approach.\\n\\n        const stripWithBlacklist = (stack, stripFirstLine = true) => {\\n          const blacklist = [\\n            `at Reflect.${trap} `, // e.g. Reflect.get or Reflect.apply\\n            `at Object.${trap} `, // e.g. Object.get or Object.apply\\n            `at Object.newHandler.<computed> [as ${trap}] ` // caused by this very wrapper :-)\\n          ]\\n          return (\\n            err.stack\\n              .split('\\\\n')\\n              // Always remove the first (file) line in the stack (guaranteed to be our proxy)\\n              .filter((line, index) => !(index === 1 && stripFirstLine))\\n              // Check if the line starts with one of our blacklisted strings\\n              .filter(line => !blacklist.some(bl => line.trim().startsWith(bl)))\\n              .join('\\\\n')\\n          )\\n        }\\n\\n        const stripWithAnchor = (stack, anchor) => {\\n          const stackArr = stack.split('\\\\n')\\n          anchor = anchor || `at Object.newHandler.<computed> [as ${trap}] ` // Known first Proxy line in chromium\\n          const anchorIndex = stackArr.findIndex(line =>\\n            line.trim().startsWith(anchor)\\n          )\\n          if (anchorIndex === -1) {\\n            return false // 404, anchor not found\\n          }\\n          // Strip everything from the top until we reach the anchor line\\n          // Note: We're keeping the 1st line (zero index) as it's unrelated (e.g. `TypeError`)\\n          stackArr.splice(1, anchorIndex)\\n          return stackArr.join('\\\\n')\\n        }\\n\\n        // Special cases due to our nested toString proxies\\n        err.stack = err.stack.replace(\\n          'at Object.toString (',\\n          'at Function.toString ('\\n        )\\n        if ((err.stack || '').includes('at Function.toString (')) {\\n          err.stack = stripWithBlacklist(err.stack, false)\\n          throw err\\n        }\\n\\n        // Try using the anchor method, fallback to blacklist if necessary\\n        err.stack = stripWithAnchor(err.stack) || stripWithBlacklist(err.stack)\\n\\n        throw err // Re-throw our now sanitized error\\n      }\\n    }\\n  })\\n  return newHandler\\n}\",\"stripErrorWithAnchor\":\"(err, anchor) => {\\n  const stackArr = err.stack.split('\\\\n')\\n  const anchorIndex = stackArr.findIndex(line => line.trim().startsWith(anchor))\\n  if (anchorIndex === -1) {\\n    return err // 404, anchor not found\\n  }\\n  // Strip everything from the top until we reach the anchor line (remove anchor line as well)\\n  // Note: We're keeping the 1st line (zero index) as it's unrelated (e.g. `TypeError`)\\n  stackArr.splice(1, anchorIndex)\\n  err.stack = stackArr.join('\\\\n')\\n  return err\\n}\",\"replaceProperty\":\"(obj, propName, descriptorOverrides = {}) => {\\n  return Object.defineProperty(obj, propName, {\\n    // Copy over the existing descriptors (writable, enumerable, configurable, etc)\\n    ...(Object.getOwnPropertyDescriptor(obj, propName) || {}),\\n    // Add our overrides (e.g. value, get())\\n    ...descriptorOverrides\\n  })\\n}\",\"preloadCache\":\"() => {\\n  if (utils.cache) {\\n    return\\n  }\\n  utils.cache = {\\n    // Used in our proxies\\n    Reflect: {\\n      get: Reflect.get.bind(Reflect),\\n      apply: Reflect.apply.bind(Reflect)\\n    },\\n    // Used in `makeNativeString`\\n    nativeToStringStr: Function.toString + '' // => `function toString() { [native code] }`\\n  }\\n}\",\"makeNativeString\":\"(name = '') => {\\n  return utils.cache.nativeToStringStr.replace('toString', name || '')\\n}\",\"patchToString\":\"(obj, str = '') => {\\n  const handler = {\\n    apply: function (target, ctx) {\\n      // This fixes e.g. `HTMLMediaElement.prototype.canPlayType.toString + \\\"\\\"`\\n      if (ctx === Function.prototype.toString) {\\n        return utils.makeNativeString('toString')\\n      }\\n      // `toString` targeted at our proxied Object detected\\n      if (ctx === obj) {\\n        // We either return the optional string verbatim or derive the most desired result automatically\\n        return str || utils.makeNativeString(obj.name)\\n      }\\n      // Check if the toString protype of the context is the same as the global prototype,\\n      // if not indicates that we are doing a check across different windows., e.g. the iframeWithdirect` test case\\n      const hasSameProto = Object.getPrototypeOf(\\n        Function.prototype.toString\\n      ).isPrototypeOf(ctx.toString) // eslint-disable-line no-prototype-builtins\\n      if (!hasSameProto) {\\n        // Pass the call on to the local Function.prototype.toString instead\\n        return ctx.toString()\\n      }\\n      return target.call(ctx)\\n    }\\n  }\\n\\n  const toStringProxy = new Proxy(\\n    Function.prototype.toString,\\n    utils.stripProxyFromErrors(handler)\\n  )\\n  utils.replaceProperty(Function.prototype, 'toString', {\\n    value: toStringProxy\\n  })\\n}\",\"patchToStringNested\":\"(obj = {}) => {\\n  return utils.execRecursively(obj, ['function'], utils.patchToString)\\n}\",\"redirectToString\":\"(proxyObj, originalObj) => {\\n  const handler = {\\n    apply: function (target, ctx) {\\n      // This fixes e.g. `HTMLMediaElement.prototype.canPlayType.toString + \\\"\\\"`\\n      if (ctx === Function.prototype.toString) {\\n        return utils.makeNativeString('toString')\\n      }\\n\\n      // `toString` targeted at our proxied Object detected\\n      if (ctx === proxyObj) {\\n        const fallback = () =>\\n          originalObj && originalObj.name\\n            ? utils.makeNativeString(originalObj.name)\\n            : utils.makeNativeString(proxyObj.name)\\n\\n        // Return the toString representation of our original object if possible\\n        return originalObj + '' || fallback()\\n      }\\n\\n      if (typeof ctx === 'undefined' || ctx === null) {\\n        return target.call(ctx)\\n      }\\n\\n      // Check if the toString protype of the context is the same as the global prototype,\\n      // if not indicates that we are doing a check across different windows., e.g. the iframeWithdirect` test case\\n      const hasSameProto = Object.getPrototypeOf(\\n        Function.prototype.toString\\n      ).isPrototypeOf(ctx.toString) // eslint-disable-line no-prototype-builtins\\n      if (!hasSameProto) {\\n        // Pass the call on to the local Function.prototype.toString instead\\n        return ctx.toString()\\n      }\\n\\n      return target.call(ctx)\\n    }\\n  }\\n\\n  const toStringProxy = new Proxy(\\n    Function.prototype.toString,\\n    utils.stripProxyFromErrors(handler)\\n  )\\n  utils.replaceProperty(Function.prototype, 'toString', {\\n    value: toStringProxy\\n  })\\n}\",\"replaceWithProxy\":\"(obj, propName, handler) => {\\n  const originalObj = obj[propName]\\n  const proxyObj = new Proxy(obj[propName], utils.stripProxyFromErrors(handler))\\n\\n  utils.replaceProperty(obj, propName, { value: proxyObj })\\n  utils.redirectToString(proxyObj, originalObj)\\n\\n  return true\\n}\",\"replaceGetterWithProxy\":\"(obj, propName, handler) => {\\n  const fn = Object.getOwnPropertyDescriptor(obj, propName).get\\n  const fnStr = fn.toString() // special getter function string\\n  const proxyObj = new Proxy(fn, utils.stripProxyFromErrors(handler))\\n\\n  utils.replaceProperty(obj, propName, { get: proxyObj })\\n  utils.patchToString(proxyObj, fnStr)\\n\\n  return true\\n}\",\"replaceGetterSetter\":\"(obj, propName, handlerGetterSetter) => {\\n  const ownPropertyDescriptor = Object.getOwnPropertyDescriptor(obj, propName)\\n  const handler = { ...ownPropertyDescriptor }\\n\\n  if (handlerGetterSetter.get !== undefined) {\\n    const nativeFn = ownPropertyDescriptor.get\\n    handler.get = function() {\\n      return handlerGetterSetter.get.call(this, nativeFn.bind(this))\\n    }\\n    utils.redirectToString(handler.get, nativeFn)\\n  }\\n\\n  if (handlerGetterSetter.set !== undefined) {\\n    const nativeFn = ownPropertyDescriptor.set\\n    handler.set = function(newValue) {\\n      handlerGetterSetter.set.call(this, newValue, nativeFn.bind(this))\\n    }\\n    utils.redirectToString(handler.set, nativeFn)\\n  }\\n\\n  Object.defineProperty(obj, propName, handler)\\n}\",\"mockWithProxy\":\"(obj, propName, pseudoTarget, handler) => {\\n  const proxyObj = new Proxy(pseudoTarget, utils.stripProxyFromErrors(handler))\\n\\n  utils.replaceProperty(obj, propName, { value: proxyObj })\\n  utils.patchToString(proxyObj)\\n\\n  return true\\n}\",\"createProxy\":\"(pseudoTarget, handler) => {\\n  const proxyObj = new Proxy(pseudoTarget, utils.stripProxyFromErrors(handler))\\n  utils.patchToString(proxyObj)\\n\\n  return proxyObj\\n}\",\"splitObjPath\":\"objPath => ({\\n  // Remove last dot entry (property) ==> `HTMLMediaElement.prototype`\\n  objName: objPath.split('.').slice(0, -1).join('.'),\\n  // Extract last dot entry ==> `canPlayType`\\n  propName: objPath.split('.').slice(-1)[0]\\n})\",\"replaceObjPathWithProxy\":\"(objPath, handler) => {\\n  const { objName, propName } = utils.splitObjPath(objPath)\\n  const obj = eval(objName) // eslint-disable-line no-eval\\n  return utils.replaceWithProxy(obj, propName, handler)\\n}\",\"execRecursively\":\"(obj = {}, typeFilter = [], fn) => {\\n  function recurse(obj) {\\n    for (const key in obj) {\\n      if (obj[key] === undefined) {\\n        continue\\n      }\\n      if (obj[key] && typeof obj[key] === 'object') {\\n        recurse(obj[key])\\n      } else {\\n        if (obj[key] && typeFilter.includes(typeof obj[key])) {\\n          fn.call(this, obj[key])\\n        }\\n      }\\n    }\\n  }\\n  recurse(obj)\\n  return obj\\n}\",\"stringifyFns\":\"(fnObj = { hello: () => 'world' }) => {\\n  // Object.fromEntries() ponyfill (in 6 lines) - supported only in Node v12+, modern browsers are fine\\n  // https://github.com/feross/fromentries\\n  function fromEntries(iterable) {\\n    return [...iterable].reduce((obj, [key, val]) => {\\n      obj[key] = val\\n      return obj\\n    }, {})\\n  }\\n  return (Object.fromEntries || fromEntries)(\\n    Object.entries(fnObj)\\n      .filter(([key, value]) => typeof value === 'function')\\n      .map(([key, value]) => [key, value.toString()]) // eslint-disable-line no-eval\\n  )\\n}\",\"materializeFns\":\"(fnStrObj = { hello: \\\"() => 'world'\\\" }) => {\\n  return Object.fromEntries(\\n    Object.entries(fnStrObj).map(([key, value]) => {\\n      if (value.startsWith('function')) {\\n        // some trickery is needed to make oldschool functions work :-)\\n        return [key, eval(`() => ${value}`)()] // eslint-disable-line no-eval\\n      } else {\\n        // arrow functions just work\\n        return [key, eval(value)] // eslint-disable-line no-eval\\n      }\\n    })\\n  )\\n}\",\"makeHandler\":\"() => ({\\n  // Used by simple `navigator` getter evasions\\n  getterValue: value => ({\\n    apply(target, ctx, args) {\\n      // Let's fetch the value first, to trigger and escalate potential errors\\n      // Illegal invocations like `navigator.__proto__.vendor` will throw here\\n      utils.cache.Reflect.apply(...arguments)\\n      return value\\n    }\\n  })\\n})\",\"arrayEquals\":\"(array1, array2) => {\\n  if (array1.length !== array2.length) {\\n    return false\\n  }\\n  for (let i = 0; i < array1.length; ++i) {\\n    if (array1[i] !== array2[i]) {\\n      return false\\n    }\\n  }\\n  return true\\n}\",\"memoize\":\"fn => {\\n  const cache = []\\n  return function(...args) {\\n    if (!cache.some(c => utils.arrayEquals(c.key, args))) {\\n      cache.push({ key: args, value: fn.apply(this, args) })\\n    }\\n    return cache.find(c => utils.arrayEquals(c.key, args)).value\\n  }\\n}\"},\"_mainFunction\":\"utils => {\\n      if (!window.chrome) {\\n        // Use the exact property descriptor found in headful Chrome\\n        // fetch it via `Object.getOwnPropertyDescriptor(window, 'chrome')`\\n        Object.defineProperty(window, 'chrome', {\\n          writable: true,\\n          enumerable: true,\\n          configurable: false, // note!\\n          value: {} // We'll extend that later\\n        })\\n      }\\n\\n      // That means we're running headful and don't need to mock anything\\n      if ('csi' in window.chrome) {\\n        return // Nothing to do here\\n      }\\n\\n      // Check that the Navigation Timing API v1 is available, we need that\\n      if (!window.performance || !window.performance.timing) {\\n        return\\n      }\\n\\n      const { timing } = window.performance\\n\\n      window.chrome.csi = function() {\\n        return {\\n          onloadT: timing.domContentLoadedEventEnd,\\n          startE: timing.navigationStart,\\n          pageT: Date.now() - timing.navigationStart,\\n          tran: 15 // Transition type or something\\n        }\\n      }\\n      utils.patchToString(window.chrome.csi)\\n    }\",\"_args\":[]})"},"stack":[{"file":"/home/neetoci/neeto-chat-web/playwright-tests/node_modules/@bigbinary/neeto-playwright-commons/node_modules/playwright-extra/dist/index.esm.js","line":230,"column":32,"function":"Proxy.<anonymous>"}]}
{"type":"before","callId":"pw:api@48","parentId":"hook@2","startTime":92240.255,"class":"Test","method":"step","apiName":"page.addInitScript","params":{"source":"(({ _utilsFns, _mainFunction, _args }) => {\n        // Add this point we cannot use our utililty functions as they're just strings, we need to materialize them first\n        const utils = Object.fromEntries(\n          Object.entries(_utilsFns).map(([key, value]) => [key, eval(value)]) // eslint-disable-line no-eval\n        )\n        utils.init()\n        return eval(_mainFunction)(utils, ..._args) // eslint-disable-line no-eval\n      })({\"_utilsFns\":{\"init\":\"() => {\\n  utils.preloadCache()\\n}\",\"stripProxyFromErrors\":\"(handler = {}) => {\\n  const newHandler = {\\n    setPrototypeOf: function (target, proto) {\\n      if (proto === null)\\n        throw new TypeError('Cannot convert object to primitive value')\\n      if (Object.getPrototypeOf(target) === Object.getPrototypeOf(proto)) {\\n        throw new TypeError('Cyclic __proto__ value')\\n      }\\n      return Reflect.setPrototypeOf(target, proto)\\n    }\\n  }\\n  // We wrap each trap in the handler in a try/catch and modify the error stack if they throw\\n  const traps = Object.getOwnPropertyNames(handler)\\n  traps.forEach(trap => {\\n    newHandler[trap] = function () {\\n      try {\\n        // Forward the call to the defined proxy handler\\n        return handler[trap].apply(this, arguments || [])\\n      } catch (err) {\\n        // Stack traces differ per browser, we only support chromium based ones currently\\n        if (!err || !err.stack || !err.stack.includes(`at `)) {\\n          throw err\\n        }\\n\\n        // When something throws within one of our traps the Proxy will show up in error stacks\\n        // An earlier implementation of this code would simply strip lines with a blacklist,\\n        // but it makes sense to be more surgical here and only remove lines related to our Proxy.\\n        // We try to use a known \\\"anchor\\\" line for that and strip it with everything above it.\\n        // If the anchor line cannot be found for some reason we fall back to our blacklist approach.\\n\\n        const stripWithBlacklist = (stack, stripFirstLine = true) => {\\n          const blacklist = [\\n            `at Reflect.${trap} `, // e.g. Reflect.get or Reflect.apply\\n            `at Object.${trap} `, // e.g. Object.get or Object.apply\\n            `at Object.newHandler.<computed> [as ${trap}] ` // caused by this very wrapper :-)\\n          ]\\n          return (\\n            err.stack\\n              .split('\\\\n')\\n              // Always remove the first (file) line in the stack (guaranteed to be our proxy)\\n              .filter((line, index) => !(index === 1 && stripFirstLine))\\n              // Check if the line starts with one of our blacklisted strings\\n              .filter(line => !blacklist.some(bl => line.trim().startsWith(bl)))\\n              .join('\\\\n')\\n          )\\n        }\\n\\n        const stripWithAnchor = (stack, anchor) => {\\n          const stackArr = stack.split('\\\\n')\\n          anchor = anchor || `at Object.newHandler.<computed> [as ${trap}] ` // Known first Proxy line in chromium\\n          const anchorIndex = stackArr.findIndex(line =>\\n            line.trim().startsWith(anchor)\\n          )\\n          if (anchorIndex === -1) {\\n            return false // 404, anchor not found\\n          }\\n          // Strip everything from the top until we reach the anchor line\\n          // Note: We're keeping the 1st line (zero index) as it's unrelated (e.g. `TypeError`)\\n          stackArr.splice(1, anchorIndex)\\n          return stackArr.join('\\\\n')\\n        }\\n\\n        // Special cases due to our nested toString proxies\\n        err.stack = err.stack.replace(\\n          'at Object.toString (',\\n          'at Function.toString ('\\n        )\\n        if ((err.stack || '').includes('at Function.toString (')) {\\n          err.stack = stripWithBlacklist(err.stack, false)\\n          throw err\\n        }\\n\\n        // Try using the anchor method, fallback to blacklist if necessary\\n        err.stack = stripWithAnchor(err.stack) || stripWithBlacklist(err.stack)\\n\\n        throw err // Re-throw our now sanitized error\\n      }\\n    }\\n  })\\n  return newHandler\\n}\",\"stripErrorWithAnchor\":\"(err, anchor) => {\\n  const stackArr = err.stack.split('\\\\n')\\n  const anchorIndex = stackArr.findIndex(line => line.trim().startsWith(anchor))\\n  if (anchorIndex === -1) {\\n    return err // 404, anchor not found\\n  }\\n  // Strip everything from the top until we reach the anchor line (remove anchor line as well)\\n  // Note: We're keeping the 1st line (zero index) as it's unrelated (e.g. `TypeError`)\\n  stackArr.splice(1, anchorIndex)\\n  err.stack = stackArr.join('\\\\n')\\n  return err\\n}\",\"replaceProperty\":\"(obj, propName, descriptorOverrides = {}) => {\\n  return Object.defineProperty(obj, propName, {\\n    // Copy over the existing descriptors (writable, enumerable, configurable, etc)\\n    ...(Object.getOwnPropertyDescriptor(obj, propName) || {}),\\n    // Add our overrides (e.g. value, get())\\n    ...descriptorOverrides\\n  })\\n}\",\"preloadCache\":\"() => {\\n  if (utils.cache) {\\n    return\\n  }\\n  utils.cache = {\\n    // Used in our proxies\\n    Reflect: {\\n      get: Reflect.get.bind(Reflect),\\n      apply: Reflect.apply.bind(Reflect)\\n    },\\n    // Used in `makeNativeString`\\n    nativeToStringStr: Function.toString + '' // => `function toString() { [native code] }`\\n  }\\n}\",\"makeNativeString\":\"(name = '') => {\\n  return utils.cache.nativeToStringStr.replace('toString', name || '')\\n}\",\"patchToString\":\"(obj, str = '') => {\\n  const handler = {\\n    apply: function (target, ctx) {\\n      // This fixes e.g. `HTMLMediaElement.prototype.canPlayType.toString + \\\"\\\"`\\n      if (ctx === Function.prototype.toString) {\\n        return utils.makeNativeString('toString')\\n      }\\n      // `toString` targeted at our proxied Object detected\\n      if (ctx === obj) {\\n        // We either return the optional string verbatim or derive the most desired result automatically\\n        return str || utils.makeNativeString(obj.name)\\n      }\\n      // Check if the toString protype of the context is the same as the global prototype,\\n      // if not indicates that we are doing a check across different windows., e.g. the iframeWithdirect` test case\\n      const hasSameProto = Object.getPrototypeOf(\\n        Function.prototype.toString\\n      ).isPrototypeOf(ctx.toString) // eslint-disable-line no-prototype-builtins\\n      if (!hasSameProto) {\\n        // Pass the call on to the local Function.prototype.toString instead\\n        return ctx.toString()\\n      }\\n      return target.call(ctx)\\n    }\\n  }\\n\\n  const toStringProxy = new Proxy(\\n    Function.prototype.toString,\\n    utils.stripProxyFromErrors(handler)\\n  )\\n  utils.replaceProperty(Function.prototype, 'toString', {\\n    value: toStringProxy\\n  })\\n}\",\"patchToStringNested\":\"(obj = {}) => {\\n  return utils.execRecursively(obj, ['function'], utils.patchToString)\\n}\",\"redirectToString\":\"(proxyObj, originalObj) => {\\n  const handler = {\\n    apply: function (target, ctx) {\\n      // This fixes e.g. `HTMLMediaElement.prototype.canPlayType.toString + \\\"\\\"`\\n      if (ctx === Function.prototype.toString) {\\n        return utils.makeNativeString('toString')\\n      }\\n\\n      // `toString` targeted at our proxied Object detected\\n      if (ctx === proxyObj) {\\n        const fallback = () =>\\n          originalObj && originalObj.name\\n            ? utils.makeNativeString(originalObj.name)\\n            : utils.makeNativeString(proxyObj.name)\\n\\n        // Return the toString representation of our original object if possible\\n        return originalObj + '' || fallback()\\n      }\\n\\n      if (typeof ctx === 'undefined' || ctx === null) {\\n        return target.call(ctx)\\n      }\\n\\n      // Check if the toString protype of the context is the same as the global prototype,\\n      // if not indicates that we are doing a check across different windows., e.g. the iframeWithdirect` test case\\n      const hasSameProto = Object.getPrototypeOf(\\n        Function.prototype.toString\\n      ).isPrototypeOf(ctx.toString) // eslint-disable-line no-prototype-builtins\\n      if (!hasSameProto) {\\n        // Pass the call on to the local Function.prototype.toString instead\\n        return ctx.toString()\\n      }\\n\\n      return target.call(ctx)\\n    }\\n  }\\n\\n  const toStringProxy = new Proxy(\\n    Function.prototype.toString,\\n    utils.stripProxyFromErrors(handler)\\n  )\\n  utils.replaceProperty(Function.prototype, 'toString', {\\n    value: toStringProxy\\n  })\\n}\",\"replaceWithProxy\":\"(obj, propName, handler) => {\\n  const originalObj = obj[propName]\\n  const proxyObj = new Proxy(obj[propName], utils.stripProxyFromErrors(handler))\\n\\n  utils.replaceProperty(obj, propName, { value: proxyObj })\\n  utils.redirectToString(proxyObj, originalObj)\\n\\n  return true\\n}\",\"replaceGetterWithProxy\":\"(obj, propName, handler) => {\\n  const fn = Object.getOwnPropertyDescriptor(obj, propName).get\\n  const fnStr = fn.toString() // special getter function string\\n  const proxyObj = new Proxy(fn, utils.stripProxyFromErrors(handler))\\n\\n  utils.replaceProperty(obj, propName, { get: proxyObj })\\n  utils.patchToString(proxyObj, fnStr)\\n\\n  return true\\n}\",\"replaceGetterSetter\":\"(obj, propName, handlerGetterSetter) => {\\n  const ownPropertyDescriptor = Object.getOwnPropertyDescriptor(obj, propName)\\n  const handler = { ...ownPropertyDescriptor }\\n\\n  if (handlerGetterSetter.get !== undefined) {\\n    const nativeFn = ownPropertyDescriptor.get\\n    handler.get = function() {\\n      return handlerGetterSetter.get.call(this, nativeFn.bind(this))\\n    }\\n    utils.redirectToString(handler.get, nativeFn)\\n  }\\n\\n  if (handlerGetterSetter.set !== undefined) {\\n    const nativeFn = ownPropertyDescriptor.set\\n    handler.set = function(newValue) {\\n      handlerGetterSetter.set.call(this, newValue, nativeFn.bind(this))\\n    }\\n    utils.redirectToString(handler.set, nativeFn)\\n  }\\n\\n  Object.defineProperty(obj, propName, handler)\\n}\",\"mockWithProxy\":\"(obj, propName, pseudoTarget, handler) => {\\n  const proxyObj = new Proxy(pseudoTarget, utils.stripProxyFromErrors(handler))\\n\\n  utils.replaceProperty(obj, propName, { value: proxyObj })\\n  utils.patchToString(proxyObj)\\n\\n  return true\\n}\",\"createProxy\":\"(pseudoTarget, handler) => {\\n  const proxyObj = new Proxy(pseudoTarget, utils.stripProxyFromErrors(handler))\\n  utils.patchToString(proxyObj)\\n\\n  return proxyObj\\n}\",\"splitObjPath\":\"objPath => ({\\n  // Remove last dot entry (property) ==> `HTMLMediaElement.prototype`\\n  objName: objPath.split('.').slice(0, -1).join('.'),\\n  // Extract last dot entry ==> `canPlayType`\\n  propName: objPath.split('.').slice(-1)[0]\\n})\",\"replaceObjPathWithProxy\":\"(objPath, handler) => {\\n  const { objName, propName } = utils.splitObjPath(objPath)\\n  const obj = eval(objName) // eslint-disable-line no-eval\\n  return utils.replaceWithProxy(obj, propName, handler)\\n}\",\"execRecursively\":\"(obj = {}, typeFilter = [], fn) => {\\n  function recurse(obj) {\\n    for (const key in obj) {\\n      if (obj[key] === undefined) {\\n        continue\\n      }\\n      if (obj[key] && typeof obj[key] === 'object') {\\n        recurse(obj[key])\\n      } else {\\n        if (obj[key] && typeFilter.includes(typeof obj[key])) {\\n          fn.call(this, obj[key])\\n        }\\n      }\\n    }\\n  }\\n  recurse(obj)\\n  return obj\\n}\",\"stringifyFns\":\"(fnObj = { hello: () => 'world' }) => {\\n  // Object.fromEntries() ponyfill (in 6 lines) - supported only in Node v12+, modern browsers are fine\\n  // https://github.com/feross/fromentries\\n  function fromEntries(iterable) {\\n    return [...iterable].reduce((obj, [key, val]) => {\\n      obj[key] = val\\n      return obj\\n    }, {})\\n  }\\n  return (Object.fromEntries || fromEntries)(\\n    Object.entries(fnObj)\\n      .filter(([key, value]) => typeof value === 'function')\\n      .map(([key, value]) => [key, value.toString()]) // eslint-disable-line no-eval\\n  )\\n}\",\"materializeFns\":\"(fnStrObj = { hello: \\\"() => 'world'\\\" }) => {\\n  return Object.fromEntries(\\n    Object.entries(fnStrObj).map(([key, value]) => {\\n      if (value.startsWith('function')) {\\n        // some trickery is needed to make oldschool functions work :-)\\n        return [key, eval(`() => ${value}`)()] // eslint-disable-line no-eval\\n      } else {\\n        // arrow functions just work\\n        return [key, eval(value)] // eslint-disable-line no-eval\\n      }\\n    })\\n  )\\n}\",\"makeHandler\":\"() => ({\\n  // Used by simple `navigator` getter evasions\\n  getterValue: value => ({\\n    apply(target, ctx, args) {\\n      // Let's fetch the value first, to trigger and escalate potential errors\\n      // Illegal invocations like `navigator.__proto__.vendor` will throw here\\n      utils.cache.Reflect.apply(...arguments)\\n      return value\\n    }\\n  })\\n})\",\"arrayEquals\":\"(array1, array2) => {\\n  if (array1.length !== array2.length) {\\n    return false\\n  }\\n  for (let i = 0; i < array1.length; ++i) {\\n    if (array1[i] !== array2[i]) {\\n      return false\\n    }\\n  }\\n  return true\\n}\",\"memoize\":\"fn => {\\n  const cache = []\\n  return function(...args) {\\n    if (!cache.some(c => utils.arrayEquals(c.key, args))) {\\n      cache.push({ key: args, value: fn.apply(this, args) })\\n    }\\n    return cache.find(c => utils.arrayEquals(c.key, args)).value\\n  }\\n}\"},\"_mainFunction\":\"(utils, { opts }) => {\\n        if (!window.chrome) {\\n          // Use the exact property descriptor found in headful Chrome\\n          // fetch it via `Object.getOwnPropertyDescriptor(window, 'chrome')`\\n          Object.defineProperty(window, 'chrome', {\\n            writable: true,\\n            enumerable: true,\\n            configurable: false, // note!\\n            value: {} // We'll extend that later\\n          })\\n        }\\n\\n        // That means we're running headful and don't need to mock anything\\n        if ('loadTimes' in window.chrome) {\\n          return // Nothing to do here\\n        }\\n\\n        // Check that the Navigation Timing API v1 + v2 is available, we need that\\n        if (\\n          !window.performance ||\\n          !window.performance.timing ||\\n          !window.PerformancePaintTiming\\n        ) {\\n          return\\n        }\\n\\n        const { performance } = window\\n\\n        // Some stuff is not available on about:blank as it requires a navigation to occur,\\n        // let's harden the code to not fail then:\\n        const ntEntryFallback = {\\n          nextHopProtocol: 'h2',\\n          type: 'other'\\n        }\\n\\n        // The API exposes some funky info regarding the connection\\n        const protocolInfo = {\\n          get connectionInfo() {\\n            const ntEntry =\\n              performance.getEntriesByType('navigation')[0] || ntEntryFallback\\n            return ntEntry.nextHopProtocol\\n          },\\n          get npnNegotiatedProtocol() {\\n            // NPN is deprecated in favor of ALPN, but this implementation returns the\\n            // HTTP/2 or HTTP2+QUIC/39 requests negotiated via ALPN.\\n            const ntEntry =\\n              performance.getEntriesByType('navigation')[0] || ntEntryFallback\\n            return ['h2', 'hq'].includes(ntEntry.nextHopProtocol)\\n              ? ntEntry.nextHopProtocol\\n              : 'unknown'\\n          },\\n          get navigationType() {\\n            const ntEntry =\\n              performance.getEntriesByType('navigation')[0] || ntEntryFallback\\n            return ntEntry.type\\n          },\\n          get wasAlternateProtocolAvailable() {\\n            // The Alternate-Protocol header is deprecated in favor of Alt-Svc\\n            // (https://www.mnot.net/blog/2016/03/09/alt-svc), so technically this\\n            // should always return false.\\n            return false\\n          },\\n          get wasFetchedViaSpdy() {\\n            // SPDY is deprecated in favor of HTTP/2, but this implementation returns\\n            // true for HTTP/2 or HTTP2+QUIC/39 as well.\\n            const ntEntry =\\n              performance.getEntriesByType('navigation')[0] || ntEntryFallback\\n            return ['h2', 'hq'].includes(ntEntry.nextHopProtocol)\\n          },\\n          get wasNpnNegotiated() {\\n            // NPN is deprecated in favor of ALPN, but this implementation returns true\\n            // for HTTP/2 or HTTP2+QUIC/39 requests negotiated via ALPN.\\n            const ntEntry =\\n              performance.getEntriesByType('navigation')[0] || ntEntryFallback\\n            return ['h2', 'hq'].includes(ntEntry.nextHopProtocol)\\n          }\\n        }\\n\\n        const { timing } = window.performance\\n\\n        // Truncate number to specific number of decimals, most of the `loadTimes` stuff has 3\\n        function toFixed(num, fixed) {\\n          var re = new RegExp('^-?\\\\\\\\d+(?:.\\\\\\\\d{0,' + (fixed || -1) + '})?')\\n          return num.toString().match(re)[0]\\n        }\\n\\n        const timingInfo = {\\n          get firstPaintAfterLoadTime() {\\n            // This was never actually implemented and always returns 0.\\n            return 0\\n          },\\n          get requestTime() {\\n            return timing.navigationStart / 1000\\n          },\\n          get startLoadTime() {\\n            return timing.navigationStart / 1000\\n          },\\n          get commitLoadTime() {\\n            return timing.responseStart / 1000\\n          },\\n          get finishDocumentLoadTime() {\\n            return timing.domContentLoadedEventEnd / 1000\\n          },\\n          get finishLoadTime() {\\n            return timing.loadEventEnd / 1000\\n          },\\n          get firstPaintTime() {\\n            const fpEntry = performance.getEntriesByType('paint')[0] || {\\n              startTime: timing.loadEventEnd / 1000 // Fallback if no navigation occured (`about:blank`)\\n            }\\n            return toFixed(\\n              (fpEntry.startTime + performance.timeOrigin) / 1000,\\n              3\\n            )\\n          }\\n        }\\n\\n        window.chrome.loadTimes = function() {\\n          return {\\n            ...protocolInfo,\\n            ...timingInfo\\n          }\\n        }\\n        utils.patchToString(window.chrome.loadTimes)\\n      }\",\"_args\":[{\"opts\":{}}]})"},"stack":[{"file":"/home/neetoci/neeto-chat-web/playwright-tests/node_modules/@bigbinary/neeto-playwright-commons/node_modules/playwright-extra/dist/index.esm.js","line":230,"column":32,"function":"Proxy.<anonymous>"}]}
{"type":"before","callId":"pw:api@49","parentId":"hook@2","startTime":92240.985,"class":"Test","method":"step","apiName":"page.addInitScript","params":{"source":"(({ _utilsFns, _mainFunction, _args }) => {\n        // Add this point we cannot use our utililty functions as they're just strings, we need to materialize them first\n        const utils = Object.fromEntries(\n          Object.entries(_utilsFns).map(([key, value]) => [key, eval(value)]) // eslint-disable-line no-eval\n        )\n        utils.init()\n        return eval(_mainFunction)(utils, ..._args) // eslint-disable-line no-eval\n      })({\"_utilsFns\":{\"init\":\"() => {\\n  utils.preloadCache()\\n}\",\"stripProxyFromErrors\":\"(handler = {}) => {\\n  const newHandler = {\\n    setPrototypeOf: function (target, proto) {\\n      if (proto === null)\\n        throw new TypeError('Cannot convert object to primitive value')\\n      if (Object.getPrototypeOf(target) === Object.getPrototypeOf(proto)) {\\n        throw new TypeError('Cyclic __proto__ value')\\n      }\\n      return Reflect.setPrototypeOf(target, proto)\\n    }\\n  }\\n  // We wrap each trap in the handler in a try/catch and modify the error stack if they throw\\n  const traps = Object.getOwnPropertyNames(handler)\\n  traps.forEach(trap => {\\n    newHandler[trap] = function () {\\n      try {\\n        // Forward the call to the defined proxy handler\\n        return handler[trap].apply(this, arguments || [])\\n      } catch (err) {\\n        // Stack traces differ per browser, we only support chromium based ones currently\\n        if (!err || !err.stack || !err.stack.includes(`at `)) {\\n          throw err\\n        }\\n\\n        // When something throws within one of our traps the Proxy will show up in error stacks\\n        // An earlier implementation of this code would simply strip lines with a blacklist,\\n        // but it makes sense to be more surgical here and only remove lines related to our Proxy.\\n        // We try to use a known \\\"anchor\\\" line for that and strip it with everything above it.\\n        // If the anchor line cannot be found for some reason we fall back to our blacklist approach.\\n\\n        const stripWithBlacklist = (stack, stripFirstLine = true) => {\\n          const blacklist = [\\n            `at Reflect.${trap} `, // e.g. Reflect.get or Reflect.apply\\n            `at Object.${trap} `, // e.g. Object.get or Object.apply\\n            `at Object.newHandler.<computed> [as ${trap}] ` // caused by this very wrapper :-)\\n          ]\\n          return (\\n            err.stack\\n              .split('\\\\n')\\n              // Always remove the first (file) line in the stack (guaranteed to be our proxy)\\n              .filter((line, index) => !(index === 1 && stripFirstLine))\\n              // Check if the line starts with one of our blacklisted strings\\n              .filter(line => !blacklist.some(bl => line.trim().startsWith(bl)))\\n              .join('\\\\n')\\n          )\\n        }\\n\\n        const stripWithAnchor = (stack, anchor) => {\\n          const stackArr = stack.split('\\\\n')\\n          anchor = anchor || `at Object.newHandler.<computed> [as ${trap}] ` // Known first Proxy line in chromium\\n          const anchorIndex = stackArr.findIndex(line =>\\n            line.trim().startsWith(anchor)\\n          )\\n          if (anchorIndex === -1) {\\n            return false // 404, anchor not found\\n          }\\n          // Strip everything from the top until we reach the anchor line\\n          // Note: We're keeping the 1st line (zero index) as it's unrelated (e.g. `TypeError`)\\n          stackArr.splice(1, anchorIndex)\\n          return stackArr.join('\\\\n')\\n        }\\n\\n        // Special cases due to our nested toString proxies\\n        err.stack = err.stack.replace(\\n          'at Object.toString (',\\n          'at Function.toString ('\\n        )\\n        if ((err.stack || '').includes('at Function.toString (')) {\\n          err.stack = stripWithBlacklist(err.stack, false)\\n          throw err\\n        }\\n\\n        // Try using the anchor method, fallback to blacklist if necessary\\n        err.stack = stripWithAnchor(err.stack) || stripWithBlacklist(err.stack)\\n\\n        throw err // Re-throw our now sanitized error\\n      }\\n    }\\n  })\\n  return newHandler\\n}\",\"stripErrorWithAnchor\":\"(err, anchor) => {\\n  const stackArr = err.stack.split('\\\\n')\\n  const anchorIndex = stackArr.findIndex(line => line.trim().startsWith(anchor))\\n  if (anchorIndex === -1) {\\n    return err // 404, anchor not found\\n  }\\n  // Strip everything from the top until we reach the anchor line (remove anchor line as well)\\n  // Note: We're keeping the 1st line (zero index) as it's unrelated (e.g. `TypeError`)\\n  stackArr.splice(1, anchorIndex)\\n  err.stack = stackArr.join('\\\\n')\\n  return err\\n}\",\"replaceProperty\":\"(obj, propName, descriptorOverrides = {}) => {\\n  return Object.defineProperty(obj, propName, {\\n    // Copy over the existing descriptors (writable, enumerable, configurable, etc)\\n    ...(Object.getOwnPropertyDescriptor(obj, propName) || {}),\\n    // Add our overrides (e.g. value, get())\\n    ...descriptorOverrides\\n  })\\n}\",\"preloadCache\":\"() => {\\n  if (utils.cache) {\\n    return\\n  }\\n  utils.cache = {\\n    // Used in our proxies\\n    Reflect: {\\n      get: Reflect.get.bind(Reflect),\\n      apply: Reflect.apply.bind(Reflect)\\n    },\\n    // Used in `makeNativeString`\\n    nativeToStringStr: Function.toString + '' // => `function toString() { [native code] }`\\n  }\\n}\",\"makeNativeString\":\"(name = '') => {\\n  return utils.cache.nativeToStringStr.replace('toString', name || '')\\n}\",\"patchToString\":\"(obj, str = '') => {\\n  const handler = {\\n    apply: function (target, ctx) {\\n      // This fixes e.g. `HTMLMediaElement.prototype.canPlayType.toString + \\\"\\\"`\\n      if (ctx === Function.prototype.toString) {\\n        return utils.makeNativeString('toString')\\n      }\\n      // `toString` targeted at our proxied Object detected\\n      if (ctx === obj) {\\n        // We either return the optional string verbatim or derive the most desired result automatically\\n        return str || utils.makeNativeString(obj.name)\\n      }\\n      // Check if the toString protype of the context is the same as the global prototype,\\n      // if not indicates that we are doing a check across different windows., e.g. the iframeWithdirect` test case\\n      const hasSameProto = Object.getPrototypeOf(\\n        Function.prototype.toString\\n      ).isPrototypeOf(ctx.toString) // eslint-disable-line no-prototype-builtins\\n      if (!hasSameProto) {\\n        // Pass the call on to the local Function.prototype.toString instead\\n        return ctx.toString()\\n      }\\n      return target.call(ctx)\\n    }\\n  }\\n\\n  const toStringProxy = new Proxy(\\n    Function.prototype.toString,\\n    utils.stripProxyFromErrors(handler)\\n  )\\n  utils.replaceProperty(Function.prototype, 'toString', {\\n    value: toStringProxy\\n  })\\n}\",\"patchToStringNested\":\"(obj = {}) => {\\n  return utils.execRecursively(obj, ['function'], utils.patchToString)\\n}\",\"redirectToString\":\"(proxyObj, originalObj) => {\\n  const handler = {\\n    apply: function (target, ctx) {\\n      // This fixes e.g. `HTMLMediaElement.prototype.canPlayType.toString + \\\"\\\"`\\n      if (ctx === Function.prototype.toString) {\\n        return utils.makeNativeString('toString')\\n      }\\n\\n      // `toString` targeted at our proxied Object detected\\n      if (ctx === proxyObj) {\\n        const fallback = () =>\\n          originalObj && originalObj.name\\n            ? utils.makeNativeString(originalObj.name)\\n            : utils.makeNativeString(proxyObj.name)\\n\\n        // Return the toString representation of our original object if possible\\n        return originalObj + '' || fallback()\\n      }\\n\\n      if (typeof ctx === 'undefined' || ctx === null) {\\n        return target.call(ctx)\\n      }\\n\\n      // Check if the toString protype of the context is the same as the global prototype,\\n      // if not indicates that we are doing a check across different windows., e.g. the iframeWithdirect` test case\\n      const hasSameProto = Object.getPrototypeOf(\\n        Function.prototype.toString\\n      ).isPrototypeOf(ctx.toString) // eslint-disable-line no-prototype-builtins\\n      if (!hasSameProto) {\\n        // Pass the call on to the local Function.prototype.toString instead\\n        return ctx.toString()\\n      }\\n\\n      return target.call(ctx)\\n    }\\n  }\\n\\n  const toStringProxy = new Proxy(\\n    Function.prototype.toString,\\n    utils.stripProxyFromErrors(handler)\\n  )\\n  utils.replaceProperty(Function.prototype, 'toString', {\\n    value: toStringProxy\\n  })\\n}\",\"replaceWithProxy\":\"(obj, propName, handler) => {\\n  const originalObj = obj[propName]\\n  const proxyObj = new Proxy(obj[propName], utils.stripProxyFromErrors(handler))\\n\\n  utils.replaceProperty(obj, propName, { value: proxyObj })\\n  utils.redirectToString(proxyObj, originalObj)\\n\\n  return true\\n}\",\"replaceGetterWithProxy\":\"(obj, propName, handler) => {\\n  const fn = Object.getOwnPropertyDescriptor(obj, propName).get\\n  const fnStr = fn.toString() // special getter function string\\n  const proxyObj = new Proxy(fn, utils.stripProxyFromErrors(handler))\\n\\n  utils.replaceProperty(obj, propName, { get: proxyObj })\\n  utils.patchToString(proxyObj, fnStr)\\n\\n  return true\\n}\",\"replaceGetterSetter\":\"(obj, propName, handlerGetterSetter) => {\\n  const ownPropertyDescriptor = Object.getOwnPropertyDescriptor(obj, propName)\\n  const handler = { ...ownPropertyDescriptor }\\n\\n  if (handlerGetterSetter.get !== undefined) {\\n    const nativeFn = ownPropertyDescriptor.get\\n    handler.get = function() {\\n      return handlerGetterSetter.get.call(this, nativeFn.bind(this))\\n    }\\n    utils.redirectToString(handler.get, nativeFn)\\n  }\\n\\n  if (handlerGetterSetter.set !== undefined) {\\n    const nativeFn = ownPropertyDescriptor.set\\n    handler.set = function(newValue) {\\n      handlerGetterSetter.set.call(this, newValue, nativeFn.bind(this))\\n    }\\n    utils.redirectToString(handler.set, nativeFn)\\n  }\\n\\n  Object.defineProperty(obj, propName, handler)\\n}\",\"mockWithProxy\":\"(obj, propName, pseudoTarget, handler) => {\\n  const proxyObj = new Proxy(pseudoTarget, utils.stripProxyFromErrors(handler))\\n\\n  utils.replaceProperty(obj, propName, { value: proxyObj })\\n  utils.patchToString(proxyObj)\\n\\n  return true\\n}\",\"createProxy\":\"(pseudoTarget, handler) => {\\n  const proxyObj = new Proxy(pseudoTarget, utils.stripProxyFromErrors(handler))\\n  utils.patchToString(proxyObj)\\n\\n  return proxyObj\\n}\",\"splitObjPath\":\"objPath => ({\\n  // Remove last dot entry (property) ==> `HTMLMediaElement.prototype`\\n  objName: objPath.split('.').slice(0, -1).join('.'),\\n  // Extract last dot entry ==> `canPlayType`\\n  propName: objPath.split('.').slice(-1)[0]\\n})\",\"replaceObjPathWithProxy\":\"(objPath, handler) => {\\n  const { objName, propName } = utils.splitObjPath(objPath)\\n  const obj = eval(objName) // eslint-disable-line no-eval\\n  return utils.replaceWithProxy(obj, propName, handler)\\n}\",\"execRecursively\":\"(obj = {}, typeFilter = [], fn) => {\\n  function recurse(obj) {\\n    for (const key in obj) {\\n      if (obj[key] === undefined) {\\n        continue\\n      }\\n      if (obj[key] && typeof obj[key] === 'object') {\\n        recurse(obj[key])\\n      } else {\\n        if (obj[key] && typeFilter.includes(typeof obj[key])) {\\n          fn.call(this, obj[key])\\n        }\\n      }\\n    }\\n  }\\n  recurse(obj)\\n  return obj\\n}\",\"stringifyFns\":\"(fnObj = { hello: () => 'world' }) => {\\n  // Object.fromEntries() ponyfill (in 6 lines) - supported only in Node v12+, modern browsers are fine\\n  // https://github.com/feross/fromentries\\n  function fromEntries(iterable) {\\n    return [...iterable].reduce((obj, [key, val]) => {\\n      obj[key] = val\\n      return obj\\n    }, {})\\n  }\\n  return (Object.fromEntries || fromEntries)(\\n    Object.entries(fnObj)\\n      .filter(([key, value]) => typeof value === 'function')\\n      .map(([key, value]) => [key, value.toString()]) // eslint-disable-line no-eval\\n  )\\n}\",\"materializeFns\":\"(fnStrObj = { hello: \\\"() => 'world'\\\" }) => {\\n  return Object.fromEntries(\\n    Object.entries(fnStrObj).map(([key, value]) => {\\n      if (value.startsWith('function')) {\\n        // some trickery is needed to make oldschool functions work :-)\\n        return [key, eval(`() => ${value}`)()] // eslint-disable-line no-eval\\n      } else {\\n        // arrow functions just work\\n        return [key, eval(value)] // eslint-disable-line no-eval\\n      }\\n    })\\n  )\\n}\",\"makeHandler\":\"() => ({\\n  // Used by simple `navigator` getter evasions\\n  getterValue: value => ({\\n    apply(target, ctx, args) {\\n      // Let's fetch the value first, to trigger and escalate potential errors\\n      // Illegal invocations like `navigator.__proto__.vendor` will throw here\\n      utils.cache.Reflect.apply(...arguments)\\n      return value\\n    }\\n  })\\n})\",\"arrayEquals\":\"(array1, array2) => {\\n  if (array1.length !== array2.length) {\\n    return false\\n  }\\n  for (let i = 0; i < array1.length; ++i) {\\n    if (array1[i] !== array2[i]) {\\n      return false\\n    }\\n  }\\n  return true\\n}\",\"memoize\":\"fn => {\\n  const cache = []\\n  return function(...args) {\\n    if (!cache.some(c => utils.arrayEquals(c.key, args))) {\\n      cache.push({ key: args, value: fn.apply(this, args) })\\n    }\\n    return cache.find(c => utils.arrayEquals(c.key, args)).value\\n  }\\n}\"},\"_mainFunction\":\"(utils, { opts, STATIC_DATA }) => {\\n        if (!window.chrome) {\\n          // Use the exact property descriptor found in headful Chrome\\n          // fetch it via `Object.getOwnPropertyDescriptor(window, 'chrome')`\\n          Object.defineProperty(window, 'chrome', {\\n            writable: true,\\n            enumerable: true,\\n            configurable: false, // note!\\n            value: {} // We'll extend that later\\n          })\\n        }\\n\\n        // That means we're running headful and don't need to mock anything\\n        const existsAlready = 'runtime' in window.chrome\\n        // `chrome.runtime` is only exposed on secure origins\\n        const isNotSecure = !window.location.protocol.startsWith('https')\\n        if (existsAlready || (isNotSecure && !opts.runOnInsecureOrigins)) {\\n          return // Nothing to do here\\n        }\\n\\n        window.chrome.runtime = {\\n          // There's a bunch of static data in that property which doesn't seem to change,\\n          // we should periodically check for updates: `JSON.stringify(window.chrome.runtime, null, 2)`\\n          ...STATIC_DATA,\\n          // `chrome.runtime.id` is extension related and returns undefined in Chrome\\n          get id() {\\n            return undefined\\n          },\\n          // These two require more sophisticated mocks\\n          connect: null,\\n          sendMessage: null\\n        }\\n\\n        const makeCustomRuntimeErrors = (preamble, method, extensionId) => ({\\n          NoMatchingSignature: new TypeError(\\n            preamble + `No matching signature.`\\n          ),\\n          MustSpecifyExtensionID: new TypeError(\\n            preamble +\\n              `${method} called from a webpage must specify an Extension ID (string) for its first argument.`\\n          ),\\n          InvalidExtensionID: new TypeError(\\n            preamble + `Invalid extension id: '${extensionId}'`\\n          )\\n        })\\n\\n        // Valid Extension IDs are 32 characters in length and use the letter `a` to `p`:\\n        // https://source.chromium.org/chromium/chromium/src/+/master:components/crx_file/id_util.cc;drc=14a055ccb17e8c8d5d437fe080faba4c6f07beac;l=90\\n        const isValidExtensionID = str =>\\n          str.length === 32 && str.toLowerCase().match(/^[a-p]+$/)\\n\\n        /** Mock `chrome.runtime.sendMessage` */\\n        const sendMessageHandler = {\\n          apply: function(target, ctx, args) {\\n            const [extensionId, options, responseCallback] = args || []\\n\\n            // Define custom errors\\n            const errorPreamble = `Error in invocation of runtime.sendMessage(optional string extensionId, any message, optional object options, optional function responseCallback): `\\n            const Errors = makeCustomRuntimeErrors(\\n              errorPreamble,\\n              `chrome.runtime.sendMessage()`,\\n              extensionId\\n            )\\n\\n            // Check if the call signature looks ok\\n            const noArguments = args.length === 0\\n            const tooManyArguments = args.length > 4\\n            const incorrectOptions = options && typeof options !== 'object'\\n            const incorrectResponseCallback =\\n              responseCallback && typeof responseCallback !== 'function'\\n            if (\\n              noArguments ||\\n              tooManyArguments ||\\n              incorrectOptions ||\\n              incorrectResponseCallback\\n            ) {\\n              throw Errors.NoMatchingSignature\\n            }\\n\\n            // At least 2 arguments are required before we even validate the extension ID\\n            if (args.length < 2) {\\n              throw Errors.MustSpecifyExtensionID\\n            }\\n\\n            // Now let's make sure we got a string as extension ID\\n            if (typeof extensionId !== 'string') {\\n              throw Errors.NoMatchingSignature\\n            }\\n\\n            if (!isValidExtensionID(extensionId)) {\\n              throw Errors.InvalidExtensionID\\n            }\\n\\n            return undefined // Normal behavior\\n          }\\n        }\\n        utils.mockWithProxy(\\n          window.chrome.runtime,\\n          'sendMessage',\\n          function sendMessage() {},\\n          sendMessageHandler\\n        )\\n\\n        /**\\n         * Mock `chrome.runtime.connect`\\n         *\\n         * @see https://developer.chrome.com/apps/runtime#method-connect\\n         */\\n        const connectHandler = {\\n          apply: function(target, ctx, args) {\\n            const [extensionId, connectInfo] = args || []\\n\\n            // Define custom errors\\n            const errorPreamble = `Error in invocation of runtime.connect(optional string extensionId, optional object connectInfo): `\\n            const Errors = makeCustomRuntimeErrors(\\n              errorPreamble,\\n              `chrome.runtime.connect()`,\\n              extensionId\\n            )\\n\\n            // Behavior differs a bit from sendMessage:\\n            const noArguments = args.length === 0\\n            const emptyStringArgument = args.length === 1 && extensionId === ''\\n            if (noArguments || emptyStringArgument) {\\n              throw Errors.MustSpecifyExtensionID\\n            }\\n\\n            const tooManyArguments = args.length > 2\\n            const incorrectConnectInfoType =\\n              connectInfo && typeof connectInfo !== 'object'\\n\\n            if (tooManyArguments || incorrectConnectInfoType) {\\n              throw Errors.NoMatchingSignature\\n            }\\n\\n            const extensionIdIsString = typeof extensionId === 'string'\\n            if (extensionIdIsString && extensionId === '') {\\n              throw Errors.MustSpecifyExtensionID\\n            }\\n            if (extensionIdIsString && !isValidExtensionID(extensionId)) {\\n              throw Errors.InvalidExtensionID\\n            }\\n\\n            // There's another edge-case here: extensionId is optional so we might find a connectInfo object as first param, which we need to validate\\n            const validateConnectInfo = ci => {\\n              // More than a first param connectInfo as been provided\\n              if (args.length > 1) {\\n                throw Errors.NoMatchingSignature\\n              }\\n              // An empty connectInfo has been provided\\n              if (Object.keys(ci).length === 0) {\\n                throw Errors.MustSpecifyExtensionID\\n              }\\n              // Loop over all connectInfo props an check them\\n              Object.entries(ci).forEach(([k, v]) => {\\n                const isExpected = ['name', 'includeTlsChannelId'].includes(k)\\n                if (!isExpected) {\\n                  throw new TypeError(\\n                    errorPreamble + `Unexpected property: '${k}'.`\\n                  )\\n                }\\n                const MismatchError = (propName, expected, found) =>\\n                  TypeError(\\n                    errorPreamble +\\n                      `Error at property '${propName}': Invalid type: expected ${expected}, found ${found}.`\\n                  )\\n                if (k === 'name' && typeof v !== 'string') {\\n                  throw MismatchError(k, 'string', typeof v)\\n                }\\n                if (k === 'includeTlsChannelId' && typeof v !== 'boolean') {\\n                  throw MismatchError(k, 'boolean', typeof v)\\n                }\\n              })\\n            }\\n            if (typeof extensionId === 'object') {\\n              validateConnectInfo(extensionId)\\n              throw Errors.MustSpecifyExtensionID\\n            }\\n\\n            // Unfortunately even when the connect fails Chrome will return an object with methods we need to mock as well\\n            return utils.patchToStringNested(makeConnectResponse())\\n          }\\n        }\\n        utils.mockWithProxy(\\n          window.chrome.runtime,\\n          'connect',\\n          function connect() {},\\n          connectHandler\\n        )\\n\\n        function makeConnectResponse() {\\n          const onSomething = () => ({\\n            addListener: function addListener() {},\\n            dispatch: function dispatch() {},\\n            hasListener: function hasListener() {},\\n            hasListeners: function hasListeners() {\\n              return false\\n            },\\n            removeListener: function removeListener() {}\\n          })\\n\\n          const response = {\\n            name: '',\\n            sender: undefined,\\n            disconnect: function disconnect() {},\\n            onDisconnect: onSomething(),\\n            onMessage: onSomething(),\\n            postMessage: function postMessage() {\\n              if (!arguments.length) {\\n                throw new TypeError(`Insufficient number of arguments.`)\\n              }\\n              throw new Error(`Attempting to use a disconnected port object`)\\n            }\\n          }\\n          return response\\n        }\\n      }\",\"_args\":[{\"opts\":{\"runOnInsecureOrigins\":false},\"STATIC_DATA\":{\"OnInstalledReason\":{\"CHROME_UPDATE\":\"chrome_update\",\"INSTALL\":\"install\",\"SHARED_MODULE_UPDATE\":\"shared_module_update\",\"UPDATE\":\"update\"},\"OnRestartRequiredReason\":{\"APP_UPDATE\":\"app_update\",\"OS_UPDATE\":\"os_update\",\"PERIODIC\":\"periodic\"},\"PlatformArch\":{\"ARM\":\"arm\",\"ARM64\":\"arm64\",\"MIPS\":\"mips\",\"MIPS64\":\"mips64\",\"X86_32\":\"x86-32\",\"X86_64\":\"x86-64\"},\"PlatformNaclArch\":{\"ARM\":\"arm\",\"MIPS\":\"mips\",\"MIPS64\":\"mips64\",\"X86_32\":\"x86-32\",\"X86_64\":\"x86-64\"},\"PlatformOs\":{\"ANDROID\":\"android\",\"CROS\":\"cros\",\"LINUX\":\"linux\",\"MAC\":\"mac\",\"OPENBSD\":\"openbsd\",\"WIN\":\"win\"},\"RequestUpdateCheckStatus\":{\"NO_UPDATE\":\"no_update\",\"THROTTLED\":\"throttled\",\"UPDATE_AVAILABLE\":\"update_available\"}}}]})"},"stack":[{"file":"/home/neetoci/neeto-chat-web/playwright-tests/node_modules/@bigbinary/neeto-playwright-commons/node_modules/playwright-extra/dist/index.esm.js","line":230,"column":32,"function":"Proxy.<anonymous>"}]}
{"type":"before","callId":"pw:api@50","parentId":"hook@2","startTime":92241.652,"class":"Test","method":"step","apiName":"page.addInitScript","params":{"source":"(({ _utilsFns, _mainFunction, _args }) => {\n        // Add this point we cannot use our utililty functions as they're just strings, we need to materialize them first\n        const utils = Object.fromEntries(\n          Object.entries(_utilsFns).map(([key, value]) => [key, eval(value)]) // eslint-disable-line no-eval\n        )\n        utils.init()\n        return eval(_mainFunction)(utils, ..._args) // eslint-disable-line no-eval\n      })({\"_utilsFns\":{\"init\":\"() => {\\n  utils.preloadCache()\\n}\",\"stripProxyFromErrors\":\"(handler = {}) => {\\n  const newHandler = {\\n    setPrototypeOf: function (target, proto) {\\n      if (proto === null)\\n        throw new TypeError('Cannot convert object to primitive value')\\n      if (Object.getPrototypeOf(target) === Object.getPrototypeOf(proto)) {\\n        throw new TypeError('Cyclic __proto__ value')\\n      }\\n      return Reflect.setPrototypeOf(target, proto)\\n    }\\n  }\\n  // We wrap each trap in the handler in a try/catch and modify the error stack if they throw\\n  const traps = Object.getOwnPropertyNames(handler)\\n  traps.forEach(trap => {\\n    newHandler[trap] = function () {\\n      try {\\n        // Forward the call to the defined proxy handler\\n        return handler[trap].apply(this, arguments || [])\\n      } catch (err) {\\n        // Stack traces differ per browser, we only support chromium based ones currently\\n        if (!err || !err.stack || !err.stack.includes(`at `)) {\\n          throw err\\n        }\\n\\n        // When something throws within one of our traps the Proxy will show up in error stacks\\n        // An earlier implementation of this code would simply strip lines with a blacklist,\\n        // but it makes sense to be more surgical here and only remove lines related to our Proxy.\\n        // We try to use a known \\\"anchor\\\" line for that and strip it with everything above it.\\n        // If the anchor line cannot be found for some reason we fall back to our blacklist approach.\\n\\n        const stripWithBlacklist = (stack, stripFirstLine = true) => {\\n          const blacklist = [\\n            `at Reflect.${trap} `, // e.g. Reflect.get or Reflect.apply\\n            `at Object.${trap} `, // e.g. Object.get or Object.apply\\n            `at Object.newHandler.<computed> [as ${trap}] ` // caused by this very wrapper :-)\\n          ]\\n          return (\\n            err.stack\\n              .split('\\\\n')\\n              // Always remove the first (file) line in the stack (guaranteed to be our proxy)\\n              .filter((line, index) => !(index === 1 && stripFirstLine))\\n              // Check if the line starts with one of our blacklisted strings\\n              .filter(line => !blacklist.some(bl => line.trim().startsWith(bl)))\\n              .join('\\\\n')\\n          )\\n        }\\n\\n        const stripWithAnchor = (stack, anchor) => {\\n          const stackArr = stack.split('\\\\n')\\n          anchor = anchor || `at Object.newHandler.<computed> [as ${trap}] ` // Known first Proxy line in chromium\\n          const anchorIndex = stackArr.findIndex(line =>\\n            line.trim().startsWith(anchor)\\n          )\\n          if (anchorIndex === -1) {\\n            return false // 404, anchor not found\\n          }\\n          // Strip everything from the top until we reach the anchor line\\n          // Note: We're keeping the 1st line (zero index) as it's unrelated (e.g. `TypeError`)\\n          stackArr.splice(1, anchorIndex)\\n          return stackArr.join('\\\\n')\\n        }\\n\\n        // Special cases due to our nested toString proxies\\n        err.stack = err.stack.replace(\\n          'at Object.toString (',\\n          'at Function.toString ('\\n        )\\n        if ((err.stack || '').includes('at Function.toString (')) {\\n          err.stack = stripWithBlacklist(err.stack, false)\\n          throw err\\n        }\\n\\n        // Try using the anchor method, fallback to blacklist if necessary\\n        err.stack = stripWithAnchor(err.stack) || stripWithBlacklist(err.stack)\\n\\n        throw err // Re-throw our now sanitized error\\n      }\\n    }\\n  })\\n  return newHandler\\n}\",\"stripErrorWithAnchor\":\"(err, anchor) => {\\n  const stackArr = err.stack.split('\\\\n')\\n  const anchorIndex = stackArr.findIndex(line => line.trim().startsWith(anchor))\\n  if (anchorIndex === -1) {\\n    return err // 404, anchor not found\\n  }\\n  // Strip everything from the top until we reach the anchor line (remove anchor line as well)\\n  // Note: We're keeping the 1st line (zero index) as it's unrelated (e.g. `TypeError`)\\n  stackArr.splice(1, anchorIndex)\\n  err.stack = stackArr.join('\\\\n')\\n  return err\\n}\",\"replaceProperty\":\"(obj, propName, descriptorOverrides = {}) => {\\n  return Object.defineProperty(obj, propName, {\\n    // Copy over the existing descriptors (writable, enumerable, configurable, etc)\\n    ...(Object.getOwnPropertyDescriptor(obj, propName) || {}),\\n    // Add our overrides (e.g. value, get())\\n    ...descriptorOverrides\\n  })\\n}\",\"preloadCache\":\"() => {\\n  if (utils.cache) {\\n    return\\n  }\\n  utils.cache = {\\n    // Used in our proxies\\n    Reflect: {\\n      get: Reflect.get.bind(Reflect),\\n      apply: Reflect.apply.bind(Reflect)\\n    },\\n    // Used in `makeNativeString`\\n    nativeToStringStr: Function.toString + '' // => `function toString() { [native code] }`\\n  }\\n}\",\"makeNativeString\":\"(name = '') => {\\n  return utils.cache.nativeToStringStr.replace('toString', name || '')\\n}\",\"patchToString\":\"(obj, str = '') => {\\n  const handler = {\\n    apply: function (target, ctx) {\\n      // This fixes e.g. `HTMLMediaElement.prototype.canPlayType.toString + \\\"\\\"`\\n      if (ctx === Function.prototype.toString) {\\n        return utils.makeNativeString('toString')\\n      }\\n      // `toString` targeted at our proxied Object detected\\n      if (ctx === obj) {\\n        // We either return the optional string verbatim or derive the most desired result automatically\\n        return str || utils.makeNativeString(obj.name)\\n      }\\n      // Check if the toString protype of the context is the same as the global prototype,\\n      // if not indicates that we are doing a check across different windows., e.g. the iframeWithdirect` test case\\n      const hasSameProto = Object.getPrototypeOf(\\n        Function.prototype.toString\\n      ).isPrototypeOf(ctx.toString) // eslint-disable-line no-prototype-builtins\\n      if (!hasSameProto) {\\n        // Pass the call on to the local Function.prototype.toString instead\\n        return ctx.toString()\\n      }\\n      return target.call(ctx)\\n    }\\n  }\\n\\n  const toStringProxy = new Proxy(\\n    Function.prototype.toString,\\n    utils.stripProxyFromErrors(handler)\\n  )\\n  utils.replaceProperty(Function.prototype, 'toString', {\\n    value: toStringProxy\\n  })\\n}\",\"patchToStringNested\":\"(obj = {}) => {\\n  return utils.execRecursively(obj, ['function'], utils.patchToString)\\n}\",\"redirectToString\":\"(proxyObj, originalObj) => {\\n  const handler = {\\n    apply: function (target, ctx) {\\n      // This fixes e.g. `HTMLMediaElement.prototype.canPlayType.toString + \\\"\\\"`\\n      if (ctx === Function.prototype.toString) {\\n        return utils.makeNativeString('toString')\\n      }\\n\\n      // `toString` targeted at our proxied Object detected\\n      if (ctx === proxyObj) {\\n        const fallback = () =>\\n          originalObj && originalObj.name\\n            ? utils.makeNativeString(originalObj.name)\\n            : utils.makeNativeString(proxyObj.name)\\n\\n        // Return the toString representation of our original object if possible\\n        return originalObj + '' || fallback()\\n      }\\n\\n      if (typeof ctx === 'undefined' || ctx === null) {\\n        return target.call(ctx)\\n      }\\n\\n      // Check if the toString protype of the context is the same as the global prototype,\\n      // if not indicates that we are doing a check across different windows., e.g. the iframeWithdirect` test case\\n      const hasSameProto = Object.getPrototypeOf(\\n        Function.prototype.toString\\n      ).isPrototypeOf(ctx.toString) // eslint-disable-line no-prototype-builtins\\n      if (!hasSameProto) {\\n        // Pass the call on to the local Function.prototype.toString instead\\n        return ctx.toString()\\n      }\\n\\n      return target.call(ctx)\\n    }\\n  }\\n\\n  const toStringProxy = new Proxy(\\n    Function.prototype.toString,\\n    utils.stripProxyFromErrors(handler)\\n  )\\n  utils.replaceProperty(Function.prototype, 'toString', {\\n    value: toStringProxy\\n  })\\n}\",\"replaceWithProxy\":\"(obj, propName, handler) => {\\n  const originalObj = obj[propName]\\n  const proxyObj = new Proxy(obj[propName], utils.stripProxyFromErrors(handler))\\n\\n  utils.replaceProperty(obj, propName, { value: proxyObj })\\n  utils.redirectToString(proxyObj, originalObj)\\n\\n  return true\\n}\",\"replaceGetterWithProxy\":\"(obj, propName, handler) => {\\n  const fn = Object.getOwnPropertyDescriptor(obj, propName).get\\n  const fnStr = fn.toString() // special getter function string\\n  const proxyObj = new Proxy(fn, utils.stripProxyFromErrors(handler))\\n\\n  utils.replaceProperty(obj, propName, { get: proxyObj })\\n  utils.patchToString(proxyObj, fnStr)\\n\\n  return true\\n}\",\"replaceGetterSetter\":\"(obj, propName, handlerGetterSetter) => {\\n  const ownPropertyDescriptor = Object.getOwnPropertyDescriptor(obj, propName)\\n  const handler = { ...ownPropertyDescriptor }\\n\\n  if (handlerGetterSetter.get !== undefined) {\\n    const nativeFn = ownPropertyDescriptor.get\\n    handler.get = function() {\\n      return handlerGetterSetter.get.call(this, nativeFn.bind(this))\\n    }\\n    utils.redirectToString(handler.get, nativeFn)\\n  }\\n\\n  if (handlerGetterSetter.set !== undefined) {\\n    const nativeFn = ownPropertyDescriptor.set\\n    handler.set = function(newValue) {\\n      handlerGetterSetter.set.call(this, newValue, nativeFn.bind(this))\\n    }\\n    utils.redirectToString(handler.set, nativeFn)\\n  }\\n\\n  Object.defineProperty(obj, propName, handler)\\n}\",\"mockWithProxy\":\"(obj, propName, pseudoTarget, handler) => {\\n  const proxyObj = new Proxy(pseudoTarget, utils.stripProxyFromErrors(handler))\\n\\n  utils.replaceProperty(obj, propName, { value: proxyObj })\\n  utils.patchToString(proxyObj)\\n\\n  return true\\n}\",\"createProxy\":\"(pseudoTarget, handler) => {\\n  const proxyObj = new Proxy(pseudoTarget, utils.stripProxyFromErrors(handler))\\n  utils.patchToString(proxyObj)\\n\\n  return proxyObj\\n}\",\"splitObjPath\":\"objPath => ({\\n  // Remove last dot entry (property) ==> `HTMLMediaElement.prototype`\\n  objName: objPath.split('.').slice(0, -1).join('.'),\\n  // Extract last dot entry ==> `canPlayType`\\n  propName: objPath.split('.').slice(-1)[0]\\n})\",\"replaceObjPathWithProxy\":\"(objPath, handler) => {\\n  const { objName, propName } = utils.splitObjPath(objPath)\\n  const obj = eval(objName) // eslint-disable-line no-eval\\n  return utils.replaceWithProxy(obj, propName, handler)\\n}\",\"execRecursively\":\"(obj = {}, typeFilter = [], fn) => {\\n  function recurse(obj) {\\n    for (const key in obj) {\\n      if (obj[key] === undefined) {\\n        continue\\n      }\\n      if (obj[key] && typeof obj[key] === 'object') {\\n        recurse(obj[key])\\n      } else {\\n        if (obj[key] && typeFilter.includes(typeof obj[key])) {\\n          fn.call(this, obj[key])\\n        }\\n      }\\n    }\\n  }\\n  recurse(obj)\\n  return obj\\n}\",\"stringifyFns\":\"(fnObj = { hello: () => 'world' }) => {\\n  // Object.fromEntries() ponyfill (in 6 lines) - supported only in Node v12+, modern browsers are fine\\n  // https://github.com/feross/fromentries\\n  function fromEntries(iterable) {\\n    return [...iterable].reduce((obj, [key, val]) => {\\n      obj[key] = val\\n      return obj\\n    }, {})\\n  }\\n  return (Object.fromEntries || fromEntries)(\\n    Object.entries(fnObj)\\n      .filter(([key, value]) => typeof value === 'function')\\n      .map(([key, value]) => [key, value.toString()]) // eslint-disable-line no-eval\\n  )\\n}\",\"materializeFns\":\"(fnStrObj = { hello: \\\"() => 'world'\\\" }) => {\\n  return Object.fromEntries(\\n    Object.entries(fnStrObj).map(([key, value]) => {\\n      if (value.startsWith('function')) {\\n        // some trickery is needed to make oldschool functions work :-)\\n        return [key, eval(`() => ${value}`)()] // eslint-disable-line no-eval\\n      } else {\\n        // arrow functions just work\\n        return [key, eval(value)] // eslint-disable-line no-eval\\n      }\\n    })\\n  )\\n}\",\"makeHandler\":\"() => ({\\n  // Used by simple `navigator` getter evasions\\n  getterValue: value => ({\\n    apply(target, ctx, args) {\\n      // Let's fetch the value first, to trigger and escalate potential errors\\n      // Illegal invocations like `navigator.__proto__.vendor` will throw here\\n      utils.cache.Reflect.apply(...arguments)\\n      return value\\n    }\\n  })\\n})\",\"arrayEquals\":\"(array1, array2) => {\\n  if (array1.length !== array2.length) {\\n    return false\\n  }\\n  for (let i = 0; i < array1.length; ++i) {\\n    if (array1[i] !== array2[i]) {\\n      return false\\n    }\\n  }\\n  return true\\n}\",\"memoize\":\"fn => {\\n  const cache = []\\n  return function(...args) {\\n    if (!cache.some(c => utils.arrayEquals(c.key, args))) {\\n      cache.push({ key: args, value: fn.apply(this, args) })\\n    }\\n    return cache.find(c => utils.arrayEquals(c.key, args)).value\\n  }\\n}\"},\"_mainFunction\":\"utils => {\\n      /**\\n       * Input might look funky, we need to normalize it so e.g. whitespace isn't an issue for our spoofing.\\n       *\\n       * @example\\n       * video/webm; codecs=\\\"vp8, vorbis\\\"\\n       * video/mp4; codecs=\\\"avc1.42E01E\\\"\\n       * audio/x-m4a;\\n       * audio/ogg; codecs=\\\"vorbis\\\"\\n       * @param {String} arg\\n       */\\n      const parseInput = arg => {\\n        const [mime, codecStr] = arg.trim().split(';')\\n        let codecs = []\\n        if (codecStr && codecStr.includes('codecs=\\\"')) {\\n          codecs = codecStr\\n            .trim()\\n            .replace(`codecs=\\\"`, '')\\n            .replace(`\\\"`, '')\\n            .trim()\\n            .split(',')\\n            .filter(x => !!x)\\n            .map(x => x.trim())\\n        }\\n        return {\\n          mime,\\n          codecStr,\\n          codecs\\n        }\\n      }\\n\\n      const canPlayType = {\\n        // Intercept certain requests\\n        apply: function(target, ctx, args) {\\n          if (!args || !args.length) {\\n            return target.apply(ctx, args)\\n          }\\n          const { mime, codecs } = parseInput(args[0])\\n          // This specific mp4 codec is missing in Chromium\\n          if (mime === 'video/mp4') {\\n            if (codecs.includes('avc1.42E01E')) {\\n              return 'probably'\\n            }\\n          }\\n          // This mimetype is only supported if no codecs are specified\\n          if (mime === 'audio/x-m4a' && !codecs.length) {\\n            return 'maybe'\\n          }\\n\\n          // This mimetype is only supported if no codecs are specified\\n          if (mime === 'audio/aac' && !codecs.length) {\\n            return 'probably'\\n          }\\n          // Everything else as usual\\n          return target.apply(ctx, args)\\n        }\\n      }\\n\\n      /* global HTMLMediaElement */\\n      utils.replaceWithProxy(\\n        HTMLMediaElement.prototype,\\n        'canPlayType',\\n        canPlayType\\n      )\\n    }\",\"_args\":[]})"},"stack":[{"file":"/home/neetoci/neeto-chat-web/playwright-tests/node_modules/@bigbinary/neeto-playwright-commons/node_modules/playwright-extra/dist/index.esm.js","line":230,"column":32,"function":"Proxy.<anonymous>"}]}
{"type":"before","callId":"pw:api@51","parentId":"hook@2","startTime":92242.388,"class":"Test","method":"step","apiName":"page.addInitScript","params":{"source":"(({ _utilsFns, _mainFunction, _args }) => {\n        // Add this point we cannot use our utililty functions as they're just strings, we need to materialize them first\n        const utils = Object.fromEntries(\n          Object.entries(_utilsFns).map(([key, value]) => [key, eval(value)]) // eslint-disable-line no-eval\n        )\n        utils.init()\n        return eval(_mainFunction)(utils, ..._args) // eslint-disable-line no-eval\n      })({\"_utilsFns\":{\"init\":\"() => {\\n  utils.preloadCache()\\n}\",\"stripProxyFromErrors\":\"(handler = {}) => {\\n  const newHandler = {\\n    setPrototypeOf: function (target, proto) {\\n      if (proto === null)\\n        throw new TypeError('Cannot convert object to primitive value')\\n      if (Object.getPrototypeOf(target) === Object.getPrototypeOf(proto)) {\\n        throw new TypeError('Cyclic __proto__ value')\\n      }\\n      return Reflect.setPrototypeOf(target, proto)\\n    }\\n  }\\n  // We wrap each trap in the handler in a try/catch and modify the error stack if they throw\\n  const traps = Object.getOwnPropertyNames(handler)\\n  traps.forEach(trap => {\\n    newHandler[trap] = function () {\\n      try {\\n        // Forward the call to the defined proxy handler\\n        return handler[trap].apply(this, arguments || [])\\n      } catch (err) {\\n        // Stack traces differ per browser, we only support chromium based ones currently\\n        if (!err || !err.stack || !err.stack.includes(`at `)) {\\n          throw err\\n        }\\n\\n        // When something throws within one of our traps the Proxy will show up in error stacks\\n        // An earlier implementation of this code would simply strip lines with a blacklist,\\n        // but it makes sense to be more surgical here and only remove lines related to our Proxy.\\n        // We try to use a known \\\"anchor\\\" line for that and strip it with everything above it.\\n        // If the anchor line cannot be found for some reason we fall back to our blacklist approach.\\n\\n        const stripWithBlacklist = (stack, stripFirstLine = true) => {\\n          const blacklist = [\\n            `at Reflect.${trap} `, // e.g. Reflect.get or Reflect.apply\\n            `at Object.${trap} `, // e.g. Object.get or Object.apply\\n            `at Object.newHandler.<computed> [as ${trap}] ` // caused by this very wrapper :-)\\n          ]\\n          return (\\n            err.stack\\n              .split('\\\\n')\\n              // Always remove the first (file) line in the stack (guaranteed to be our proxy)\\n              .filter((line, index) => !(index === 1 && stripFirstLine))\\n              // Check if the line starts with one of our blacklisted strings\\n              .filter(line => !blacklist.some(bl => line.trim().startsWith(bl)))\\n              .join('\\\\n')\\n          )\\n        }\\n\\n        const stripWithAnchor = (stack, anchor) => {\\n          const stackArr = stack.split('\\\\n')\\n          anchor = anchor || `at Object.newHandler.<computed> [as ${trap}] ` // Known first Proxy line in chromium\\n          const anchorIndex = stackArr.findIndex(line =>\\n            line.trim().startsWith(anchor)\\n          )\\n          if (anchorIndex === -1) {\\n            return false // 404, anchor not found\\n          }\\n          // Strip everything from the top until we reach the anchor line\\n          // Note: We're keeping the 1st line (zero index) as it's unrelated (e.g. `TypeError`)\\n          stackArr.splice(1, anchorIndex)\\n          return stackArr.join('\\\\n')\\n        }\\n\\n        // Special cases due to our nested toString proxies\\n        err.stack = err.stack.replace(\\n          'at Object.toString (',\\n          'at Function.toString ('\\n        )\\n        if ((err.stack || '').includes('at Function.toString (')) {\\n          err.stack = stripWithBlacklist(err.stack, false)\\n          throw err\\n        }\\n\\n        // Try using the anchor method, fallback to blacklist if necessary\\n        err.stack = stripWithAnchor(err.stack) || stripWithBlacklist(err.stack)\\n\\n        throw err // Re-throw our now sanitized error\\n      }\\n    }\\n  })\\n  return newHandler\\n}\",\"stripErrorWithAnchor\":\"(err, anchor) => {\\n  const stackArr = err.stack.split('\\\\n')\\n  const anchorIndex = stackArr.findIndex(line => line.trim().startsWith(anchor))\\n  if (anchorIndex === -1) {\\n    return err // 404, anchor not found\\n  }\\n  // Strip everything from the top until we reach the anchor line (remove anchor line as well)\\n  // Note: We're keeping the 1st line (zero index) as it's unrelated (e.g. `TypeError`)\\n  stackArr.splice(1, anchorIndex)\\n  err.stack = stackArr.join('\\\\n')\\n  return err\\n}\",\"replaceProperty\":\"(obj, propName, descriptorOverrides = {}) => {\\n  return Object.defineProperty(obj, propName, {\\n    // Copy over the existing descriptors (writable, enumerable, configurable, etc)\\n    ...(Object.getOwnPropertyDescriptor(obj, propName) || {}),\\n    // Add our overrides (e.g. value, get())\\n    ...descriptorOverrides\\n  })\\n}\",\"preloadCache\":\"() => {\\n  if (utils.cache) {\\n    return\\n  }\\n  utils.cache = {\\n    // Used in our proxies\\n    Reflect: {\\n      get: Reflect.get.bind(Reflect),\\n      apply: Reflect.apply.bind(Reflect)\\n    },\\n    // Used in `makeNativeString`\\n    nativeToStringStr: Function.toString + '' // => `function toString() { [native code] }`\\n  }\\n}\",\"makeNativeString\":\"(name = '') => {\\n  return utils.cache.nativeToStringStr.replace('toString', name || '')\\n}\",\"patchToString\":\"(obj, str = '') => {\\n  const handler = {\\n    apply: function (target, ctx) {\\n      // This fixes e.g. `HTMLMediaElement.prototype.canPlayType.toString + \\\"\\\"`\\n      if (ctx === Function.prototype.toString) {\\n        return utils.makeNativeString('toString')\\n      }\\n      // `toString` targeted at our proxied Object detected\\n      if (ctx === obj) {\\n        // We either return the optional string verbatim or derive the most desired result automatically\\n        return str || utils.makeNativeString(obj.name)\\n      }\\n      // Check if the toString protype of the context is the same as the global prototype,\\n      // if not indicates that we are doing a check across different windows., e.g. the iframeWithdirect` test case\\n      const hasSameProto = Object.getPrototypeOf(\\n        Function.prototype.toString\\n      ).isPrototypeOf(ctx.toString) // eslint-disable-line no-prototype-builtins\\n      if (!hasSameProto) {\\n        // Pass the call on to the local Function.prototype.toString instead\\n        return ctx.toString()\\n      }\\n      return target.call(ctx)\\n    }\\n  }\\n\\n  const toStringProxy = new Proxy(\\n    Function.prototype.toString,\\n    utils.stripProxyFromErrors(handler)\\n  )\\n  utils.replaceProperty(Function.prototype, 'toString', {\\n    value: toStringProxy\\n  })\\n}\",\"patchToStringNested\":\"(obj = {}) => {\\n  return utils.execRecursively(obj, ['function'], utils.patchToString)\\n}\",\"redirectToString\":\"(proxyObj, originalObj) => {\\n  const handler = {\\n    apply: function (target, ctx) {\\n      // This fixes e.g. `HTMLMediaElement.prototype.canPlayType.toString + \\\"\\\"`\\n      if (ctx === Function.prototype.toString) {\\n        return utils.makeNativeString('toString')\\n      }\\n\\n      // `toString` targeted at our proxied Object detected\\n      if (ctx === proxyObj) {\\n        const fallback = () =>\\n          originalObj && originalObj.name\\n            ? utils.makeNativeString(originalObj.name)\\n            : utils.makeNativeString(proxyObj.name)\\n\\n        // Return the toString representation of our original object if possible\\n        return originalObj + '' || fallback()\\n      }\\n\\n      if (typeof ctx === 'undefined' || ctx === null) {\\n        return target.call(ctx)\\n      }\\n\\n      // Check if the toString protype of the context is the same as the global prototype,\\n      // if not indicates that we are doing a check across different windows., e.g. the iframeWithdirect` test case\\n      const hasSameProto = Object.getPrototypeOf(\\n        Function.prototype.toString\\n      ).isPrototypeOf(ctx.toString) // eslint-disable-line no-prototype-builtins\\n      if (!hasSameProto) {\\n        // Pass the call on to the local Function.prototype.toString instead\\n        return ctx.toString()\\n      }\\n\\n      return target.call(ctx)\\n    }\\n  }\\n\\n  const toStringProxy = new Proxy(\\n    Function.prototype.toString,\\n    utils.stripProxyFromErrors(handler)\\n  )\\n  utils.replaceProperty(Function.prototype, 'toString', {\\n    value: toStringProxy\\n  })\\n}\",\"replaceWithProxy\":\"(obj, propName, handler) => {\\n  const originalObj = obj[propName]\\n  const proxyObj = new Proxy(obj[propName], utils.stripProxyFromErrors(handler))\\n\\n  utils.replaceProperty(obj, propName, { value: proxyObj })\\n  utils.redirectToString(proxyObj, originalObj)\\n\\n  return true\\n}\",\"replaceGetterWithProxy\":\"(obj, propName, handler) => {\\n  const fn = Object.getOwnPropertyDescriptor(obj, propName).get\\n  const fnStr = fn.toString() // special getter function string\\n  const proxyObj = new Proxy(fn, utils.stripProxyFromErrors(handler))\\n\\n  utils.replaceProperty(obj, propName, { get: proxyObj })\\n  utils.patchToString(proxyObj, fnStr)\\n\\n  return true\\n}\",\"replaceGetterSetter\":\"(obj, propName, handlerGetterSetter) => {\\n  const ownPropertyDescriptor = Object.getOwnPropertyDescriptor(obj, propName)\\n  const handler = { ...ownPropertyDescriptor }\\n\\n  if (handlerGetterSetter.get !== undefined) {\\n    const nativeFn = ownPropertyDescriptor.get\\n    handler.get = function() {\\n      return handlerGetterSetter.get.call(this, nativeFn.bind(this))\\n    }\\n    utils.redirectToString(handler.get, nativeFn)\\n  }\\n\\n  if (handlerGetterSetter.set !== undefined) {\\n    const nativeFn = ownPropertyDescriptor.set\\n    handler.set = function(newValue) {\\n      handlerGetterSetter.set.call(this, newValue, nativeFn.bind(this))\\n    }\\n    utils.redirectToString(handler.set, nativeFn)\\n  }\\n\\n  Object.defineProperty(obj, propName, handler)\\n}\",\"mockWithProxy\":\"(obj, propName, pseudoTarget, handler) => {\\n  const proxyObj = new Proxy(pseudoTarget, utils.stripProxyFromErrors(handler))\\n\\n  utils.replaceProperty(obj, propName, { value: proxyObj })\\n  utils.patchToString(proxyObj)\\n\\n  return true\\n}\",\"createProxy\":\"(pseudoTarget, handler) => {\\n  const proxyObj = new Proxy(pseudoTarget, utils.stripProxyFromErrors(handler))\\n  utils.patchToString(proxyObj)\\n\\n  return proxyObj\\n}\",\"splitObjPath\":\"objPath => ({\\n  // Remove last dot entry (property) ==> `HTMLMediaElement.prototype`\\n  objName: objPath.split('.').slice(0, -1).join('.'),\\n  // Extract last dot entry ==> `canPlayType`\\n  propName: objPath.split('.').slice(-1)[0]\\n})\",\"replaceObjPathWithProxy\":\"(objPath, handler) => {\\n  const { objName, propName } = utils.splitObjPath(objPath)\\n  const obj = eval(objName) // eslint-disable-line no-eval\\n  return utils.replaceWithProxy(obj, propName, handler)\\n}\",\"execRecursively\":\"(obj = {}, typeFilter = [], fn) => {\\n  function recurse(obj) {\\n    for (const key in obj) {\\n      if (obj[key] === undefined) {\\n        continue\\n      }\\n      if (obj[key] && typeof obj[key] === 'object') {\\n        recurse(obj[key])\\n      } else {\\n        if (obj[key] && typeFilter.includes(typeof obj[key])) {\\n          fn.call(this, obj[key])\\n        }\\n      }\\n    }\\n  }\\n  recurse(obj)\\n  return obj\\n}\",\"stringifyFns\":\"(fnObj = { hello: () => 'world' }) => {\\n  // Object.fromEntries() ponyfill (in 6 lines) - supported only in Node v12+, modern browsers are fine\\n  // https://github.com/feross/fromentries\\n  function fromEntries(iterable) {\\n    return [...iterable].reduce((obj, [key, val]) => {\\n      obj[key] = val\\n      return obj\\n    }, {})\\n  }\\n  return (Object.fromEntries || fromEntries)(\\n    Object.entries(fnObj)\\n      .filter(([key, value]) => typeof value === 'function')\\n      .map(([key, value]) => [key, value.toString()]) // eslint-disable-line no-eval\\n  )\\n}\",\"materializeFns\":\"(fnStrObj = { hello: \\\"() => 'world'\\\" }) => {\\n  return Object.fromEntries(\\n    Object.entries(fnStrObj).map(([key, value]) => {\\n      if (value.startsWith('function')) {\\n        // some trickery is needed to make oldschool functions work :-)\\n        return [key, eval(`() => ${value}`)()] // eslint-disable-line no-eval\\n      } else {\\n        // arrow functions just work\\n        return [key, eval(value)] // eslint-disable-line no-eval\\n      }\\n    })\\n  )\\n}\",\"makeHandler\":\"() => ({\\n  // Used by simple `navigator` getter evasions\\n  getterValue: value => ({\\n    apply(target, ctx, args) {\\n      // Let's fetch the value first, to trigger and escalate potential errors\\n      // Illegal invocations like `navigator.__proto__.vendor` will throw here\\n      utils.cache.Reflect.apply(...arguments)\\n      return value\\n    }\\n  })\\n})\",\"arrayEquals\":\"(array1, array2) => {\\n  if (array1.length !== array2.length) {\\n    return false\\n  }\\n  for (let i = 0; i < array1.length; ++i) {\\n    if (array1[i] !== array2[i]) {\\n      return false\\n    }\\n  }\\n  return true\\n}\",\"memoize\":\"fn => {\\n  const cache = []\\n  return function(...args) {\\n    if (!cache.some(c => utils.arrayEquals(c.key, args))) {\\n      cache.push({ key: args, value: fn.apply(this, args) })\\n    }\\n    return cache.find(c => utils.arrayEquals(c.key, args)).value\\n  }\\n}\"},\"_mainFunction\":\"(utils, { opts }) => {\\n        utils.replaceGetterWithProxy(\\n          Object.getPrototypeOf(navigator),\\n          'hardwareConcurrency',\\n          utils.makeHandler().getterValue(opts.hardwareConcurrency)\\n        )\\n      }\",\"_args\":[{\"opts\":{\"hardwareConcurrency\":4}}]})"},"stack":[{"file":"/home/neetoci/neeto-chat-web/playwright-tests/node_modules/@bigbinary/neeto-playwright-commons/node_modules/playwright-extra/dist/index.esm.js","line":230,"column":32,"function":"Proxy.<anonymous>"}]}
{"type":"before","callId":"pw:api@52","parentId":"hook@2","startTime":92243.177,"class":"Test","method":"step","apiName":"page.addInitScript","params":{"source":"(({ _utilsFns, _mainFunction, _args }) => {\n        // Add this point we cannot use our utililty functions as they're just strings, we need to materialize them first\n        const utils = Object.fromEntries(\n          Object.entries(_utilsFns).map(([key, value]) => [key, eval(value)]) // eslint-disable-line no-eval\n        )\n        utils.init()\n        return eval(_mainFunction)(utils, ..._args) // eslint-disable-line no-eval\n      })({\"_utilsFns\":{\"init\":\"() => {\\n  utils.preloadCache()\\n}\",\"stripProxyFromErrors\":\"(handler = {}) => {\\n  const newHandler = {\\n    setPrototypeOf: function (target, proto) {\\n      if (proto === null)\\n        throw new TypeError('Cannot convert object to primitive value')\\n      if (Object.getPrototypeOf(target) === Object.getPrototypeOf(proto)) {\\n        throw new TypeError('Cyclic __proto__ value')\\n      }\\n      return Reflect.setPrototypeOf(target, proto)\\n    }\\n  }\\n  // We wrap each trap in the handler in a try/catch and modify the error stack if they throw\\n  const traps = Object.getOwnPropertyNames(handler)\\n  traps.forEach(trap => {\\n    newHandler[trap] = function () {\\n      try {\\n        // Forward the call to the defined proxy handler\\n        return handler[trap].apply(this, arguments || [])\\n      } catch (err) {\\n        // Stack traces differ per browser, we only support chromium based ones currently\\n        if (!err || !err.stack || !err.stack.includes(`at `)) {\\n          throw err\\n        }\\n\\n        // When something throws within one of our traps the Proxy will show up in error stacks\\n        // An earlier implementation of this code would simply strip lines with a blacklist,\\n        // but it makes sense to be more surgical here and only remove lines related to our Proxy.\\n        // We try to use a known \\\"anchor\\\" line for that and strip it with everything above it.\\n        // If the anchor line cannot be found for some reason we fall back to our blacklist approach.\\n\\n        const stripWithBlacklist = (stack, stripFirstLine = true) => {\\n          const blacklist = [\\n            `at Reflect.${trap} `, // e.g. Reflect.get or Reflect.apply\\n            `at Object.${trap} `, // e.g. Object.get or Object.apply\\n            `at Object.newHandler.<computed> [as ${trap}] ` // caused by this very wrapper :-)\\n          ]\\n          return (\\n            err.stack\\n              .split('\\\\n')\\n              // Always remove the first (file) line in the stack (guaranteed to be our proxy)\\n              .filter((line, index) => !(index === 1 && stripFirstLine))\\n              // Check if the line starts with one of our blacklisted strings\\n              .filter(line => !blacklist.some(bl => line.trim().startsWith(bl)))\\n              .join('\\\\n')\\n          )\\n        }\\n\\n        const stripWithAnchor = (stack, anchor) => {\\n          const stackArr = stack.split('\\\\n')\\n          anchor = anchor || `at Object.newHandler.<computed> [as ${trap}] ` // Known first Proxy line in chromium\\n          const anchorIndex = stackArr.findIndex(line =>\\n            line.trim().startsWith(anchor)\\n          )\\n          if (anchorIndex === -1) {\\n            return false // 404, anchor not found\\n          }\\n          // Strip everything from the top until we reach the anchor line\\n          // Note: We're keeping the 1st line (zero index) as it's unrelated (e.g. `TypeError`)\\n          stackArr.splice(1, anchorIndex)\\n          return stackArr.join('\\\\n')\\n        }\\n\\n        // Special cases due to our nested toString proxies\\n        err.stack = err.stack.replace(\\n          'at Object.toString (',\\n          'at Function.toString ('\\n        )\\n        if ((err.stack || '').includes('at Function.toString (')) {\\n          err.stack = stripWithBlacklist(err.stack, false)\\n          throw err\\n        }\\n\\n        // Try using the anchor method, fallback to blacklist if necessary\\n        err.stack = stripWithAnchor(err.stack) || stripWithBlacklist(err.stack)\\n\\n        throw err // Re-throw our now sanitized error\\n      }\\n    }\\n  })\\n  return newHandler\\n}\",\"stripErrorWithAnchor\":\"(err, anchor) => {\\n  const stackArr = err.stack.split('\\\\n')\\n  const anchorIndex = stackArr.findIndex(line => line.trim().startsWith(anchor))\\n  if (anchorIndex === -1) {\\n    return err // 404, anchor not found\\n  }\\n  // Strip everything from the top until we reach the anchor line (remove anchor line as well)\\n  // Note: We're keeping the 1st line (zero index) as it's unrelated (e.g. `TypeError`)\\n  stackArr.splice(1, anchorIndex)\\n  err.stack = stackArr.join('\\\\n')\\n  return err\\n}\",\"replaceProperty\":\"(obj, propName, descriptorOverrides = {}) => {\\n  return Object.defineProperty(obj, propName, {\\n    // Copy over the existing descriptors (writable, enumerable, configurable, etc)\\n    ...(Object.getOwnPropertyDescriptor(obj, propName) || {}),\\n    // Add our overrides (e.g. value, get())\\n    ...descriptorOverrides\\n  })\\n}\",\"preloadCache\":\"() => {\\n  if (utils.cache) {\\n    return\\n  }\\n  utils.cache = {\\n    // Used in our proxies\\n    Reflect: {\\n      get: Reflect.get.bind(Reflect),\\n      apply: Reflect.apply.bind(Reflect)\\n    },\\n    // Used in `makeNativeString`\\n    nativeToStringStr: Function.toString + '' // => `function toString() { [native code] }`\\n  }\\n}\",\"makeNativeString\":\"(name = '') => {\\n  return utils.cache.nativeToStringStr.replace('toString', name || '')\\n}\",\"patchToString\":\"(obj, str = '') => {\\n  const handler = {\\n    apply: function (target, ctx) {\\n      // This fixes e.g. `HTMLMediaElement.prototype.canPlayType.toString + \\\"\\\"`\\n      if (ctx === Function.prototype.toString) {\\n        return utils.makeNativeString('toString')\\n      }\\n      // `toString` targeted at our proxied Object detected\\n      if (ctx === obj) {\\n        // We either return the optional string verbatim or derive the most desired result automatically\\n        return str || utils.makeNativeString(obj.name)\\n      }\\n      // Check if the toString protype of the context is the same as the global prototype,\\n      // if not indicates that we are doing a check across different windows., e.g. the iframeWithdirect` test case\\n      const hasSameProto = Object.getPrototypeOf(\\n        Function.prototype.toString\\n      ).isPrototypeOf(ctx.toString) // eslint-disable-line no-prototype-builtins\\n      if (!hasSameProto) {\\n        // Pass the call on to the local Function.prototype.toString instead\\n        return ctx.toString()\\n      }\\n      return target.call(ctx)\\n    }\\n  }\\n\\n  const toStringProxy = new Proxy(\\n    Function.prototype.toString,\\n    utils.stripProxyFromErrors(handler)\\n  )\\n  utils.replaceProperty(Function.prototype, 'toString', {\\n    value: toStringProxy\\n  })\\n}\",\"patchToStringNested\":\"(obj = {}) => {\\n  return utils.execRecursively(obj, ['function'], utils.patchToString)\\n}\",\"redirectToString\":\"(proxyObj, originalObj) => {\\n  const handler = {\\n    apply: function (target, ctx) {\\n      // This fixes e.g. `HTMLMediaElement.prototype.canPlayType.toString + \\\"\\\"`\\n      if (ctx === Function.prototype.toString) {\\n        return utils.makeNativeString('toString')\\n      }\\n\\n      // `toString` targeted at our proxied Object detected\\n      if (ctx === proxyObj) {\\n        const fallback = () =>\\n          originalObj && originalObj.name\\n            ? utils.makeNativeString(originalObj.name)\\n            : utils.makeNativeString(proxyObj.name)\\n\\n        // Return the toString representation of our original object if possible\\n        return originalObj + '' || fallback()\\n      }\\n\\n      if (typeof ctx === 'undefined' || ctx === null) {\\n        return target.call(ctx)\\n      }\\n\\n      // Check if the toString protype of the context is the same as the global prototype,\\n      // if not indicates that we are doing a check across different windows., e.g. the iframeWithdirect` test case\\n      const hasSameProto = Object.getPrototypeOf(\\n        Function.prototype.toString\\n      ).isPrototypeOf(ctx.toString) // eslint-disable-line no-prototype-builtins\\n      if (!hasSameProto) {\\n        // Pass the call on to the local Function.prototype.toString instead\\n        return ctx.toString()\\n      }\\n\\n      return target.call(ctx)\\n    }\\n  }\\n\\n  const toStringProxy = new Proxy(\\n    Function.prototype.toString,\\n    utils.stripProxyFromErrors(handler)\\n  )\\n  utils.replaceProperty(Function.prototype, 'toString', {\\n    value: toStringProxy\\n  })\\n}\",\"replaceWithProxy\":\"(obj, propName, handler) => {\\n  const originalObj = obj[propName]\\n  const proxyObj = new Proxy(obj[propName], utils.stripProxyFromErrors(handler))\\n\\n  utils.replaceProperty(obj, propName, { value: proxyObj })\\n  utils.redirectToString(proxyObj, originalObj)\\n\\n  return true\\n}\",\"replaceGetterWithProxy\":\"(obj, propName, handler) => {\\n  const fn = Object.getOwnPropertyDescriptor(obj, propName).get\\n  const fnStr = fn.toString() // special getter function string\\n  const proxyObj = new Proxy(fn, utils.stripProxyFromErrors(handler))\\n\\n  utils.replaceProperty(obj, propName, { get: proxyObj })\\n  utils.patchToString(proxyObj, fnStr)\\n\\n  return true\\n}\",\"replaceGetterSetter\":\"(obj, propName, handlerGetterSetter) => {\\n  const ownPropertyDescriptor = Object.getOwnPropertyDescriptor(obj, propName)\\n  const handler = { ...ownPropertyDescriptor }\\n\\n  if (handlerGetterSetter.get !== undefined) {\\n    const nativeFn = ownPropertyDescriptor.get\\n    handler.get = function() {\\n      return handlerGetterSetter.get.call(this, nativeFn.bind(this))\\n    }\\n    utils.redirectToString(handler.get, nativeFn)\\n  }\\n\\n  if (handlerGetterSetter.set !== undefined) {\\n    const nativeFn = ownPropertyDescriptor.set\\n    handler.set = function(newValue) {\\n      handlerGetterSetter.set.call(this, newValue, nativeFn.bind(this))\\n    }\\n    utils.redirectToString(handler.set, nativeFn)\\n  }\\n\\n  Object.defineProperty(obj, propName, handler)\\n}\",\"mockWithProxy\":\"(obj, propName, pseudoTarget, handler) => {\\n  const proxyObj = new Proxy(pseudoTarget, utils.stripProxyFromErrors(handler))\\n\\n  utils.replaceProperty(obj, propName, { value: proxyObj })\\n  utils.patchToString(proxyObj)\\n\\n  return true\\n}\",\"createProxy\":\"(pseudoTarget, handler) => {\\n  const proxyObj = new Proxy(pseudoTarget, utils.stripProxyFromErrors(handler))\\n  utils.patchToString(proxyObj)\\n\\n  return proxyObj\\n}\",\"splitObjPath\":\"objPath => ({\\n  // Remove last dot entry (property) ==> `HTMLMediaElement.prototype`\\n  objName: objPath.split('.').slice(0, -1).join('.'),\\n  // Extract last dot entry ==> `canPlayType`\\n  propName: objPath.split('.').slice(-1)[0]\\n})\",\"replaceObjPathWithProxy\":\"(objPath, handler) => {\\n  const { objName, propName } = utils.splitObjPath(objPath)\\n  const obj = eval(objName) // eslint-disable-line no-eval\\n  return utils.replaceWithProxy(obj, propName, handler)\\n}\",\"execRecursively\":\"(obj = {}, typeFilter = [], fn) => {\\n  function recurse(obj) {\\n    for (const key in obj) {\\n      if (obj[key] === undefined) {\\n        continue\\n      }\\n      if (obj[key] && typeof obj[key] === 'object') {\\n        recurse(obj[key])\\n      } else {\\n        if (obj[key] && typeFilter.includes(typeof obj[key])) {\\n          fn.call(this, obj[key])\\n        }\\n      }\\n    }\\n  }\\n  recurse(obj)\\n  return obj\\n}\",\"stringifyFns\":\"(fnObj = { hello: () => 'world' }) => {\\n  // Object.fromEntries() ponyfill (in 6 lines) - supported only in Node v12+, modern browsers are fine\\n  // https://github.com/feross/fromentries\\n  function fromEntries(iterable) {\\n    return [...iterable].reduce((obj, [key, val]) => {\\n      obj[key] = val\\n      return obj\\n    }, {})\\n  }\\n  return (Object.fromEntries || fromEntries)(\\n    Object.entries(fnObj)\\n      .filter(([key, value]) => typeof value === 'function')\\n      .map(([key, value]) => [key, value.toString()]) // eslint-disable-line no-eval\\n  )\\n}\",\"materializeFns\":\"(fnStrObj = { hello: \\\"() => 'world'\\\" }) => {\\n  return Object.fromEntries(\\n    Object.entries(fnStrObj).map(([key, value]) => {\\n      if (value.startsWith('function')) {\\n        // some trickery is needed to make oldschool functions work :-)\\n        return [key, eval(`() => ${value}`)()] // eslint-disable-line no-eval\\n      } else {\\n        // arrow functions just work\\n        return [key, eval(value)] // eslint-disable-line no-eval\\n      }\\n    })\\n  )\\n}\",\"makeHandler\":\"() => ({\\n  // Used by simple `navigator` getter evasions\\n  getterValue: value => ({\\n    apply(target, ctx, args) {\\n      // Let's fetch the value first, to trigger and escalate potential errors\\n      // Illegal invocations like `navigator.__proto__.vendor` will throw here\\n      utils.cache.Reflect.apply(...arguments)\\n      return value\\n    }\\n  })\\n})\",\"arrayEquals\":\"(array1, array2) => {\\n  if (array1.length !== array2.length) {\\n    return false\\n  }\\n  for (let i = 0; i < array1.length; ++i) {\\n    if (array1[i] !== array2[i]) {\\n      return false\\n    }\\n  }\\n  return true\\n}\",\"memoize\":\"fn => {\\n  const cache = []\\n  return function(...args) {\\n    if (!cache.some(c => utils.arrayEquals(c.key, args))) {\\n      cache.push({ key: args, value: fn.apply(this, args) })\\n    }\\n    return cache.find(c => utils.arrayEquals(c.key, args)).value\\n  }\\n}\"},\"_mainFunction\":\"(utils, { opts }) => {\\n        const languages = opts.languages.length\\n          ? opts.languages\\n          : ['en-US', 'en']\\n        utils.replaceGetterWithProxy(\\n          Object.getPrototypeOf(navigator),\\n          'languages',\\n          utils.makeHandler().getterValue(Object.freeze([...languages]))\\n        )\\n      }\",\"_args\":[{\"opts\":{\"languages\":[]}}]})"},"stack":[{"file":"/home/neetoci/neeto-chat-web/playwright-tests/node_modules/@bigbinary/neeto-playwright-commons/node_modules/playwright-extra/dist/index.esm.js","line":230,"column":32,"function":"Proxy.<anonymous>"}]}
{"type":"before","callId":"pw:api@53","parentId":"hook@2","startTime":92243.93,"class":"Test","method":"step","apiName":"page.addInitScript","params":{"source":"(({ _utilsFns, _mainFunction, _args }) => {\n        // Add this point we cannot use our utililty functions as they're just strings, we need to materialize them first\n        const utils = Object.fromEntries(\n          Object.entries(_utilsFns).map(([key, value]) => [key, eval(value)]) // eslint-disable-line no-eval\n        )\n        utils.init()\n        return eval(_mainFunction)(utils, ..._args) // eslint-disable-line no-eval\n      })({\"_utilsFns\":{\"init\":\"() => {\\n  utils.preloadCache()\\n}\",\"stripProxyFromErrors\":\"(handler = {}) => {\\n  const newHandler = {\\n    setPrototypeOf: function (target, proto) {\\n      if (proto === null)\\n        throw new TypeError('Cannot convert object to primitive value')\\n      if (Object.getPrototypeOf(target) === Object.getPrototypeOf(proto)) {\\n        throw new TypeError('Cyclic __proto__ value')\\n      }\\n      return Reflect.setPrototypeOf(target, proto)\\n    }\\n  }\\n  // We wrap each trap in the handler in a try/catch and modify the error stack if they throw\\n  const traps = Object.getOwnPropertyNames(handler)\\n  traps.forEach(trap => {\\n    newHandler[trap] = function () {\\n      try {\\n        // Forward the call to the defined proxy handler\\n        return handler[trap].apply(this, arguments || [])\\n      } catch (err) {\\n        // Stack traces differ per browser, we only support chromium based ones currently\\n        if (!err || !err.stack || !err.stack.includes(`at `)) {\\n          throw err\\n        }\\n\\n        // When something throws within one of our traps the Proxy will show up in error stacks\\n        // An earlier implementation of this code would simply strip lines with a blacklist,\\n        // but it makes sense to be more surgical here and only remove lines related to our Proxy.\\n        // We try to use a known \\\"anchor\\\" line for that and strip it with everything above it.\\n        // If the anchor line cannot be found for some reason we fall back to our blacklist approach.\\n\\n        const stripWithBlacklist = (stack, stripFirstLine = true) => {\\n          const blacklist = [\\n            `at Reflect.${trap} `, // e.g. Reflect.get or Reflect.apply\\n            `at Object.${trap} `, // e.g. Object.get or Object.apply\\n            `at Object.newHandler.<computed> [as ${trap}] ` // caused by this very wrapper :-)\\n          ]\\n          return (\\n            err.stack\\n              .split('\\\\n')\\n              // Always remove the first (file) line in the stack (guaranteed to be our proxy)\\n              .filter((line, index) => !(index === 1 && stripFirstLine))\\n              // Check if the line starts with one of our blacklisted strings\\n              .filter(line => !blacklist.some(bl => line.trim().startsWith(bl)))\\n              .join('\\\\n')\\n          )\\n        }\\n\\n        const stripWithAnchor = (stack, anchor) => {\\n          const stackArr = stack.split('\\\\n')\\n          anchor = anchor || `at Object.newHandler.<computed> [as ${trap}] ` // Known first Proxy line in chromium\\n          const anchorIndex = stackArr.findIndex(line =>\\n            line.trim().startsWith(anchor)\\n          )\\n          if (anchorIndex === -1) {\\n            return false // 404, anchor not found\\n          }\\n          // Strip everything from the top until we reach the anchor line\\n          // Note: We're keeping the 1st line (zero index) as it's unrelated (e.g. `TypeError`)\\n          stackArr.splice(1, anchorIndex)\\n          return stackArr.join('\\\\n')\\n        }\\n\\n        // Special cases due to our nested toString proxies\\n        err.stack = err.stack.replace(\\n          'at Object.toString (',\\n          'at Function.toString ('\\n        )\\n        if ((err.stack || '').includes('at Function.toString (')) {\\n          err.stack = stripWithBlacklist(err.stack, false)\\n          throw err\\n        }\\n\\n        // Try using the anchor method, fallback to blacklist if necessary\\n        err.stack = stripWithAnchor(err.stack) || stripWithBlacklist(err.stack)\\n\\n        throw err // Re-throw our now sanitized error\\n      }\\n    }\\n  })\\n  return newHandler\\n}\",\"stripErrorWithAnchor\":\"(err, anchor) => {\\n  const stackArr = err.stack.split('\\\\n')\\n  const anchorIndex = stackArr.findIndex(line => line.trim().startsWith(anchor))\\n  if (anchorIndex === -1) {\\n    return err // 404, anchor not found\\n  }\\n  // Strip everything from the top until we reach the anchor line (remove anchor line as well)\\n  // Note: We're keeping the 1st line (zero index) as it's unrelated (e.g. `TypeError`)\\n  stackArr.splice(1, anchorIndex)\\n  err.stack = stackArr.join('\\\\n')\\n  return err\\n}\",\"replaceProperty\":\"(obj, propName, descriptorOverrides = {}) => {\\n  return Object.defineProperty(obj, propName, {\\n    // Copy over the existing descriptors (writable, enumerable, configurable, etc)\\n    ...(Object.getOwnPropertyDescriptor(obj, propName) || {}),\\n    // Add our overrides (e.g. value, get())\\n    ...descriptorOverrides\\n  })\\n}\",\"preloadCache\":\"() => {\\n  if (utils.cache) {\\n    return\\n  }\\n  utils.cache = {\\n    // Used in our proxies\\n    Reflect: {\\n      get: Reflect.get.bind(Reflect),\\n      apply: Reflect.apply.bind(Reflect)\\n    },\\n    // Used in `makeNativeString`\\n    nativeToStringStr: Function.toString + '' // => `function toString() { [native code] }`\\n  }\\n}\",\"makeNativeString\":\"(name = '') => {\\n  return utils.cache.nativeToStringStr.replace('toString', name || '')\\n}\",\"patchToString\":\"(obj, str = '') => {\\n  const handler = {\\n    apply: function (target, ctx) {\\n      // This fixes e.g. `HTMLMediaElement.prototype.canPlayType.toString + \\\"\\\"`\\n      if (ctx === Function.prototype.toString) {\\n        return utils.makeNativeString('toString')\\n      }\\n      // `toString` targeted at our proxied Object detected\\n      if (ctx === obj) {\\n        // We either return the optional string verbatim or derive the most desired result automatically\\n        return str || utils.makeNativeString(obj.name)\\n      }\\n      // Check if the toString protype of the context is the same as the global prototype,\\n      // if not indicates that we are doing a check across different windows., e.g. the iframeWithdirect` test case\\n      const hasSameProto = Object.getPrototypeOf(\\n        Function.prototype.toString\\n      ).isPrototypeOf(ctx.toString) // eslint-disable-line no-prototype-builtins\\n      if (!hasSameProto) {\\n        // Pass the call on to the local Function.prototype.toString instead\\n        return ctx.toString()\\n      }\\n      return target.call(ctx)\\n    }\\n  }\\n\\n  const toStringProxy = new Proxy(\\n    Function.prototype.toString,\\n    utils.stripProxyFromErrors(handler)\\n  )\\n  utils.replaceProperty(Function.prototype, 'toString', {\\n    value: toStringProxy\\n  })\\n}\",\"patchToStringNested\":\"(obj = {}) => {\\n  return utils.execRecursively(obj, ['function'], utils.patchToString)\\n}\",\"redirectToString\":\"(proxyObj, originalObj) => {\\n  const handler = {\\n    apply: function (target, ctx) {\\n      // This fixes e.g. `HTMLMediaElement.prototype.canPlayType.toString + \\\"\\\"`\\n      if (ctx === Function.prototype.toString) {\\n        return utils.makeNativeString('toString')\\n      }\\n\\n      // `toString` targeted at our proxied Object detected\\n      if (ctx === proxyObj) {\\n        const fallback = () =>\\n          originalObj && originalObj.name\\n            ? utils.makeNativeString(originalObj.name)\\n            : utils.makeNativeString(proxyObj.name)\\n\\n        // Return the toString representation of our original object if possible\\n        return originalObj + '' || fallback()\\n      }\\n\\n      if (typeof ctx === 'undefined' || ctx === null) {\\n        return target.call(ctx)\\n      }\\n\\n      // Check if the toString protype of the context is the same as the global prototype,\\n      // if not indicates that we are doing a check across different windows., e.g. the iframeWithdirect` test case\\n      const hasSameProto = Object.getPrototypeOf(\\n        Function.prototype.toString\\n      ).isPrototypeOf(ctx.toString) // eslint-disable-line no-prototype-builtins\\n      if (!hasSameProto) {\\n        // Pass the call on to the local Function.prototype.toString instead\\n        return ctx.toString()\\n      }\\n\\n      return target.call(ctx)\\n    }\\n  }\\n\\n  const toStringProxy = new Proxy(\\n    Function.prototype.toString,\\n    utils.stripProxyFromErrors(handler)\\n  )\\n  utils.replaceProperty(Function.prototype, 'toString', {\\n    value: toStringProxy\\n  })\\n}\",\"replaceWithProxy\":\"(obj, propName, handler) => {\\n  const originalObj = obj[propName]\\n  const proxyObj = new Proxy(obj[propName], utils.stripProxyFromErrors(handler))\\n\\n  utils.replaceProperty(obj, propName, { value: proxyObj })\\n  utils.redirectToString(proxyObj, originalObj)\\n\\n  return true\\n}\",\"replaceGetterWithProxy\":\"(obj, propName, handler) => {\\n  const fn = Object.getOwnPropertyDescriptor(obj, propName).get\\n  const fnStr = fn.toString() // special getter function string\\n  const proxyObj = new Proxy(fn, utils.stripProxyFromErrors(handler))\\n\\n  utils.replaceProperty(obj, propName, { get: proxyObj })\\n  utils.patchToString(proxyObj, fnStr)\\n\\n  return true\\n}\",\"replaceGetterSetter\":\"(obj, propName, handlerGetterSetter) => {\\n  const ownPropertyDescriptor = Object.getOwnPropertyDescriptor(obj, propName)\\n  const handler = { ...ownPropertyDescriptor }\\n\\n  if (handlerGetterSetter.get !== undefined) {\\n    const nativeFn = ownPropertyDescriptor.get\\n    handler.get = function() {\\n      return handlerGetterSetter.get.call(this, nativeFn.bind(this))\\n    }\\n    utils.redirectToString(handler.get, nativeFn)\\n  }\\n\\n  if (handlerGetterSetter.set !== undefined) {\\n    const nativeFn = ownPropertyDescriptor.set\\n    handler.set = function(newValue) {\\n      handlerGetterSetter.set.call(this, newValue, nativeFn.bind(this))\\n    }\\n    utils.redirectToString(handler.set, nativeFn)\\n  }\\n\\n  Object.defineProperty(obj, propName, handler)\\n}\",\"mockWithProxy\":\"(obj, propName, pseudoTarget, handler) => {\\n  const proxyObj = new Proxy(pseudoTarget, utils.stripProxyFromErrors(handler))\\n\\n  utils.replaceProperty(obj, propName, { value: proxyObj })\\n  utils.patchToString(proxyObj)\\n\\n  return true\\n}\",\"createProxy\":\"(pseudoTarget, handler) => {\\n  const proxyObj = new Proxy(pseudoTarget, utils.stripProxyFromErrors(handler))\\n  utils.patchToString(proxyObj)\\n\\n  return proxyObj\\n}\",\"splitObjPath\":\"objPath => ({\\n  // Remove last dot entry (property) ==> `HTMLMediaElement.prototype`\\n  objName: objPath.split('.').slice(0, -1).join('.'),\\n  // Extract last dot entry ==> `canPlayType`\\n  propName: objPath.split('.').slice(-1)[0]\\n})\",\"replaceObjPathWithProxy\":\"(objPath, handler) => {\\n  const { objName, propName } = utils.splitObjPath(objPath)\\n  const obj = eval(objName) // eslint-disable-line no-eval\\n  return utils.replaceWithProxy(obj, propName, handler)\\n}\",\"execRecursively\":\"(obj = {}, typeFilter = [], fn) => {\\n  function recurse(obj) {\\n    for (const key in obj) {\\n      if (obj[key] === undefined) {\\n        continue\\n      }\\n      if (obj[key] && typeof obj[key] === 'object') {\\n        recurse(obj[key])\\n      } else {\\n        if (obj[key] && typeFilter.includes(typeof obj[key])) {\\n          fn.call(this, obj[key])\\n        }\\n      }\\n    }\\n  }\\n  recurse(obj)\\n  return obj\\n}\",\"stringifyFns\":\"(fnObj = { hello: () => 'world' }) => {\\n  // Object.fromEntries() ponyfill (in 6 lines) - supported only in Node v12+, modern browsers are fine\\n  // https://github.com/feross/fromentries\\n  function fromEntries(iterable) {\\n    return [...iterable].reduce((obj, [key, val]) => {\\n      obj[key] = val\\n      return obj\\n    }, {})\\n  }\\n  return (Object.fromEntries || fromEntries)(\\n    Object.entries(fnObj)\\n      .filter(([key, value]) => typeof value === 'function')\\n      .map(([key, value]) => [key, value.toString()]) // eslint-disable-line no-eval\\n  )\\n}\",\"materializeFns\":\"(fnStrObj = { hello: \\\"() => 'world'\\\" }) => {\\n  return Object.fromEntries(\\n    Object.entries(fnStrObj).map(([key, value]) => {\\n      if (value.startsWith('function')) {\\n        // some trickery is needed to make oldschool functions work :-)\\n        return [key, eval(`() => ${value}`)()] // eslint-disable-line no-eval\\n      } else {\\n        // arrow functions just work\\n        return [key, eval(value)] // eslint-disable-line no-eval\\n      }\\n    })\\n  )\\n}\",\"makeHandler\":\"() => ({\\n  // Used by simple `navigator` getter evasions\\n  getterValue: value => ({\\n    apply(target, ctx, args) {\\n      // Let's fetch the value first, to trigger and escalate potential errors\\n      // Illegal invocations like `navigator.__proto__.vendor` will throw here\\n      utils.cache.Reflect.apply(...arguments)\\n      return value\\n    }\\n  })\\n})\",\"arrayEquals\":\"(array1, array2) => {\\n  if (array1.length !== array2.length) {\\n    return false\\n  }\\n  for (let i = 0; i < array1.length; ++i) {\\n    if (array1[i] !== array2[i]) {\\n      return false\\n    }\\n  }\\n  return true\\n}\",\"memoize\":\"fn => {\\n  const cache = []\\n  return function(...args) {\\n    if (!cache.some(c => utils.arrayEquals(c.key, args))) {\\n      cache.push({ key: args, value: fn.apply(this, args) })\\n    }\\n    return cache.find(c => utils.arrayEquals(c.key, args)).value\\n  }\\n}\"},\"_mainFunction\":\"(utils, opts) => {\\n      const isSecure = document.location.protocol.startsWith('https')\\n\\n      // In headful on secure origins the permission should be \\\"default\\\", not \\\"denied\\\"\\n      if (isSecure) {\\n        utils.replaceGetterWithProxy(Notification, 'permission', {\\n          apply() {\\n            return 'default'\\n          }\\n        })\\n      }\\n\\n      // Another weird behavior:\\n      // On insecure origins in headful the state is \\\"denied\\\",\\n      // whereas in headless it's \\\"prompt\\\"\\n      if (!isSecure) {\\n        const handler = {\\n          apply(target, ctx, args) {\\n            const param = (args || [])[0]\\n\\n            const isNotifications =\\n              param && param.name && param.name === 'notifications'\\n            if (!isNotifications) {\\n              return utils.cache.Reflect.apply(...arguments)\\n            }\\n\\n            return Promise.resolve(\\n              Object.setPrototypeOf(\\n                {\\n                  state: 'denied',\\n                  onchange: null\\n                },\\n                PermissionStatus.prototype\\n              )\\n            )\\n          }\\n        }\\n        // Note: Don't use `Object.getPrototypeOf` here\\n        utils.replaceWithProxy(Permissions.prototype, 'query', handler)\\n      }\\n    }\",\"_args\":[{}]})"},"stack":[{"file":"/home/neetoci/neeto-chat-web/playwright-tests/node_modules/@bigbinary/neeto-playwright-commons/node_modules/playwright-extra/dist/index.esm.js","line":230,"column":32,"function":"Proxy.<anonymous>"}]}
{"type":"before","callId":"pw:api@54","parentId":"hook@2","startTime":92244.784,"class":"Test","method":"step","apiName":"page.addInitScript","params":{"source":"(({ _utilsFns, _mainFunction, _args }) => {\n        // Add this point we cannot use our utililty functions as they're just strings, we need to materialize them first\n        const utils = Object.fromEntries(\n          Object.entries(_utilsFns).map(([key, value]) => [key, eval(value)]) // eslint-disable-line no-eval\n        )\n        utils.init()\n        return eval(_mainFunction)(utils, ..._args) // eslint-disable-line no-eval\n      })({\"_utilsFns\":{\"init\":\"() => {\\n  utils.preloadCache()\\n}\",\"stripProxyFromErrors\":\"(handler = {}) => {\\n  const newHandler = {\\n    setPrototypeOf: function (target, proto) {\\n      if (proto === null)\\n        throw new TypeError('Cannot convert object to primitive value')\\n      if (Object.getPrototypeOf(target) === Object.getPrototypeOf(proto)) {\\n        throw new TypeError('Cyclic __proto__ value')\\n      }\\n      return Reflect.setPrototypeOf(target, proto)\\n    }\\n  }\\n  // We wrap each trap in the handler in a try/catch and modify the error stack if they throw\\n  const traps = Object.getOwnPropertyNames(handler)\\n  traps.forEach(trap => {\\n    newHandler[trap] = function () {\\n      try {\\n        // Forward the call to the defined proxy handler\\n        return handler[trap].apply(this, arguments || [])\\n      } catch (err) {\\n        // Stack traces differ per browser, we only support chromium based ones currently\\n        if (!err || !err.stack || !err.stack.includes(`at `)) {\\n          throw err\\n        }\\n\\n        // When something throws within one of our traps the Proxy will show up in error stacks\\n        // An earlier implementation of this code would simply strip lines with a blacklist,\\n        // but it makes sense to be more surgical here and only remove lines related to our Proxy.\\n        // We try to use a known \\\"anchor\\\" line for that and strip it with everything above it.\\n        // If the anchor line cannot be found for some reason we fall back to our blacklist approach.\\n\\n        const stripWithBlacklist = (stack, stripFirstLine = true) => {\\n          const blacklist = [\\n            `at Reflect.${trap} `, // e.g. Reflect.get or Reflect.apply\\n            `at Object.${trap} `, // e.g. Object.get or Object.apply\\n            `at Object.newHandler.<computed> [as ${trap}] ` // caused by this very wrapper :-)\\n          ]\\n          return (\\n            err.stack\\n              .split('\\\\n')\\n              // Always remove the first (file) line in the stack (guaranteed to be our proxy)\\n              .filter((line, index) => !(index === 1 && stripFirstLine))\\n              // Check if the line starts with one of our blacklisted strings\\n              .filter(line => !blacklist.some(bl => line.trim().startsWith(bl)))\\n              .join('\\\\n')\\n          )\\n        }\\n\\n        const stripWithAnchor = (stack, anchor) => {\\n          const stackArr = stack.split('\\\\n')\\n          anchor = anchor || `at Object.newHandler.<computed> [as ${trap}] ` // Known first Proxy line in chromium\\n          const anchorIndex = stackArr.findIndex(line =>\\n            line.trim().startsWith(anchor)\\n          )\\n          if (anchorIndex === -1) {\\n            return false // 404, anchor not found\\n          }\\n          // Strip everything from the top until we reach the anchor line\\n          // Note: We're keeping the 1st line (zero index) as it's unrelated (e.g. `TypeError`)\\n          stackArr.splice(1, anchorIndex)\\n          return stackArr.join('\\\\n')\\n        }\\n\\n        // Special cases due to our nested toString proxies\\n        err.stack = err.stack.replace(\\n          'at Object.toString (',\\n          'at Function.toString ('\\n        )\\n        if ((err.stack || '').includes('at Function.toString (')) {\\n          err.stack = stripWithBlacklist(err.stack, false)\\n          throw err\\n        }\\n\\n        // Try using the anchor method, fallback to blacklist if necessary\\n        err.stack = stripWithAnchor(err.stack) || stripWithBlacklist(err.stack)\\n\\n        throw err // Re-throw our now sanitized error\\n      }\\n    }\\n  })\\n  return newHandler\\n}\",\"stripErrorWithAnchor\":\"(err, anchor) => {\\n  const stackArr = err.stack.split('\\\\n')\\n  const anchorIndex = stackArr.findIndex(line => line.trim().startsWith(anchor))\\n  if (anchorIndex === -1) {\\n    return err // 404, anchor not found\\n  }\\n  // Strip everything from the top until we reach the anchor line (remove anchor line as well)\\n  // Note: We're keeping the 1st line (zero index) as it's unrelated (e.g. `TypeError`)\\n  stackArr.splice(1, anchorIndex)\\n  err.stack = stackArr.join('\\\\n')\\n  return err\\n}\",\"replaceProperty\":\"(obj, propName, descriptorOverrides = {}) => {\\n  return Object.defineProperty(obj, propName, {\\n    // Copy over the existing descriptors (writable, enumerable, configurable, etc)\\n    ...(Object.getOwnPropertyDescriptor(obj, propName) || {}),\\n    // Add our overrides (e.g. value, get())\\n    ...descriptorOverrides\\n  })\\n}\",\"preloadCache\":\"() => {\\n  if (utils.cache) {\\n    return\\n  }\\n  utils.cache = {\\n    // Used in our proxies\\n    Reflect: {\\n      get: Reflect.get.bind(Reflect),\\n      apply: Reflect.apply.bind(Reflect)\\n    },\\n    // Used in `makeNativeString`\\n    nativeToStringStr: Function.toString + '' // => `function toString() { [native code] }`\\n  }\\n}\",\"makeNativeString\":\"(name = '') => {\\n  return utils.cache.nativeToStringStr.replace('toString', name || '')\\n}\",\"patchToString\":\"(obj, str = '') => {\\n  const handler = {\\n    apply: function (target, ctx) {\\n      // This fixes e.g. `HTMLMediaElement.prototype.canPlayType.toString + \\\"\\\"`\\n      if (ctx === Function.prototype.toString) {\\n        return utils.makeNativeString('toString')\\n      }\\n      // `toString` targeted at our proxied Object detected\\n      if (ctx === obj) {\\n        // We either return the optional string verbatim or derive the most desired result automatically\\n        return str || utils.makeNativeString(obj.name)\\n      }\\n      // Check if the toString protype of the context is the same as the global prototype,\\n      // if not indicates that we are doing a check across different windows., e.g. the iframeWithdirect` test case\\n      const hasSameProto = Object.getPrototypeOf(\\n        Function.prototype.toString\\n      ).isPrototypeOf(ctx.toString) // eslint-disable-line no-prototype-builtins\\n      if (!hasSameProto) {\\n        // Pass the call on to the local Function.prototype.toString instead\\n        return ctx.toString()\\n      }\\n      return target.call(ctx)\\n    }\\n  }\\n\\n  const toStringProxy = new Proxy(\\n    Function.prototype.toString,\\n    utils.stripProxyFromErrors(handler)\\n  )\\n  utils.replaceProperty(Function.prototype, 'toString', {\\n    value: toStringProxy\\n  })\\n}\",\"patchToStringNested\":\"(obj = {}) => {\\n  return utils.execRecursively(obj, ['function'], utils.patchToString)\\n}\",\"redirectToString\":\"(proxyObj, originalObj) => {\\n  const handler = {\\n    apply: function (target, ctx) {\\n      // This fixes e.g. `HTMLMediaElement.prototype.canPlayType.toString + \\\"\\\"`\\n      if (ctx === Function.prototype.toString) {\\n        return utils.makeNativeString('toString')\\n      }\\n\\n      // `toString` targeted at our proxied Object detected\\n      if (ctx === proxyObj) {\\n        const fallback = () =>\\n          originalObj && originalObj.name\\n            ? utils.makeNativeString(originalObj.name)\\n            : utils.makeNativeString(proxyObj.name)\\n\\n        // Return the toString representation of our original object if possible\\n        return originalObj + '' || fallback()\\n      }\\n\\n      if (typeof ctx === 'undefined' || ctx === null) {\\n        return target.call(ctx)\\n      }\\n\\n      // Check if the toString protype of the context is the same as the global prototype,\\n      // if not indicates that we are doing a check across different windows., e.g. the iframeWithdirect` test case\\n      const hasSameProto = Object.getPrototypeOf(\\n        Function.prototype.toString\\n      ).isPrototypeOf(ctx.toString) // eslint-disable-line no-prototype-builtins\\n      if (!hasSameProto) {\\n        // Pass the call on to the local Function.prototype.toString instead\\n        return ctx.toString()\\n      }\\n\\n      return target.call(ctx)\\n    }\\n  }\\n\\n  const toStringProxy = new Proxy(\\n    Function.prototype.toString,\\n    utils.stripProxyFromErrors(handler)\\n  )\\n  utils.replaceProperty(Function.prototype, 'toString', {\\n    value: toStringProxy\\n  })\\n}\",\"replaceWithProxy\":\"(obj, propName, handler) => {\\n  const originalObj = obj[propName]\\n  const proxyObj = new Proxy(obj[propName], utils.stripProxyFromErrors(handler))\\n\\n  utils.replaceProperty(obj, propName, { value: proxyObj })\\n  utils.redirectToString(proxyObj, originalObj)\\n\\n  return true\\n}\",\"replaceGetterWithProxy\":\"(obj, propName, handler) => {\\n  const fn = Object.getOwnPropertyDescriptor(obj, propName).get\\n  const fnStr = fn.toString() // special getter function string\\n  const proxyObj = new Proxy(fn, utils.stripProxyFromErrors(handler))\\n\\n  utils.replaceProperty(obj, propName, { get: proxyObj })\\n  utils.patchToString(proxyObj, fnStr)\\n\\n  return true\\n}\",\"replaceGetterSetter\":\"(obj, propName, handlerGetterSetter) => {\\n  const ownPropertyDescriptor = Object.getOwnPropertyDescriptor(obj, propName)\\n  const handler = { ...ownPropertyDescriptor }\\n\\n  if (handlerGetterSetter.get !== undefined) {\\n    const nativeFn = ownPropertyDescriptor.get\\n    handler.get = function() {\\n      return handlerGetterSetter.get.call(this, nativeFn.bind(this))\\n    }\\n    utils.redirectToString(handler.get, nativeFn)\\n  }\\n\\n  if (handlerGetterSetter.set !== undefined) {\\n    const nativeFn = ownPropertyDescriptor.set\\n    handler.set = function(newValue) {\\n      handlerGetterSetter.set.call(this, newValue, nativeFn.bind(this))\\n    }\\n    utils.redirectToString(handler.set, nativeFn)\\n  }\\n\\n  Object.defineProperty(obj, propName, handler)\\n}\",\"mockWithProxy\":\"(obj, propName, pseudoTarget, handler) => {\\n  const proxyObj = new Proxy(pseudoTarget, utils.stripProxyFromErrors(handler))\\n\\n  utils.replaceProperty(obj, propName, { value: proxyObj })\\n  utils.patchToString(proxyObj)\\n\\n  return true\\n}\",\"createProxy\":\"(pseudoTarget, handler) => {\\n  const proxyObj = new Proxy(pseudoTarget, utils.stripProxyFromErrors(handler))\\n  utils.patchToString(proxyObj)\\n\\n  return proxyObj\\n}\",\"splitObjPath\":\"objPath => ({\\n  // Remove last dot entry (property) ==> `HTMLMediaElement.prototype`\\n  objName: objPath.split('.').slice(0, -1).join('.'),\\n  // Extract last dot entry ==> `canPlayType`\\n  propName: objPath.split('.').slice(-1)[0]\\n})\",\"replaceObjPathWithProxy\":\"(objPath, handler) => {\\n  const { objName, propName } = utils.splitObjPath(objPath)\\n  const obj = eval(objName) // eslint-disable-line no-eval\\n  return utils.replaceWithProxy(obj, propName, handler)\\n}\",\"execRecursively\":\"(obj = {}, typeFilter = [], fn) => {\\n  function recurse(obj) {\\n    for (const key in obj) {\\n      if (obj[key] === undefined) {\\n        continue\\n      }\\n      if (obj[key] && typeof obj[key] === 'object') {\\n        recurse(obj[key])\\n      } else {\\n        if (obj[key] && typeFilter.includes(typeof obj[key])) {\\n          fn.call(this, obj[key])\\n        }\\n      }\\n    }\\n  }\\n  recurse(obj)\\n  return obj\\n}\",\"stringifyFns\":\"(fnObj = { hello: () => 'world' }) => {\\n  // Object.fromEntries() ponyfill (in 6 lines) - supported only in Node v12+, modern browsers are fine\\n  // https://github.com/feross/fromentries\\n  function fromEntries(iterable) {\\n    return [...iterable].reduce((obj, [key, val]) => {\\n      obj[key] = val\\n      return obj\\n    }, {})\\n  }\\n  return (Object.fromEntries || fromEntries)(\\n    Object.entries(fnObj)\\n      .filter(([key, value]) => typeof value === 'function')\\n      .map(([key, value]) => [key, value.toString()]) // eslint-disable-line no-eval\\n  )\\n}\",\"materializeFns\":\"(fnStrObj = { hello: \\\"() => 'world'\\\" }) => {\\n  return Object.fromEntries(\\n    Object.entries(fnStrObj).map(([key, value]) => {\\n      if (value.startsWith('function')) {\\n        // some trickery is needed to make oldschool functions work :-)\\n        return [key, eval(`() => ${value}`)()] // eslint-disable-line no-eval\\n      } else {\\n        // arrow functions just work\\n        return [key, eval(value)] // eslint-disable-line no-eval\\n      }\\n    })\\n  )\\n}\",\"makeHandler\":\"() => ({\\n  // Used by simple `navigator` getter evasions\\n  getterValue: value => ({\\n    apply(target, ctx, args) {\\n      // Let's fetch the value first, to trigger and escalate potential errors\\n      // Illegal invocations like `navigator.__proto__.vendor` will throw here\\n      utils.cache.Reflect.apply(...arguments)\\n      return value\\n    }\\n  })\\n})\",\"arrayEquals\":\"(array1, array2) => {\\n  if (array1.length !== array2.length) {\\n    return false\\n  }\\n  for (let i = 0; i < array1.length; ++i) {\\n    if (array1[i] !== array2[i]) {\\n      return false\\n    }\\n  }\\n  return true\\n}\",\"memoize\":\"fn => {\\n  const cache = []\\n  return function(...args) {\\n    if (!cache.some(c => utils.arrayEquals(c.key, args))) {\\n      cache.push({ key: args, value: fn.apply(this, args) })\\n    }\\n    return cache.find(c => utils.arrayEquals(c.key, args)).value\\n  }\\n}\"},\"_mainFunction\":\"(utils, { fns, data }) => {\\n        fns = utils.materializeFns(fns)\\n\\n        // That means we're running headful\\n        const hasPlugins = 'plugins' in navigator && navigator.plugins.length\\n        if (hasPlugins) {\\n          return // nothing to do here\\n        }\\n\\n        const mimeTypes = fns.generateMimeTypeArray(utils, fns)(data.mimeTypes)\\n        const plugins = fns.generatePluginArray(utils, fns)(data.plugins)\\n\\n        // Plugin and MimeType cross-reference each other, let's do that now\\n        // Note: We're looping through `data.plugins` here, not the generated `plugins`\\n        for (const pluginData of data.plugins) {\\n          pluginData.__mimeTypes.forEach((type, index) => {\\n            plugins[pluginData.name][index] = mimeTypes[type]\\n\\n            Object.defineProperty(plugins[pluginData.name], type, {\\n              value: mimeTypes[type],\\n              writable: false,\\n              enumerable: false, // Not enumerable\\n              configurable: true\\n            })\\n            Object.defineProperty(mimeTypes[type], 'enabledPlugin', {\\n              value:\\n                type === 'application/x-pnacl'\\n                  ? mimeTypes['application/x-nacl'].enabledPlugin // these reference the same plugin, so we need to re-use the Proxy in order to avoid leaks\\n                  : new Proxy(plugins[pluginData.name], {}), // Prevent circular references\\n              writable: false,\\n              enumerable: false, // Important: `JSON.stringify(navigator.plugins)`\\n              configurable: true\\n            })\\n          })\\n        }\\n\\n        const patchNavigator = (name, value) =>\\n          utils.replaceProperty(Object.getPrototypeOf(navigator), name, {\\n            get() {\\n              return value\\n            }\\n          })\\n\\n        patchNavigator('mimeTypes', mimeTypes)\\n        patchNavigator('plugins', plugins)\\n\\n        // All done\\n      }\",\"_args\":[{\"fns\":{\"generateMimeTypeArray\":\"(utils, fns) => mimeTypesData => {\\n  return fns.generateMagicArray(utils, fns)(\\n    mimeTypesData,\\n    MimeTypeArray.prototype,\\n    MimeType.prototype,\\n    'type'\\n  )\\n}\",\"generatePluginArray\":\"(utils, fns) => pluginsData => {\\n  return fns.generateMagicArray(utils, fns)(\\n    pluginsData,\\n    PluginArray.prototype,\\n    Plugin.prototype,\\n    'name'\\n  )\\n}\",\"generateMagicArray\":\"(utils, fns) =>\\n  function(\\n    dataArray = [],\\n    proto = MimeTypeArray.prototype,\\n    itemProto = MimeType.prototype,\\n    itemMainProp = 'type'\\n  ) {\\n    // Quick helper to set props with the same descriptors vanilla is using\\n    const defineProp = (obj, prop, value) =>\\n      Object.defineProperty(obj, prop, {\\n        value,\\n        writable: false,\\n        enumerable: false, // Important for mimeTypes & plugins: `JSON.stringify(navigator.mimeTypes)`\\n        configurable: true\\n      })\\n\\n    // Loop over our fake data and construct items\\n    const makeItem = data => {\\n      const item = {}\\n      for (const prop of Object.keys(data)) {\\n        if (prop.startsWith('__')) {\\n          continue\\n        }\\n        defineProp(item, prop, data[prop])\\n      }\\n      return patchItem(item, data)\\n    }\\n\\n    const patchItem = (item, data) => {\\n      let descriptor = Object.getOwnPropertyDescriptors(item)\\n\\n      // Special case: Plugins have a magic length property which is not enumerable\\n      // e.g. `navigator.plugins[i].length` should always be the length of the assigned mimeTypes\\n      if (itemProto === Plugin.prototype) {\\n        descriptor = {\\n          ...descriptor,\\n          length: {\\n            value: data.__mimeTypes.length,\\n            writable: false,\\n            enumerable: false,\\n            configurable: true // Important to be able to use the ownKeys trap in a Proxy to strip `length`\\n          }\\n        }\\n      }\\n\\n      // We need to spoof a specific `MimeType` or `Plugin` object\\n      const obj = Object.create(itemProto, descriptor)\\n\\n      // Virtually all property keys are not enumerable in vanilla\\n      const blacklist = [...Object.keys(data), 'length', 'enabledPlugin']\\n      return new Proxy(obj, {\\n        ownKeys(target) {\\n          return Reflect.ownKeys(target).filter(k => !blacklist.includes(k))\\n        },\\n        getOwnPropertyDescriptor(target, prop) {\\n          if (blacklist.includes(prop)) {\\n            return undefined\\n          }\\n          return Reflect.getOwnPropertyDescriptor(target, prop)\\n        }\\n      })\\n    }\\n\\n    const magicArray = []\\n\\n    // Loop through our fake data and use that to create convincing entities\\n    dataArray.forEach(data => {\\n      magicArray.push(makeItem(data))\\n    })\\n\\n    // Add direct property access  based on types (e.g. `obj['application/pdf']`) afterwards\\n    magicArray.forEach(entry => {\\n      defineProp(magicArray, entry[itemMainProp], entry)\\n    })\\n\\n    // This is the best way to fake the type to make sure this is false: `Array.isArray(navigator.mimeTypes)`\\n    const magicArrayObj = Object.create(proto, {\\n      ...Object.getOwnPropertyDescriptors(magicArray),\\n\\n      // There's one ugly quirk we unfortunately need to take care of:\\n      // The `MimeTypeArray` prototype has an enumerable `length` property,\\n      // but headful Chrome will still skip it when running `Object.getOwnPropertyNames(navigator.mimeTypes)`.\\n      // To strip it we need to make it first `configurable` and can then overlay a Proxy with an `ownKeys` trap.\\n      length: {\\n        value: magicArray.length,\\n        writable: false,\\n        enumerable: false,\\n        configurable: true // Important to be able to use the ownKeys trap in a Proxy to strip `length`\\n      }\\n    })\\n\\n    // Generate our functional function mocks :-)\\n    const functionMocks = fns.generateFunctionMocks(utils)(\\n      proto,\\n      itemMainProp,\\n      magicArray\\n    )\\n\\n    // We need to overlay our custom object with a JS Proxy\\n    const magicArrayObjProxy = new Proxy(magicArrayObj, {\\n      get(target, key = '') {\\n        // Redirect function calls to our custom proxied versions mocking the vanilla behavior\\n        if (key === 'item') {\\n          return functionMocks.item\\n        }\\n        if (key === 'namedItem') {\\n          return functionMocks.namedItem\\n        }\\n        if (proto === PluginArray.prototype && key === 'refresh') {\\n          return functionMocks.refresh\\n        }\\n        // Everything else can pass through as normal\\n        return utils.cache.Reflect.get(...arguments)\\n      },\\n      ownKeys(target) {\\n        // There are a couple of quirks where the original property demonstrates \\\"magical\\\" behavior that makes no sense\\n        // This can be witnessed when calling `Object.getOwnPropertyNames(navigator.mimeTypes)` and the absense of `length`\\n        // My guess is that it has to do with the recent change of not allowing data enumeration and this being implemented weirdly\\n        // For that reason we just completely fake the available property names based on our data to match what regular Chrome is doing\\n        // Specific issues when not patching this: `length` property is available, direct `types` props (e.g. `obj['application/pdf']`) are missing\\n        const keys = []\\n        const typeProps = magicArray.map(mt => mt[itemMainProp])\\n        typeProps.forEach((_, i) => keys.push(`${i}`))\\n        typeProps.forEach(propName => keys.push(propName))\\n        return keys\\n      },\\n      getOwnPropertyDescriptor(target, prop) {\\n        if (prop === 'length') {\\n          return undefined\\n        }\\n        return Reflect.getOwnPropertyDescriptor(target, prop)\\n      }\\n    })\\n\\n    return magicArrayObjProxy\\n  }\",\"generateFunctionMocks\":\"utils => (\\n  proto,\\n  itemMainProp,\\n  dataArray\\n) => ({\\n  /** Returns the MimeType object with the specified index. */\\n  item: utils.createProxy(proto.item, {\\n    apply(target, ctx, args) {\\n      if (!args.length) {\\n        throw new TypeError(\\n          `Failed to execute 'item' on '${\\n            proto[Symbol.toStringTag]\\n          }': 1 argument required, but only 0 present.`\\n        )\\n      }\\n      // Special behavior alert:\\n      // - Vanilla tries to cast strings to Numbers (only integers!) and use them as property index lookup\\n      // - If anything else than an integer (including as string) is provided it will return the first entry\\n      const isInteger = args[0] && Number.isInteger(Number(args[0])) // Cast potential string to number first, then check for integer\\n      // Note: Vanilla never returns `undefined`\\n      return (isInteger ? dataArray[Number(args[0])] : dataArray[0]) || null\\n    }\\n  }),\\n  /** Returns the MimeType object with the specified name. */\\n  namedItem: utils.createProxy(proto.namedItem, {\\n    apply(target, ctx, args) {\\n      if (!args.length) {\\n        throw new TypeError(\\n          `Failed to execute 'namedItem' on '${\\n            proto[Symbol.toStringTag]\\n          }': 1 argument required, but only 0 present.`\\n        )\\n      }\\n      return dataArray.find(mt => mt[itemMainProp] === args[0]) || null // Not `undefined`!\\n    }\\n  }),\\n  /** Does nothing and shall return nothing */\\n  refresh: proto.refresh\\n    ? utils.createProxy(proto.refresh, {\\n        apply(target, ctx, args) {\\n          return undefined\\n        }\\n      })\\n    : undefined\\n})\"},\"data\":{\"mimeTypes\":[{\"type\":\"application/pdf\",\"suffixes\":\"pdf\",\"description\":\"\",\"__pluginName\":\"Chrome PDF Viewer\"},{\"type\":\"application/x-google-chrome-pdf\",\"suffixes\":\"pdf\",\"description\":\"Portable Document Format\",\"__pluginName\":\"Chrome PDF Plugin\"},{\"type\":\"application/x-nacl\",\"suffixes\":\"\",\"description\":\"Native Client Executable\",\"__pluginName\":\"Native Client\"},{\"type\":\"application/x-pnacl\",\"suffixes\":\"\",\"description\":\"Portable Native Client Executable\",\"__pluginName\":\"Native Client\"}],\"plugins\":[{\"name\":\"Chrome PDF Plugin\",\"filename\":\"internal-pdf-viewer\",\"description\":\"Portable Document Format\",\"__mimeTypes\":[\"application/x-google-chrome-pdf\"]},{\"name\":\"Chrome PDF Viewer\",\"filename\":\"mhjfbmdgcfjbbpaeojofohoefgiehjai\",\"description\":\"\",\"__mimeTypes\":[\"application/pdf\"]},{\"name\":\"Native Client\",\"filename\":\"internal-nacl-plugin\",\"description\":\"\",\"__mimeTypes\":[\"application/x-nacl\",\"application/x-pnacl\"]}]}}]})"},"stack":[{"file":"/home/neetoci/neeto-chat-web/playwright-tests/node_modules/@bigbinary/neeto-playwright-commons/node_modules/playwright-extra/dist/index.esm.js","line":230,"column":32,"function":"Proxy.<anonymous>"}]}
{"type":"before","callId":"pw:api@55","parentId":"hook@2","startTime":92245.537,"class":"Test","method":"step","apiName":"page.addInitScript","params":{"source":"(() => {\n      if (navigator.webdriver === false) {\n        // Post Chrome 89.0.4339.0 and already good\n      } else if (navigator.webdriver === undefined) {\n        // Pre Chrome 89.0.4339.0 and already good\n      } else {\n        // Pre Chrome 88.0.4291.0 and needs patching\n        delete Object.getPrototypeOf(navigator).webdriver\n      }\n    })(undefined)"},"stack":[{"file":"/home/neetoci/neeto-chat-web/playwright-tests/node_modules/@bigbinary/neeto-playwright-commons/node_modules/playwright-extra/dist/index.esm.js","line":230,"column":32,"function":"Proxy.<anonymous>"}]}
{"type":"before","callId":"pw:api@56","parentId":"hook@2","startTime":92246.337,"class":"Test","method":"step","apiName":"cdpSession.send","params":{"method":"Browser.getVersion","params":"undefined"},"stack":[{"file":"/home/neetoci/neeto-chat-web/playwright-tests/node_modules/@bigbinary/neeto-playwright-commons/node_modules/playwright-extra/dist/index.esm.js","line":263,"column":48,"function":"Proxy.<anonymous>"}]}
{"type":"before","callId":"pw:api@57","parentId":"hook@2","startTime":92248.487,"class":"Test","method":"step","apiName":"page.addInitScript","params":{"source":"(({ _utilsFns, _mainFunction, _args }) => {\n        // Add this point we cannot use our utililty functions as they're just strings, we need to materialize them first\n        const utils = Object.fromEntries(\n          Object.entries(_utilsFns).map(([key, value]) => [key, eval(value)]) // eslint-disable-line no-eval\n        )\n        utils.init()\n        return eval(_mainFunction)(utils, ..._args) // eslint-disable-line no-eval\n      })({\"_utilsFns\":{\"init\":\"() => {\\n  utils.preloadCache()\\n}\",\"stripProxyFromErrors\":\"(handler = {}) => {\\n  const newHandler = {\\n    setPrototypeOf: function (target, proto) {\\n      if (proto === null)\\n        throw new TypeError('Cannot convert object to primitive value')\\n      if (Object.getPrototypeOf(target) === Object.getPrototypeOf(proto)) {\\n        throw new TypeError('Cyclic __proto__ value')\\n      }\\n      return Reflect.setPrototypeOf(target, proto)\\n    }\\n  }\\n  // We wrap each trap in the handler in a try/catch and modify the error stack if they throw\\n  const traps = Object.getOwnPropertyNames(handler)\\n  traps.forEach(trap => {\\n    newHandler[trap] = function () {\\n      try {\\n        // Forward the call to the defined proxy handler\\n        return handler[trap].apply(this, arguments || [])\\n      } catch (err) {\\n        // Stack traces differ per browser, we only support chromium based ones currently\\n        if (!err || !err.stack || !err.stack.includes(`at `)) {\\n          throw err\\n        }\\n\\n        // When something throws within one of our traps the Proxy will show up in error stacks\\n        // An earlier implementation of this code would simply strip lines with a blacklist,\\n        // but it makes sense to be more surgical here and only remove lines related to our Proxy.\\n        // We try to use a known \\\"anchor\\\" line for that and strip it with everything above it.\\n        // If the anchor line cannot be found for some reason we fall back to our blacklist approach.\\n\\n        const stripWithBlacklist = (stack, stripFirstLine = true) => {\\n          const blacklist = [\\n            `at Reflect.${trap} `, // e.g. Reflect.get or Reflect.apply\\n            `at Object.${trap} `, // e.g. Object.get or Object.apply\\n            `at Object.newHandler.<computed> [as ${trap}] ` // caused by this very wrapper :-)\\n          ]\\n          return (\\n            err.stack\\n              .split('\\\\n')\\n              // Always remove the first (file) line in the stack (guaranteed to be our proxy)\\n              .filter((line, index) => !(index === 1 && stripFirstLine))\\n              // Check if the line starts with one of our blacklisted strings\\n              .filter(line => !blacklist.some(bl => line.trim().startsWith(bl)))\\n              .join('\\\\n')\\n          )\\n        }\\n\\n        const stripWithAnchor = (stack, anchor) => {\\n          const stackArr = stack.split('\\\\n')\\n          anchor = anchor || `at Object.newHandler.<computed> [as ${trap}] ` // Known first Proxy line in chromium\\n          const anchorIndex = stackArr.findIndex(line =>\\n            line.trim().startsWith(anchor)\\n          )\\n          if (anchorIndex === -1) {\\n            return false // 404, anchor not found\\n          }\\n          // Strip everything from the top until we reach the anchor line\\n          // Note: We're keeping the 1st line (zero index) as it's unrelated (e.g. `TypeError`)\\n          stackArr.splice(1, anchorIndex)\\n          return stackArr.join('\\\\n')\\n        }\\n\\n        // Special cases due to our nested toString proxies\\n        err.stack = err.stack.replace(\\n          'at Object.toString (',\\n          'at Function.toString ('\\n        )\\n        if ((err.stack || '').includes('at Function.toString (')) {\\n          err.stack = stripWithBlacklist(err.stack, false)\\n          throw err\\n        }\\n\\n        // Try using the anchor method, fallback to blacklist if necessary\\n        err.stack = stripWithAnchor(err.stack) || stripWithBlacklist(err.stack)\\n\\n        throw err // Re-throw our now sanitized error\\n      }\\n    }\\n  })\\n  return newHandler\\n}\",\"stripErrorWithAnchor\":\"(err, anchor) => {\\n  const stackArr = err.stack.split('\\\\n')\\n  const anchorIndex = stackArr.findIndex(line => line.trim().startsWith(anchor))\\n  if (anchorIndex === -1) {\\n    return err // 404, anchor not found\\n  }\\n  // Strip everything from the top until we reach the anchor line (remove anchor line as well)\\n  // Note: We're keeping the 1st line (zero index) as it's unrelated (e.g. `TypeError`)\\n  stackArr.splice(1, anchorIndex)\\n  err.stack = stackArr.join('\\\\n')\\n  return err\\n}\",\"replaceProperty\":\"(obj, propName, descriptorOverrides = {}) => {\\n  return Object.defineProperty(obj, propName, {\\n    // Copy over the existing descriptors (writable, enumerable, configurable, etc)\\n    ...(Object.getOwnPropertyDescriptor(obj, propName) || {}),\\n    // Add our overrides (e.g. value, get())\\n    ...descriptorOverrides\\n  })\\n}\",\"preloadCache\":\"() => {\\n  if (utils.cache) {\\n    return\\n  }\\n  utils.cache = {\\n    // Used in our proxies\\n    Reflect: {\\n      get: Reflect.get.bind(Reflect),\\n      apply: Reflect.apply.bind(Reflect)\\n    },\\n    // Used in `makeNativeString`\\n    nativeToStringStr: Function.toString + '' // => `function toString() { [native code] }`\\n  }\\n}\",\"makeNativeString\":\"(name = '') => {\\n  return utils.cache.nativeToStringStr.replace('toString', name || '')\\n}\",\"patchToString\":\"(obj, str = '') => {\\n  const handler = {\\n    apply: function (target, ctx) {\\n      // This fixes e.g. `HTMLMediaElement.prototype.canPlayType.toString + \\\"\\\"`\\n      if (ctx === Function.prototype.toString) {\\n        return utils.makeNativeString('toString')\\n      }\\n      // `toString` targeted at our proxied Object detected\\n      if (ctx === obj) {\\n        // We either return the optional string verbatim or derive the most desired result automatically\\n        return str || utils.makeNativeString(obj.name)\\n      }\\n      // Check if the toString protype of the context is the same as the global prototype,\\n      // if not indicates that we are doing a check across different windows., e.g. the iframeWithdirect` test case\\n      const hasSameProto = Object.getPrototypeOf(\\n        Function.prototype.toString\\n      ).isPrototypeOf(ctx.toString) // eslint-disable-line no-prototype-builtins\\n      if (!hasSameProto) {\\n        // Pass the call on to the local Function.prototype.toString instead\\n        return ctx.toString()\\n      }\\n      return target.call(ctx)\\n    }\\n  }\\n\\n  const toStringProxy = new Proxy(\\n    Function.prototype.toString,\\n    utils.stripProxyFromErrors(handler)\\n  )\\n  utils.replaceProperty(Function.prototype, 'toString', {\\n    value: toStringProxy\\n  })\\n}\",\"patchToStringNested\":\"(obj = {}) => {\\n  return utils.execRecursively(obj, ['function'], utils.patchToString)\\n}\",\"redirectToString\":\"(proxyObj, originalObj) => {\\n  const handler = {\\n    apply: function (target, ctx) {\\n      // This fixes e.g. `HTMLMediaElement.prototype.canPlayType.toString + \\\"\\\"`\\n      if (ctx === Function.prototype.toString) {\\n        return utils.makeNativeString('toString')\\n      }\\n\\n      // `toString` targeted at our proxied Object detected\\n      if (ctx === proxyObj) {\\n        const fallback = () =>\\n          originalObj && originalObj.name\\n            ? utils.makeNativeString(originalObj.name)\\n            : utils.makeNativeString(proxyObj.name)\\n\\n        // Return the toString representation of our original object if possible\\n        return originalObj + '' || fallback()\\n      }\\n\\n      if (typeof ctx === 'undefined' || ctx === null) {\\n        return target.call(ctx)\\n      }\\n\\n      // Check if the toString protype of the context is the same as the global prototype,\\n      // if not indicates that we are doing a check across different windows., e.g. the iframeWithdirect` test case\\n      const hasSameProto = Object.getPrototypeOf(\\n        Function.prototype.toString\\n      ).isPrototypeOf(ctx.toString) // eslint-disable-line no-prototype-builtins\\n      if (!hasSameProto) {\\n        // Pass the call on to the local Function.prototype.toString instead\\n        return ctx.toString()\\n      }\\n\\n      return target.call(ctx)\\n    }\\n  }\\n\\n  const toStringProxy = new Proxy(\\n    Function.prototype.toString,\\n    utils.stripProxyFromErrors(handler)\\n  )\\n  utils.replaceProperty(Function.prototype, 'toString', {\\n    value: toStringProxy\\n  })\\n}\",\"replaceWithProxy\":\"(obj, propName, handler) => {\\n  const originalObj = obj[propName]\\n  const proxyObj = new Proxy(obj[propName], utils.stripProxyFromErrors(handler))\\n\\n  utils.replaceProperty(obj, propName, { value: proxyObj })\\n  utils.redirectToString(proxyObj, originalObj)\\n\\n  return true\\n}\",\"replaceGetterWithProxy\":\"(obj, propName, handler) => {\\n  const fn = Object.getOwnPropertyDescriptor(obj, propName).get\\n  const fnStr = fn.toString() // special getter function string\\n  const proxyObj = new Proxy(fn, utils.stripProxyFromErrors(handler))\\n\\n  utils.replaceProperty(obj, propName, { get: proxyObj })\\n  utils.patchToString(proxyObj, fnStr)\\n\\n  return true\\n}\",\"replaceGetterSetter\":\"(obj, propName, handlerGetterSetter) => {\\n  const ownPropertyDescriptor = Object.getOwnPropertyDescriptor(obj, propName)\\n  const handler = { ...ownPropertyDescriptor }\\n\\n  if (handlerGetterSetter.get !== undefined) {\\n    const nativeFn = ownPropertyDescriptor.get\\n    handler.get = function() {\\n      return handlerGetterSetter.get.call(this, nativeFn.bind(this))\\n    }\\n    utils.redirectToString(handler.get, nativeFn)\\n  }\\n\\n  if (handlerGetterSetter.set !== undefined) {\\n    const nativeFn = ownPropertyDescriptor.set\\n    handler.set = function(newValue) {\\n      handlerGetterSetter.set.call(this, newValue, nativeFn.bind(this))\\n    }\\n    utils.redirectToString(handler.set, nativeFn)\\n  }\\n\\n  Object.defineProperty(obj, propName, handler)\\n}\",\"mockWithProxy\":\"(obj, propName, pseudoTarget, handler) => {\\n  const proxyObj = new Proxy(pseudoTarget, utils.stripProxyFromErrors(handler))\\n\\n  utils.replaceProperty(obj, propName, { value: proxyObj })\\n  utils.patchToString(proxyObj)\\n\\n  return true\\n}\",\"createProxy\":\"(pseudoTarget, handler) => {\\n  const proxyObj = new Proxy(pseudoTarget, utils.stripProxyFromErrors(handler))\\n  utils.patchToString(proxyObj)\\n\\n  return proxyObj\\n}\",\"splitObjPath\":\"objPath => ({\\n  // Remove last dot entry (property) ==> `HTMLMediaElement.prototype`\\n  objName: objPath.split('.').slice(0, -1).join('.'),\\n  // Extract last dot entry ==> `canPlayType`\\n  propName: objPath.split('.').slice(-1)[0]\\n})\",\"replaceObjPathWithProxy\":\"(objPath, handler) => {\\n  const { objName, propName } = utils.splitObjPath(objPath)\\n  const obj = eval(objName) // eslint-disable-line no-eval\\n  return utils.replaceWithProxy(obj, propName, handler)\\n}\",\"execRecursively\":\"(obj = {}, typeFilter = [], fn) => {\\n  function recurse(obj) {\\n    for (const key in obj) {\\n      if (obj[key] === undefined) {\\n        continue\\n      }\\n      if (obj[key] && typeof obj[key] === 'object') {\\n        recurse(obj[key])\\n      } else {\\n        if (obj[key] && typeFilter.includes(typeof obj[key])) {\\n          fn.call(this, obj[key])\\n        }\\n      }\\n    }\\n  }\\n  recurse(obj)\\n  return obj\\n}\",\"stringifyFns\":\"(fnObj = { hello: () => 'world' }) => {\\n  // Object.fromEntries() ponyfill (in 6 lines) - supported only in Node v12+, modern browsers are fine\\n  // https://github.com/feross/fromentries\\n  function fromEntries(iterable) {\\n    return [...iterable].reduce((obj, [key, val]) => {\\n      obj[key] = val\\n      return obj\\n    }, {})\\n  }\\n  return (Object.fromEntries || fromEntries)(\\n    Object.entries(fnObj)\\n      .filter(([key, value]) => typeof value === 'function')\\n      .map(([key, value]) => [key, value.toString()]) // eslint-disable-line no-eval\\n  )\\n}\",\"materializeFns\":\"(fnStrObj = { hello: \\\"() => 'world'\\\" }) => {\\n  return Object.fromEntries(\\n    Object.entries(fnStrObj).map(([key, value]) => {\\n      if (value.startsWith('function')) {\\n        // some trickery is needed to make oldschool functions work :-)\\n        return [key, eval(`() => ${value}`)()] // eslint-disable-line no-eval\\n      } else {\\n        // arrow functions just work\\n        return [key, eval(value)] // eslint-disable-line no-eval\\n      }\\n    })\\n  )\\n}\",\"makeHandler\":\"() => ({\\n  // Used by simple `navigator` getter evasions\\n  getterValue: value => ({\\n    apply(target, ctx, args) {\\n      // Let's fetch the value first, to trigger and escalate potential errors\\n      // Illegal invocations like `navigator.__proto__.vendor` will throw here\\n      utils.cache.Reflect.apply(...arguments)\\n      return value\\n    }\\n  })\\n})\",\"arrayEquals\":\"(array1, array2) => {\\n  if (array1.length !== array2.length) {\\n    return false\\n  }\\n  for (let i = 0; i < array1.length; ++i) {\\n    if (array1[i] !== array2[i]) {\\n      return false\\n    }\\n  }\\n  return true\\n}\",\"memoize\":\"fn => {\\n  const cache = []\\n  return function(...args) {\\n    if (!cache.some(c => utils.arrayEquals(c.key, args))) {\\n      cache.push({ key: args, value: fn.apply(this, args) })\\n    }\\n    return cache.find(c => utils.arrayEquals(c.key, args)).value\\n  }\\n}\"},\"_mainFunction\":\"(utils, opts) => {\\n      const getParameterProxyHandler = {\\n        apply: function(target, ctx, args) {\\n          const param = (args || [])[0]\\n          const result = utils.cache.Reflect.apply(target, ctx, args)\\n          // UNMASKED_VENDOR_WEBGL\\n          if (param === 37445) {\\n            return opts.vendor || 'Intel Inc.' // default in headless: Google Inc.\\n          }\\n          // UNMASKED_RENDERER_WEBGL\\n          if (param === 37446) {\\n            return opts.renderer || 'Intel Iris OpenGL Engine' // default in headless: Google SwiftShader\\n          }\\n          return result\\n        }\\n      }\\n\\n      // There's more than one WebGL rendering context\\n      // https://developer.mozilla.org/en-US/docs/Web/API/WebGL2RenderingContext#Browser_compatibility\\n      // To find out the original values here: Object.getOwnPropertyDescriptors(WebGLRenderingContext.prototype.getParameter)\\n      const addProxy = (obj, propName) => {\\n        utils.replaceWithProxy(obj, propName, getParameterProxyHandler)\\n      }\\n      // For whatever weird reason loops don't play nice with Object.defineProperty, here's the next best thing:\\n      addProxy(WebGLRenderingContext.prototype, 'getParameter')\\n      addProxy(WebGL2RenderingContext.prototype, 'getParameter')\\n    }\",\"_args\":[{}]})"},"stack":[{"file":"/home/neetoci/neeto-chat-web/playwright-tests/node_modules/@bigbinary/neeto-playwright-commons/node_modules/playwright-extra/dist/index.esm.js","line":230,"column":32,"function":"Proxy.<anonymous>"}]}
{"type":"before","callId":"pw:api@58","parentId":"hook@2","startTime":92249.34,"class":"Test","method":"step","apiName":"page.addInitScript","params":{"source":"(() => {\n      try {\n        if (window.outerWidth && window.outerHeight) {\n          return // nothing to do here\n        }\n        const windowFrame = 85 // probably OS and WM dependent\n        window.outerWidth = window.innerWidth\n        window.outerHeight = window.innerHeight + windowFrame\n      } catch (err) {}\n    })(undefined)"},"stack":[{"file":"/home/neetoci/neeto-chat-web/playwright-tests/node_modules/@bigbinary/neeto-playwright-commons/node_modules/playwright-extra/dist/index.esm.js","line":230,"column":32,"function":"Proxy.<anonymous>"}]}
{"type":"before","callId":"pw:api@59","parentId":"hook@2","startTime":92250.036,"class":"Test","method":"step","apiName":"page.addInitScript","params":{"source":"(({ _utilsFns, _mainFunction, _args }) => {\n        // Add this point we cannot use our utililty functions as they're just strings, we need to materialize them first\n        const utils = Object.fromEntries(\n          Object.entries(_utilsFns).map(([key, value]) => [key, eval(value)]) // eslint-disable-line no-eval\n        )\n        utils.init()\n        return eval(_mainFunction)(utils, ..._args) // eslint-disable-line no-eval\n      })({\"_utilsFns\":{\"init\":\"() => {\\n  utils.preloadCache()\\n}\",\"stripProxyFromErrors\":\"(handler = {}) => {\\n  const newHandler = {\\n    setPrototypeOf: function (target, proto) {\\n      if (proto === null)\\n        throw new TypeError('Cannot convert object to primitive value')\\n      if (Object.getPrototypeOf(target) === Object.getPrototypeOf(proto)) {\\n        throw new TypeError('Cyclic __proto__ value')\\n      }\\n      return Reflect.setPrototypeOf(target, proto)\\n    }\\n  }\\n  // We wrap each trap in the handler in a try/catch and modify the error stack if they throw\\n  const traps = Object.getOwnPropertyNames(handler)\\n  traps.forEach(trap => {\\n    newHandler[trap] = function () {\\n      try {\\n        // Forward the call to the defined proxy handler\\n        return handler[trap].apply(this, arguments || [])\\n      } catch (err) {\\n        // Stack traces differ per browser, we only support chromium based ones currently\\n        if (!err || !err.stack || !err.stack.includes(`at `)) {\\n          throw err\\n        }\\n\\n        // When something throws within one of our traps the Proxy will show up in error stacks\\n        // An earlier implementation of this code would simply strip lines with a blacklist,\\n        // but it makes sense to be more surgical here and only remove lines related to our Proxy.\\n        // We try to use a known \\\"anchor\\\" line for that and strip it with everything above it.\\n        // If the anchor line cannot be found for some reason we fall back to our blacklist approach.\\n\\n        const stripWithBlacklist = (stack, stripFirstLine = true) => {\\n          const blacklist = [\\n            `at Reflect.${trap} `, // e.g. Reflect.get or Reflect.apply\\n            `at Object.${trap} `, // e.g. Object.get or Object.apply\\n            `at Object.newHandler.<computed> [as ${trap}] ` // caused by this very wrapper :-)\\n          ]\\n          return (\\n            err.stack\\n              .split('\\\\n')\\n              // Always remove the first (file) line in the stack (guaranteed to be our proxy)\\n              .filter((line, index) => !(index === 1 && stripFirstLine))\\n              // Check if the line starts with one of our blacklisted strings\\n              .filter(line => !blacklist.some(bl => line.trim().startsWith(bl)))\\n              .join('\\\\n')\\n          )\\n        }\\n\\n        const stripWithAnchor = (stack, anchor) => {\\n          const stackArr = stack.split('\\\\n')\\n          anchor = anchor || `at Object.newHandler.<computed> [as ${trap}] ` // Known first Proxy line in chromium\\n          const anchorIndex = stackArr.findIndex(line =>\\n            line.trim().startsWith(anchor)\\n          )\\n          if (anchorIndex === -1) {\\n            return false // 404, anchor not found\\n          }\\n          // Strip everything from the top until we reach the anchor line\\n          // Note: We're keeping the 1st line (zero index) as it's unrelated (e.g. `TypeError`)\\n          stackArr.splice(1, anchorIndex)\\n          return stackArr.join('\\\\n')\\n        }\\n\\n        // Special cases due to our nested toString proxies\\n        err.stack = err.stack.replace(\\n          'at Object.toString (',\\n          'at Function.toString ('\\n        )\\n        if ((err.stack || '').includes('at Function.toString (')) {\\n          err.stack = stripWithBlacklist(err.stack, false)\\n          throw err\\n        }\\n\\n        // Try using the anchor method, fallback to blacklist if necessary\\n        err.stack = stripWithAnchor(err.stack) || stripWithBlacklist(err.stack)\\n\\n        throw err // Re-throw our now sanitized error\\n      }\\n    }\\n  })\\n  return newHandler\\n}\",\"stripErrorWithAnchor\":\"(err, anchor) => {\\n  const stackArr = err.stack.split('\\\\n')\\n  const anchorIndex = stackArr.findIndex(line => line.trim().startsWith(anchor))\\n  if (anchorIndex === -1) {\\n    return err // 404, anchor not found\\n  }\\n  // Strip everything from the top until we reach the anchor line (remove anchor line as well)\\n  // Note: We're keeping the 1st line (zero index) as it's unrelated (e.g. `TypeError`)\\n  stackArr.splice(1, anchorIndex)\\n  err.stack = stackArr.join('\\\\n')\\n  return err\\n}\",\"replaceProperty\":\"(obj, propName, descriptorOverrides = {}) => {\\n  return Object.defineProperty(obj, propName, {\\n    // Copy over the existing descriptors (writable, enumerable, configurable, etc)\\n    ...(Object.getOwnPropertyDescriptor(obj, propName) || {}),\\n    // Add our overrides (e.g. value, get())\\n    ...descriptorOverrides\\n  })\\n}\",\"preloadCache\":\"() => {\\n  if (utils.cache) {\\n    return\\n  }\\n  utils.cache = {\\n    // Used in our proxies\\n    Reflect: {\\n      get: Reflect.get.bind(Reflect),\\n      apply: Reflect.apply.bind(Reflect)\\n    },\\n    // Used in `makeNativeString`\\n    nativeToStringStr: Function.toString + '' // => `function toString() { [native code] }`\\n  }\\n}\",\"makeNativeString\":\"(name = '') => {\\n  return utils.cache.nativeToStringStr.replace('toString', name || '')\\n}\",\"patchToString\":\"(obj, str = '') => {\\n  const handler = {\\n    apply: function (target, ctx) {\\n      // This fixes e.g. `HTMLMediaElement.prototype.canPlayType.toString + \\\"\\\"`\\n      if (ctx === Function.prototype.toString) {\\n        return utils.makeNativeString('toString')\\n      }\\n      // `toString` targeted at our proxied Object detected\\n      if (ctx === obj) {\\n        // We either return the optional string verbatim or derive the most desired result automatically\\n        return str || utils.makeNativeString(obj.name)\\n      }\\n      // Check if the toString protype of the context is the same as the global prototype,\\n      // if not indicates that we are doing a check across different windows., e.g. the iframeWithdirect` test case\\n      const hasSameProto = Object.getPrototypeOf(\\n        Function.prototype.toString\\n      ).isPrototypeOf(ctx.toString) // eslint-disable-line no-prototype-builtins\\n      if (!hasSameProto) {\\n        // Pass the call on to the local Function.prototype.toString instead\\n        return ctx.toString()\\n      }\\n      return target.call(ctx)\\n    }\\n  }\\n\\n  const toStringProxy = new Proxy(\\n    Function.prototype.toString,\\n    utils.stripProxyFromErrors(handler)\\n  )\\n  utils.replaceProperty(Function.prototype, 'toString', {\\n    value: toStringProxy\\n  })\\n}\",\"patchToStringNested\":\"(obj = {}) => {\\n  return utils.execRecursively(obj, ['function'], utils.patchToString)\\n}\",\"redirectToString\":\"(proxyObj, originalObj) => {\\n  const handler = {\\n    apply: function (target, ctx) {\\n      // This fixes e.g. `HTMLMediaElement.prototype.canPlayType.toString + \\\"\\\"`\\n      if (ctx === Function.prototype.toString) {\\n        return utils.makeNativeString('toString')\\n      }\\n\\n      // `toString` targeted at our proxied Object detected\\n      if (ctx === proxyObj) {\\n        const fallback = () =>\\n          originalObj && originalObj.name\\n            ? utils.makeNativeString(originalObj.name)\\n            : utils.makeNativeString(proxyObj.name)\\n\\n        // Return the toString representation of our original object if possible\\n        return originalObj + '' || fallback()\\n      }\\n\\n      if (typeof ctx === 'undefined' || ctx === null) {\\n        return target.call(ctx)\\n      }\\n\\n      // Check if the toString protype of the context is the same as the global prototype,\\n      // if not indicates that we are doing a check across different windows., e.g. the iframeWithdirect` test case\\n      const hasSameProto = Object.getPrototypeOf(\\n        Function.prototype.toString\\n      ).isPrototypeOf(ctx.toString) // eslint-disable-line no-prototype-builtins\\n      if (!hasSameProto) {\\n        // Pass the call on to the local Function.prototype.toString instead\\n        return ctx.toString()\\n      }\\n\\n      return target.call(ctx)\\n    }\\n  }\\n\\n  const toStringProxy = new Proxy(\\n    Function.prototype.toString,\\n    utils.stripProxyFromErrors(handler)\\n  )\\n  utils.replaceProperty(Function.prototype, 'toString', {\\n    value: toStringProxy\\n  })\\n}\",\"replaceWithProxy\":\"(obj, propName, handler) => {\\n  const originalObj = obj[propName]\\n  const proxyObj = new Proxy(obj[propName], utils.stripProxyFromErrors(handler))\\n\\n  utils.replaceProperty(obj, propName, { value: proxyObj })\\n  utils.redirectToString(proxyObj, originalObj)\\n\\n  return true\\n}\",\"replaceGetterWithProxy\":\"(obj, propName, handler) => {\\n  const fn = Object.getOwnPropertyDescriptor(obj, propName).get\\n  const fnStr = fn.toString() // special getter function string\\n  const proxyObj = new Proxy(fn, utils.stripProxyFromErrors(handler))\\n\\n  utils.replaceProperty(obj, propName, { get: proxyObj })\\n  utils.patchToString(proxyObj, fnStr)\\n\\n  return true\\n}\",\"replaceGetterSetter\":\"(obj, propName, handlerGetterSetter) => {\\n  const ownPropertyDescriptor = Object.getOwnPropertyDescriptor(obj, propName)\\n  const handler = { ...ownPropertyDescriptor }\\n\\n  if (handlerGetterSetter.get !== undefined) {\\n    const nativeFn = ownPropertyDescriptor.get\\n    handler.get = function() {\\n      return handlerGetterSetter.get.call(this, nativeFn.bind(this))\\n    }\\n    utils.redirectToString(handler.get, nativeFn)\\n  }\\n\\n  if (handlerGetterSetter.set !== undefined) {\\n    const nativeFn = ownPropertyDescriptor.set\\n    handler.set = function(newValue) {\\n      handlerGetterSetter.set.call(this, newValue, nativeFn.bind(this))\\n    }\\n    utils.redirectToString(handler.set, nativeFn)\\n  }\\n\\n  Object.defineProperty(obj, propName, handler)\\n}\",\"mockWithProxy\":\"(obj, propName, pseudoTarget, handler) => {\\n  const proxyObj = new Proxy(pseudoTarget, utils.stripProxyFromErrors(handler))\\n\\n  utils.replaceProperty(obj, propName, { value: proxyObj })\\n  utils.patchToString(proxyObj)\\n\\n  return true\\n}\",\"createProxy\":\"(pseudoTarget, handler) => {\\n  const proxyObj = new Proxy(pseudoTarget, utils.stripProxyFromErrors(handler))\\n  utils.patchToString(proxyObj)\\n\\n  return proxyObj\\n}\",\"splitObjPath\":\"objPath => ({\\n  // Remove last dot entry (property) ==> `HTMLMediaElement.prototype`\\n  objName: objPath.split('.').slice(0, -1).join('.'),\\n  // Extract last dot entry ==> `canPlayType`\\n  propName: objPath.split('.').slice(-1)[0]\\n})\",\"replaceObjPathWithProxy\":\"(objPath, handler) => {\\n  const { objName, propName } = utils.splitObjPath(objPath)\\n  const obj = eval(objName) // eslint-disable-line no-eval\\n  return utils.replaceWithProxy(obj, propName, handler)\\n}\",\"execRecursively\":\"(obj = {}, typeFilter = [], fn) => {\\n  function recurse(obj) {\\n    for (const key in obj) {\\n      if (obj[key] === undefined) {\\n        continue\\n      }\\n      if (obj[key] && typeof obj[key] === 'object') {\\n        recurse(obj[key])\\n      } else {\\n        if (obj[key] && typeFilter.includes(typeof obj[key])) {\\n          fn.call(this, obj[key])\\n        }\\n      }\\n    }\\n  }\\n  recurse(obj)\\n  return obj\\n}\",\"stringifyFns\":\"(fnObj = { hello: () => 'world' }) => {\\n  // Object.fromEntries() ponyfill (in 6 lines) - supported only in Node v12+, modern browsers are fine\\n  // https://github.com/feross/fromentries\\n  function fromEntries(iterable) {\\n    return [...iterable].reduce((obj, [key, val]) => {\\n      obj[key] = val\\n      return obj\\n    }, {})\\n  }\\n  return (Object.fromEntries || fromEntries)(\\n    Object.entries(fnObj)\\n      .filter(([key, value]) => typeof value === 'function')\\n      .map(([key, value]) => [key, value.toString()]) // eslint-disable-line no-eval\\n  )\\n}\",\"materializeFns\":\"(fnStrObj = { hello: \\\"() => 'world'\\\" }) => {\\n  return Object.fromEntries(\\n    Object.entries(fnStrObj).map(([key, value]) => {\\n      if (value.startsWith('function')) {\\n        // some trickery is needed to make oldschool functions work :-)\\n        return [key, eval(`() => ${value}`)()] // eslint-disable-line no-eval\\n      } else {\\n        // arrow functions just work\\n        return [key, eval(value)] // eslint-disable-line no-eval\\n      }\\n    })\\n  )\\n}\",\"makeHandler\":\"() => ({\\n  // Used by simple `navigator` getter evasions\\n  getterValue: value => ({\\n    apply(target, ctx, args) {\\n      // Let's fetch the value first, to trigger and escalate potential errors\\n      // Illegal invocations like `navigator.__proto__.vendor` will throw here\\n      utils.cache.Reflect.apply(...arguments)\\n      return value\\n    }\\n  })\\n})\",\"arrayEquals\":\"(array1, array2) => {\\n  if (array1.length !== array2.length) {\\n    return false\\n  }\\n  for (let i = 0; i < array1.length; ++i) {\\n    if (array1[i] !== array2[i]) {\\n      return false\\n    }\\n  }\\n  return true\\n}\",\"memoize\":\"fn => {\\n  const cache = []\\n  return function(...args) {\\n    if (!cache.some(c => utils.arrayEquals(c.key, args))) {\\n      cache.push({ key: args, value: fn.apply(this, args) })\\n    }\\n    return cache.find(c => utils.arrayEquals(c.key, args)).value\\n  }\\n}\"},\"_mainFunction\":\"(utils, opts) => {\\n      try {\\n        // Adds a contentWindow proxy to the provided iframe element\\n        const addContentWindowProxy = iframe => {\\n          const contentWindowProxy = {\\n            get(target, key) {\\n              // Now to the interesting part:\\n              // We actually make this thing behave like a regular iframe window,\\n              // by intercepting calls to e.g. `.self` and redirect it to the correct thing. :)\\n              // That makes it possible for these assertions to be correct:\\n              // iframe.contentWindow.self === window.top // must be false\\n              if (key === 'self') {\\n                return this\\n              }\\n              // iframe.contentWindow.frameElement === iframe // must be true\\n              if (key === 'frameElement') {\\n                return iframe\\n              }\\n              // Intercept iframe.contentWindow[0] to hide the property 0 added by the proxy.\\n              if (key === '0') {\\n                return undefined\\n              }\\n              return Reflect.get(target, key)\\n            }\\n          }\\n\\n          if (!iframe.contentWindow) {\\n            const proxy = new Proxy(window, contentWindowProxy)\\n            Object.defineProperty(iframe, 'contentWindow', {\\n              get() {\\n                return proxy\\n              },\\n              set(newValue) {\\n                return newValue // contentWindow is immutable\\n              },\\n              enumerable: true,\\n              configurable: false\\n            })\\n          }\\n        }\\n\\n        // Handles iframe element creation, augments `srcdoc` property so we can intercept further\\n        const handleIframeCreation = (target, thisArg, args) => {\\n          const iframe = target.apply(thisArg, args)\\n\\n          // We need to keep the originals around\\n          const _iframe = iframe\\n          const _srcdoc = _iframe.srcdoc\\n\\n          // Add hook for the srcdoc property\\n          // We need to be very surgical here to not break other iframes by accident\\n          Object.defineProperty(iframe, 'srcdoc', {\\n            configurable: true, // Important, so we can reset this later\\n            get: function() {\\n              return _srcdoc\\n            },\\n            set: function(newValue) {\\n              addContentWindowProxy(this)\\n              // Reset property, the hook is only needed once\\n              Object.defineProperty(iframe, 'srcdoc', {\\n                configurable: false,\\n                writable: false,\\n                value: _srcdoc\\n              })\\n              _iframe.srcdoc = newValue\\n            }\\n          })\\n          return iframe\\n        }\\n\\n        // Adds a hook to intercept iframe creation events\\n        const addIframeCreationSniffer = () => {\\n          /* global document */\\n          const createElementHandler = {\\n            // Make toString() native\\n            get(target, key) {\\n              return Reflect.get(target, key)\\n            },\\n            apply: function(target, thisArg, args) {\\n              const isIframe =\\n                args && args.length && `${args[0]}`.toLowerCase() === 'iframe'\\n              if (!isIframe) {\\n                // Everything as usual\\n                return target.apply(thisArg, args)\\n              } else {\\n                return handleIframeCreation(target, thisArg, args)\\n              }\\n            }\\n          }\\n          // All this just due to iframes with srcdoc bug\\n          utils.replaceWithProxy(\\n            document,\\n            'createElement',\\n            createElementHandler\\n          )\\n        }\\n\\n        // Let's go\\n        addIframeCreationSniffer()\\n      } catch (err) {\\n        // console.warn(err)\\n      }\\n    }\",\"_args\":[]})"},"stack":[{"file":"/home/neetoci/neeto-chat-web/playwright-tests/node_modules/@bigbinary/neeto-playwright-commons/node_modules/playwright-extra/dist/index.esm.js","line":230,"column":32,"function":"Proxy.<anonymous>"}]}
{"type":"after","callId":"pw:api@45","endTime":92250.175,"annotations":[]}
{"type":"before","callId":"pw:api@60","parentId":"test.step@44","startTime":92255.488,"class":"Test","method":"step","apiName":"page.goto","params":{"url":"about:blank","waitUntil":"load"},"stack":[{"file":"/home/neetoci/neeto-chat-web/playwright-tests/node_modules/@bigbinary/neeto-playwright-commons/node_modules/playwright-extra/dist/index.esm.js","line":779,"column":28,"function":"BrowserContext.newPage"}]}
{"type":"after","callId":"pw:api@46","endTime":92346.585,"annotations":[]}
{"type":"after","callId":"pw:api@47","endTime":92346.625,"annotations":[]}
{"type":"after","callId":"pw:api@48","endTime":92346.658,"annotations":[]}
{"type":"after","callId":"pw:api@49","endTime":92346.685,"annotations":[]}
{"type":"after","callId":"pw:api@50","endTime":92346.713,"annotations":[]}
{"type":"after","callId":"pw:api@51","endTime":92346.75,"annotations":[]}
{"type":"after","callId":"pw:api@52","endTime":92346.801,"annotations":[]}
{"type":"after","callId":"pw:api@53","endTime":92346.854,"annotations":[]}
{"type":"after","callId":"pw:api@54","endTime":92346.89,"annotations":[]}
{"type":"after","callId":"pw:api@55","endTime":92346.924,"annotations":[]}
{"type":"after","callId":"pw:api@56","endTime":92346.967,"annotations":[]}
{"type":"before","callId":"pw:api@61","parentId":"hook@2","startTime":92348.027,"class":"Test","method":"step","apiName":"browserContext.newCDPSession","params":{"page":"Object"},"stack":[{"file":"/home/neetoci/neeto-chat-web/playwright-tests/node_modules/@bigbinary/neeto-playwright-commons/node_modules/playwright-extra/dist/index.esm.js","line":148,"column":33,"function":"getPageCDPSession"}]}
{"type":"after","callId":"pw:api@57","endTime":92348.145,"annotations":[]}
{"type":"after","callId":"pw:api@58","endTime":92348.181,"annotations":[]}
{"type":"after","callId":"pw:api@59","endTime":92348.209,"annotations":[]}
{"type":"after","callId":"pw:api@61","endTime":92349.413,"annotations":[]}
{"type":"before","callId":"pw:api@62","parentId":"hook@2","startTime":92349.971,"class":"Test","method":"step","apiName":"cdpSession.send","params":{"method":"Network.setUserAgentOverride","params":"Object"},"stack":[{"file":"/home/neetoci/neeto-chat-web/playwright-tests/node_modules/@bigbinary/neeto-playwright-commons/node_modules/playwright-extra/dist/index.esm.js","line":188,"column":46,"function":"Object.send"}]}
{"type":"after","callId":"pw:api@62","endTime":92421.439,"annotations":[]}
{"type":"after","callId":"pw:api@60","endTime":92424.964,"annotations":[]}
{"type":"before","callId":"pw:api@63","parentId":"test.step@44","startTime":92426.916,"class":"Test","method":"step","apiName":"page.goto","params":{"url":"https://aquamarineaquarium.slack.com/sign_in_with_password","timeout":"20000","waitUntil":"load"},"stack":[{"file":"/home/neetoci/neeto-chat-web/playwright-tests/node_modules/@bigbinary/neeto-playwright-commons/build/compiled/poms/integrations/slack.js","line":117,"column":39,"function":"SlackPage.loginToSlackWebapp"}]}
{"type":"after","callId":"pw:api@63","endTime":95711.267,"annotations":[]}
{"type":"before","callId":"pw:api@64","parentId":"test.step@44","startTime":95713.223,"class":"Test","method":"step","apiName":"page.waitForLoadState","params":{"info":"Object"},"stack":[{"file":"/home/neetoci/neeto-chat-web/playwright-tests/node_modules/@bigbinary/neeto-playwright-commons/build/compiled/poms/integrations/slack.js","line":118,"column":39,"function":"SlackPage.loginToSlackWebapp"}]}
{"type":"after","callId":"pw:api@64","endTime":95713.892,"annotations":[]}
{"type":"before","callId":"pw:api@65","parentId":"test.step@44","startTime":95715.398,"class":"Test","method":"step","apiName":"locator.pressSequentially","params":{"selector":"[data-qa='login_email']","text":"neeto-chat-slack@ymn2s6kt.mailosaur.net","strict":"true","delay":"10"},"stack":[{"file":"/home/neetoci/neeto-chat-web/playwright-tests/node_modules/@bigbinary/neeto-playwright-commons/build/compiled/poms/integrations/slack.js","line":121,"column":22,"function":"SlackPage.loginToSlackWebapp"}]}
{"type":"after","callId":"pw:api@65","endTime":97638.651,"annotations":[]}
{"type":"before","callId":"pw:api@66","parentId":"test.step@44","startTime":97640.449,"class":"Test","method":"step","apiName":"locator.pressSequentially","params":{"selector":"[data-qa='login_password']","text":"Jp349HyGBsrs8Gr","strict":"true","delay":"10"},"stack":[{"file":"/home/neetoci/neeto-chat-web/playwright-tests/node_modules/@bigbinary/neeto-playwright-commons/build/compiled/poms/integrations/slack.js","line":124,"column":22,"function":"SlackPage.loginToSlackWebapp"}]}
{"type":"after","callId":"pw:api@66","endTime":98245.708,"annotations":[]}
{"type":"before","callId":"pw:api@67","parentId":"test.step@44","startTime":98247.272,"class":"Test","method":"step","apiName":"locator.click","params":{"selector":"[data-qa='signin_button']","strict":"true"},"stack":[{"file":"/home/neetoci/neeto-chat-web/playwright-tests/node_modules/@bigbinary/neeto-playwright-commons/build/compiled/poms/integrations/slack.js","line":125,"column":77,"function":"SlackPage.loginToSlackWebapp"}]}
{"type":"after","callId":"pw:api@67","endTime":99235.718,"annotations":[]}
{"type":"before","callId":"pw:api@68","parentId":"test.step@44","startTime":99237.757,"class":"Test","method":"step","apiName":"page.waitForLoadState","params":{"info":"Object"},"stack":[{"file":"/home/neetoci/neeto-chat-web/playwright-tests/node_modules/@bigbinary/neeto-playwright-commons/build/compiled/poms/integrations/slack.js","line":126,"column":39,"function":"SlackPage.loginToSlackWebapp"}]}
{"type":"after","callId":"pw:api@68","endTime":102316.473,"annotations":[]}
{"type":"before","callId":"expect@69","parentId":"test.step@44","startTime":102319.008,"class":"Test","method":"step","apiName":"expect.toBeVisible","params":{"expected":"Object"},"stack":[{"file":"/home/neetoci/neeto-chat-web/playwright-tests/node_modules/@bigbinary/neeto-playwright-commons/build/compiled/poms/integrations/slack.js","line":130,"column":53,"function":"SlackPage.loginToSlackWebapp"}]}
{"type":"after","callId":"expect@69","endTime":105332.581,"annotations":[]}
{"type":"before","callId":"pw:api@70","parentId":"test.step@44","startTime":105335.014,"class":"Test","method":"step","apiName":"locator.click","params":{"selector":"[data-qa='ssb_redirect_open_in_browser']","strict":"true"},"stack":[{"file":"/home/neetoci/neeto-chat-web/playwright-tests/node_modules/@bigbinary/neeto-playwright-commons/build/compiled/poms/integrations/slack.js","line":131,"column":45,"function":"SlackPage.loginToSlackWebapp"}]}
{"type":"after","callId":"pw:api@70","endTime":105853.369,"annotations":[]}
{"type":"before","callId":"pw:api@71","parentId":"test.step@44","startTime":105855.171,"class":"Test","method":"step","apiName":"page.addLocatorHandler","params":{"selector":"[data-qa='coachmark-close-button']","noWaitAfter":"undefined"},"stack":[{"file":"/home/neetoci/neeto-chat-web/playwright-tests/node_modules/@bigbinary/neeto-playwright-commons/build/compiled/poms/integrations/slack.js","line":20,"column":35,"function":"SlackPage.setupCloseHandlers"}]}
{"type":"after","callId":"pw:api@71","endTime":105857.8,"annotations":[]}
{"type":"before","callId":"pw:api@72","parentId":"test.step@44","startTime":105859.71,"class":"Test","method":"step","apiName":"page.addLocatorHandler","params":{"selector":"[data-qa='message_pane_banner_close_icon']","noWaitAfter":"undefined"},"stack":[{"file":"/home/neetoci/neeto-chat-web/playwright-tests/node_modules/@bigbinary/neeto-playwright-commons/build/compiled/poms/integrations/slack.js","line":21,"column":35,"function":"SlackPage.setupCloseHandlers"}]}
{"type":"after","callId":"pw:api@72","endTime":105919.688,"annotations":[]}
{"type":"before","callId":"pw:api@73","parentId":"test.step@44","startTime":105921.438,"class":"Test","method":"step","apiName":"page.addLocatorHandler","params":{"selector":"[data-qa='banner_close_btn']","noWaitAfter":"true"},"stack":[{"file":"/home/neetoci/neeto-chat-web/playwright-tests/node_modules/@bigbinary/neeto-playwright-commons/build/compiled/poms/integrations/slack.js","line":23,"column":35,"function":"SlackPage.setupCloseHandlers"}]}
{"type":"after","callId":"pw:api@73","endTime":105926.355,"annotations":[]}
{"type":"after","callId":"test.step@44","endTime":105926.465,"annotations":[]}
{"type":"before","callId":"test.step@74","parentId":"hook@2","startTime":105926.98,"class":"Test","method":"step","apiName":"Step 3: Connect Slack integration and verify","params":{},"stack":[{"file":"/home/neetoci/neeto-chat-web/playwright-tests/e2e/tests/integrations/slack.spec.ts","line":42,"column":18}]}
{"type":"before","callId":"pw:api@75","parentId":"test.step@74","startTime":105928.822,"class":"Test","method":"step","apiName":"page.goto","params":{"url":"/admin/admin-panel","timeout":"20000","waitUntil":"load"},"stack":[{"file":"/home/neetoci/neeto-chat-web/playwright-tests/node_modules/@bigbinary/neeto-playwright-commons/build/compiled/poms/integrations/integrationBase.js","line":48,"column":33,"function":"SlackPage.IntegrationBase.gotoIntegrationIndex"}]}
{"type":"after","callId":"pw:api@75","endTime":108725.293,"annotations":[]}
{"type":"before","callId":"pw:api@76","parentId":"test.step@74","startTime":108727.854,"class":"Test","method":"step","apiName":"page.waitForLoadState","params":{"info":"Object"},"stack":[{"file":"/home/neetoci/neeto-chat-web/playwright-tests/node_modules/@bigbinary/neeto-playwright-commons/build/compiled/utils/commands.js","line":85,"column":31,"function":"CustomCommands.waitForPageLoad"}]}
{"type":"after","callId":"pw:api@76","endTime":108728.317,"annotations":[]}
{"type":"before","callId":"expect@77","parentId":"test.step@74","startTime":108742.958,"class":"Test","method":"step","apiName":"expect.toHaveCount","params":{},"stack":[{"file":"/home/neetoci/neeto-chat-web/playwright-tests/node_modules/@bigbinary/neeto-playwright-commons/build/compiled/utils/commands.js","line":87,"column":78,"function":"CustomCommands.waitForPageLoad"}]}
{"type":"before","callId":"expect@78","parentId":"test.step@74","startTime":108746.708,"class":"Test","method":"step","apiName":"expect.toHaveCount","params":{},"stack":[{"file":"/home/neetoci/neeto-chat-web/playwright-tests/node_modules/@bigbinary/neeto-playwright-commons/build/compiled/utils/commands.js","line":90,"column":77,"function":"CustomCommands.waitForPageLoad"}]}
{"type":"after","callId":"expect@77","endTime":109113.839,"annotations":[]}
{"type":"after","callId":"expect@78","endTime":109927.572,"annotations":[]}
{"type":"before","callId":"pw:api@79","parentId":"test.step@74","startTime":109948.156,"class":"Test","method":"step","apiName":"page.waitForLoadState","params":{"info":"Object"},"stack":[{"file":"/home/neetoci/neeto-chat-web/playwright-tests/node_modules/@bigbinary/neeto-playwright-commons/build/compiled/utils/commands.js","line":85,"column":31,"function":"CustomCommands.waitForPageLoad"}]}
{"type":"after","callId":"pw:api@79","endTime":109948.561,"annotations":[]}
{"type":"before","callId":"expect@80","parentId":"test.step@74","startTime":109949.862,"class":"Test","method":"step","apiName":"expect.toHaveCount","params":{},"stack":[{"file":"/home/neetoci/neeto-chat-web/playwright-tests/node_modules/@bigbinary/neeto-playwright-commons/build/compiled/utils/commands.js","line":87,"column":78,"function":"CustomCommands.waitForPageLoad"}]}
{"type":"before","callId":"expect@81","parentId":"test.step@74","startTime":109952.024,"class":"Test","method":"step","apiName":"expect.toHaveCount","params":{},"stack":[{"file":"/home/neetoci/neeto-chat-web/playwright-tests/node_modules/@bigbinary/neeto-playwright-commons/build/compiled/utils/commands.js","line":90,"column":77,"function":"CustomCommands.waitForPageLoad"}]}
{"type":"after","callId":"expect@80","endTime":110058.08,"annotations":[]}
{"type":"after","callId":"expect@81","endTime":110058.292,"annotations":[]}
{"type":"before","callId":"pw:api@82","parentId":"test.step@74","startTime":110114.689,"class":"Test","method":"step","apiName":"locator.scrollIntoViewIfNeeded","params":{"selector":"internal:testid=[data-cy=\"slack-integration-card\"s]","strict":"true","state":"attached","timeout":"10000"},"stack":[{"file":"/home/neetoci/neeto-chat-web/playwright-tests/node_modules/@bigbinary/neeto-playwright-commons/build/compiled/poms/integrations/integrationBase.js","line":40,"column":40,"function":"SlackPage.IntegrationBase.clickOnIntegrationCard"}]}
{"type":"after","callId":"pw:api@82","endTime":110359.278,"annotations":[]}
{"type":"before","callId":"pw:api@83","parentId":"test.step@74","startTime":110360.954,"class":"Test","method":"step","apiName":"locator.click","params":{"selector":"internal:testid=[data-cy=\"slack-integration-card\"s]","strict":"true"},"stack":[{"file":"/home/neetoci/neeto-chat-web/playwright-tests/node_modules/@bigbinary/neeto-playwright-commons/build/compiled/poms/integrations/integrationBase.js","line":41,"column":40,"function":"SlackPage.IntegrationBase.clickOnIntegrationCard"}]}
{"type":"after","callId":"pw:api@83","endTime":111016.741,"annotations":[]}
{"type":"before","callId":"pw:api@84","parentId":"test.step@74","startTime":111018.596,"class":"Test","method":"step","apiName":"page.waitForLoadState","params":{"info":"Object"},"stack":[{"file":"/home/neetoci/neeto-chat-web/playwright-tests/node_modules/@bigbinary/neeto-playwright-commons/build/compiled/utils/commands.js","line":85,"column":31,"function":"CustomCommands.waitForPageLoad"}]}
{"type":"after","callId":"pw:api@84","endTime":111019.005,"annotations":[]}
{"type":"before","callId":"expect@85","parentId":"test.step@74","startTime":111020.21,"class":"Test","method":"step","apiName":"expect.toHaveCount","params":{},"stack":[{"file":"/home/neetoci/neeto-chat-web/playwright-tests/node_modules/@bigbinary/neeto-playwright-commons/build/compiled/utils/commands.js","line":87,"column":78,"function":"CustomCommands.waitForPageLoad"}]}
{"type":"before","callId":"expect@86","parentId":"test.step@74","startTime":111029.652,"class":"Test","method":"step","apiName":"expect.toHaveCount","params":{},"stack":[{"file":"/home/neetoci/neeto-chat-web/playwright-tests/node_modules/@bigbinary/neeto-playwright-commons/build/compiled/utils/commands.js","line":90,"column":77,"function":"CustomCommands.waitForPageLoad"}]}
{"type":"after","callId":"expect@85","endTime":111050.685,"annotations":[]}
{"type":"after","callId":"expect@86","endTime":111052.557,"annotations":[]}
{"type":"before","callId":"expect@87","parentId":"test.step@74","startTime":111058.242,"class":"Test","method":"step","apiName":"expect.toBeVisible","params":{},"stack":[{"file":"/home/neetoci/neeto-chat-web/playwright-tests/node_modules/@bigbinary/neeto-playwright-commons/build/compiled/poms/integrations/integrationBase.js","line":24,"column":17,"function":"SlackPage.IntegrationBase.connect"}]}
{"type":"after","callId":"expect@87","endTime":111136.856,"annotations":[]}
{"type":"before","callId":"pw:api@88","parentId":"test.step@74","startTime":111138.234,"class":"Test","method":"step","apiName":"locator.click","params":{"selector":"internal:testid=[data-cy=\"connect-button\"s]","strict":"true"},"stack":[{"file":"/home/neetoci/neeto-chat-web/playwright-tests/node_modules/@bigbinary/neeto-playwright-commons/build/compiled/poms/integrations/integrationBase.js","line":25,"column":78,"function":"SlackPage.IntegrationBase.connect"}]}
{"type":"after","callId":"pw:api@88","endTime":121147.321,"annotations":[],"error":{"name":"","message":"TimeoutError: locator.click: Timeout 10000ms exceeded.\nCall log:\n\u001b[2m  - waiting for getByTestId('connect-button')\u001b[22m\n","stack":"TimeoutError: locator.click: Timeout 10000ms exceeded.\nCall log:\n\u001b[2m  - waiting for getByTestId('connect-button')\u001b[22m\n\n    at SlackPage.IntegrationBase.connect (/home/neetoci/neeto-chat-web/playwright-tests/node_modules/@bigbinary/neeto-playwright-commons/build/compiled/poms/integrations/integrationBase.js:25:78)\n    at SlackPage.connectAndVerifyIntegration (/home/neetoci/neeto-chat-web/playwright-tests/node_modules/@bigbinary/neeto-playwright-commons/build/compiled/poms/integrations/slack.js:29:13)\n    at /home/neetoci/neeto-chat-web/playwright-tests/e2e/tests/integrations/slack.spec.ts:57:11\n    at /home/neetoci/neeto-chat-web/playwright-tests/e2e/tests/integrations/slack.spec.ts:42:7"}}
{"type":"after","callId":"test.step@74","endTime":121147.639,"annotations":[],"error":{"name":"","message":"TimeoutError: locator.click: Timeout 10000ms exceeded.\nCall log:\n\u001b[2m  - waiting for getByTestId('connect-button')\u001b[22m\n","stack":"TimeoutError: locator.click: Timeout 10000ms exceeded.\nCall log:\n\u001b[2m  - waiting for getByTestId('connect-button')\u001b[22m\n\n    at SlackPage.IntegrationBase.connect (/home/neetoci/neeto-chat-web/playwright-tests/node_modules/@bigbinary/neeto-playwright-commons/build/compiled/poms/integrations/integrationBase.js:25:78)\n    at SlackPage.connectAndVerifyIntegration (/home/neetoci/neeto-chat-web/playwright-tests/node_modules/@bigbinary/neeto-playwright-commons/build/compiled/poms/integrations/slack.js:29:13)\n    at /home/neetoci/neeto-chat-web/playwright-tests/e2e/tests/integrations/slack.spec.ts:57:11\n    at /home/neetoci/neeto-chat-web/playwright-tests/e2e/tests/integrations/slack.spec.ts:42:7"}}
{"type":"error","message":"TimeoutError: locator.click: Timeout 10000ms exceeded.\nCall log:\n\u001b[2m  - waiting for getByTestId('connect-button')\u001b[22m\n","stack":[{"file":"/home/neetoci/neeto-chat-web/playwright-tests/node_modules/@bigbinary/neeto-playwright-commons/build/compiled/poms/integrations/integrationBase.js","line":25,"column":78,"function":"SlackPage.IntegrationBase.connect"},{"file":"/home/neetoci/neeto-chat-web/playwright-tests/node_modules/@bigbinary/neeto-playwright-commons/build/compiled/poms/integrations/slack.js","line":29,"column":13,"function":"SlackPage.connectAndVerifyIntegration"},{"file":"/home/neetoci/neeto-chat-web/playwright-tests/e2e/tests/integrations/slack.spec.ts","line":57,"column":11},{"file":"/home/neetoci/neeto-chat-web/playwright-tests/e2e/tests/integrations/slack.spec.ts","line":42,"column":7}]}
{"type":"after","callId":"hook@2","endTime":121148.003,"annotations":[],"error":{"name":"","message":"TimeoutError: locator.click: Timeout 10000ms exceeded.\nCall log:\n\u001b[2m  - waiting for getByTestId('connect-button')\u001b[22m\n","stack":"TimeoutError: locator.click: Timeout 10000ms exceeded.\nCall log:\n\u001b[2m  - waiting for getByTestId('connect-button')\u001b[22m\n\n    at SlackPage.IntegrationBase.connect (/home/neetoci/neeto-chat-web/playwright-tests/node_modules/@bigbinary/neeto-playwright-commons/build/compiled/poms/integrations/integrationBase.js:25:78)\n    at SlackPage.connectAndVerifyIntegration (/home/neetoci/neeto-chat-web/playwright-tests/node_modules/@bigbinary/neeto-playwright-commons/build/compiled/poms/integrations/slack.js:29:13)\n    at /home/neetoci/neeto-chat-web/playwright-tests/e2e/tests/integrations/slack.spec.ts:57:11\n    at /home/neetoci/neeto-chat-web/playwright-tests/e2e/tests/integrations/slack.spec.ts:42:7"}}
{"type":"after","callId":"hook@1","endTime":121148.132,"annotations":[],"error":{"name":"","message":"TimeoutError: locator.click: Timeout 10000ms exceeded.\nCall log:\n\u001b[2m  - waiting for getByTestId('connect-button')\u001b[22m\n","stack":"TimeoutError: locator.click: Timeout 10000ms exceeded.\nCall log:\n\u001b[2m  - waiting for getByTestId('connect-button')\u001b[22m\n\n    at SlackPage.IntegrationBase.connect (/home/neetoci/neeto-chat-web/playwright-tests/node_modules/@bigbinary/neeto-playwright-commons/build/compiled/poms/integrations/integrationBase.js:25:78)\n    at SlackPage.connectAndVerifyIntegration (/home/neetoci/neeto-chat-web/playwright-tests/node_modules/@bigbinary/neeto-playwright-commons/build/compiled/poms/integrations/slack.js:29:13)\n    at /home/neetoci/neeto-chat-web/playwright-tests/e2e/tests/integrations/slack.spec.ts:57:11\n    at /home/neetoci/neeto-chat-web/playwright-tests/e2e/tests/integrations/slack.spec.ts:42:7"}}
{"type":"before","callId":"hook@89","startTime":121148.567,"class":"Test","method":"step","apiName":"After Hooks","params":{},"stack":[]}
{"type":"before","callId":"pw:api@90","parentId":"hook@89","startTime":121150.563,"class":"Test","method":"step","apiName":"page.screenshot","params":{"timeout":"5000","path":"/home/neetoci/neeto-chat-web/playwright-tests/test-results/integrations-slack-Verify--54bf8-is-send-via-automation-rule-chromium-retry1/test-failed-1.png","caret":"initial","mask":"undefined","type":"png"},"stack":[]}
{"type":"before","callId":"pw:api@91","parentId":"hook@89","startTime":121151.711,"class":"Test","method":"step","apiName":"page.screenshot","params":{"timeout":"5000","path":"/home/neetoci/neeto-chat-web/playwright-tests/test-results/integrations-slack-Verify--54bf8-is-send-via-automation-rule-chromium-retry1/test-failed-2.png","caret":"initial","mask":"undefined","type":"png"},"stack":[]}
{"type":"after","callId":"pw:api@90","endTime":121325.529,"annotations":[]}
{"type":"after","callId":"pw:api@91","endTime":121629.79,"annotations":[]}
{"type":"before","callId":"hook@92","parentId":"hook@89","startTime":121630.724,"class":"Test","method":"step","apiName":"afterEach hook","params":{},"stack":[{"file":"/home/neetoci/neeto-chat-web/playwright-tests/e2e/tests/integrations/slack.spec.ts","line":76,"column":8}]}
{"type":"before","callId":"fixture@93","parentId":"hook@92","startTime":121631.416,"class":"Test","method":"step","apiName":"fixture: conversationsApis","params":{},"stack":[{"file":"/home/neetoci/neeto-chat-web/playwright-tests/e2e/fixtures/index.ts","line":9,"column":4}]}
{"type":"after","callId":"fixture@93","endTime":121631.823,"annotations":[]}
{"type":"before","callId":"fixture@94","parentId":"hook@92","startTime":121632.119,"class":"Test","method":"step","apiName":"fixture: conversationsPage","params":{},"stack":[{"file":"/home/neetoci/neeto-chat-web/playwright-tests/e2e/fixtures/index.ts","line":9,"column":4}]}
{"type":"after","callId":"fixture@94","endTime":121632.736,"annotations":[]}
{"type":"before","callId":"pw:api@95","parentId":"hook@92","startTime":121633.791,"class":"Test","method":"step","apiName":"page.goto","params":{"url":"/admin/admin-panel","waitUntil":"load"},"stack":[{"file":"/home/neetoci/neeto-chat-web/playwright-tests/e2e/tests/integrations/slack.spec.ts","line":84,"column":18}]}
{"type":"after","callId":"pw:api@95","endTime":124113.297,"annotations":[]}
{"type":"before","callId":"expect@96","parentId":"hook@92","startTime":124116.722,"class":"Test","method":"step","apiName":"expect.toBeHidden","params":{"expected":"Object"},"stack":[{"file":"/home/neetoci/neeto-chat-web/playwright-tests/e2e/poms/automations.ts","line":114,"column":70,"function":"AutomationRulesPage.deleteAutomationRule"}]}
{"type":"after","callId":"expect@96","endTime":124563.574,"annotations":[]}
{"type":"before","callId":"pw:api@97","parentId":"hook@92","startTime":124564.954,"class":"Test","method":"step","apiName":"locator.click","params":{"selector":"internal:testid=[data-cy=\"automation-rules-settings-link\"s]","strict":"true"},"stack":[{"file":"/home/neetoci/neeto-chat-web/playwright-tests/e2e/poms/automations.ts","line":122,"column":8,"function":"AutomationRulesPage.deleteAutomationRule"}]}
{"type":"after","callId":"pw:api@97","endTime":125512.06,"annotations":[]}
{"type":"before","callId":"expect@98","parentId":"hook@92","startTime":125513.211,"class":"Test","method":"step","apiName":"expect.toBeHidden","params":{"expected":"Object"},"stack":[{"file":"/home/neetoci/neeto-chat-web/playwright-tests/e2e/poms/automations.ts","line":124,"column":70,"function":"AutomationRulesPage.deleteAutomationRule"}]}
{"type":"after","callId":"expect@98","endTime":125539.681,"annotations":[]}
{"type":"before","callId":"pw:api@99","parentId":"hook@92","startTime":125541.566,"class":"Test","method":"step","apiName":"locator.click","params":{"selector":"internal:role=cell[name=\"Send new conversations to Slack general channel\"i] >> internal:testid=[data-cy=\"nui-dropdown-icon\"s]","strict":"true"},"stack":[{"file":"/home/neetoci/neeto-chat-web/playwright-tests/e2e/poms/automations.ts","line":131,"column":8,"function":"AutomationRulesPage.deleteAutomationRule"}]}
{"type":"after","callId":"pw:api@99","endTime":135615.177,"annotations":[],"error":{"name":"","message":"TimeoutError: locator.click: Timeout 10000ms exceeded.\nCall log:\n\u001b[2m  - waiting for getByRole('cell', { name: 'Send new conversations to Slack general channel' }).getByTestId('nui-dropdown-icon')\u001b[22m\n","stack":"TimeoutError: locator.click: Timeout 10000ms exceeded.\nCall log:\n\u001b[2m  - waiting for getByRole('cell', { name: 'Send new conversations to Slack general channel' }).getByTestId('nui-dropdown-icon')\u001b[22m\n\n    at AutomationRulesPage.deleteAutomationRule (/home/neetoci/neeto-chat-web/playwright-tests/e2e/poms/automations.ts:131:8)\n    at /home/neetoci/neeto-chat-web/playwright-tests/e2e/tests/integrations/slack.spec.ts:85:7"}}
{"type":"error","message":"TimeoutError: locator.click: Timeout 10000ms exceeded.\nCall log:\n\u001b[2m  - waiting for getByRole('cell', { name: 'Send new conversations to Slack general channel' }).getByTestId('nui-dropdown-icon')\u001b[22m\n","stack":[{"file":"/home/neetoci/neeto-chat-web/playwright-tests/e2e/poms/automations.ts","line":131,"column":8,"function":"AutomationRulesPage.deleteAutomationRule"},{"file":"/home/neetoci/neeto-chat-web/playwright-tests/e2e/tests/integrations/slack.spec.ts","line":85,"column":7}]}
{"type":"after","callId":"hook@92","endTime":135615.393,"annotations":[],"error":{"name":"","message":"TimeoutError: locator.click: Timeout 10000ms exceeded.\nCall log:\n\u001b[2m  - waiting for getByRole('cell', { name: 'Send new conversations to Slack general channel' }).getByTestId('nui-dropdown-icon')\u001b[22m\n","stack":"TimeoutError: locator.click: Timeout 10000ms exceeded.\nCall log:\n\u001b[2m  - waiting for getByRole('cell', { name: 'Send new conversations to Slack general channel' }).getByTestId('nui-dropdown-icon')\u001b[22m\n\n    at AutomationRulesPage.deleteAutomationRule (/home/neetoci/neeto-chat-web/playwright-tests/e2e/poms/automations.ts:131:8)\n    at /home/neetoci/neeto-chat-web/playwright-tests/e2e/tests/integrations/slack.spec.ts:85:7"}}
{"type":"before","callId":"fixture@100","parentId":"hook@89","startTime":135616.286,"class":"Test","method":"step","apiName":"fixture: conversationsPage","params":{},"stack":[{"file":"/home/neetoci/neeto-chat-web/playwright-tests/e2e/fixtures/index.ts","line":9,"column":4}]}
{"type":"after","callId":"fixture@100","endTime":135616.502,"annotations":[]}
{"type":"before","callId":"fixture@101","parentId":"hook@89","startTime":135616.751,"class":"Test","method":"step","apiName":"fixture: conversationsApis","params":{},"stack":[{"file":"/home/neetoci/neeto-chat-web/playwright-tests/e2e/fixtures/index.ts","line":9,"column":4}]}
{"type":"after","callId":"fixture@101","endTime":135616.827,"annotations":[]}
{"type":"before","callId":"fixture@102","parentId":"hook@89","startTime":135617.104,"class":"Test","method":"step","apiName":"fixture: contactApis","params":{},"stack":[{"file":"/home/neetoci/neeto-chat-web/playwright-tests/e2e/fixtures/index.ts","line":9,"column":4}]}
{"type":"after","callId":"fixture@102","endTime":135617.175,"annotations":[]}
{"type":"before","callId":"fixture@103","parentId":"hook@89","startTime":135617.409,"class":"Test","method":"step","apiName":"fixture: automationRulesPage","params":{},"stack":[{"file":"/home/neetoci/neeto-chat-web/playwright-tests/e2e/fixtures/index.ts","line":9,"column":4}]}
{"type":"after","callId":"fixture@103","endTime":135617.477,"annotations":[]}
{"type":"before","callId":"fixture@104","parentId":"hook@89","startTime":135617.707,"class":"Test","method":"step","apiName":"fixture: slackPage","params":{},"stack":[{"file":"/home/neetoci/neeto-chat-web/playwright-tests/e2e/fixtures/index.ts","line":9,"column":4}]}
{"type":"after","callId":"fixture@104","endTime":135617.785,"annotations":[]}
{"type":"before","callId":"fixture@105","parentId":"hook@89","startTime":135617.993,"class":"Test","method":"step","apiName":"fixture: neetoPlaywrightUtilities","params":{},"stack":[{"file":"/home/neetoci/neeto-chat-web/playwright-tests/e2e/fixtures/index.ts","line":7,"column":4}]}
{"type":"after","callId":"fixture@105","endTime":135618.039,"annotations":[]}
{"type":"before","callId":"fixture@106","parentId":"hook@89","startTime":135618.345,"class":"Test","method":"step","apiName":"fixture: request","params":{},"stack":[]}
{"type":"before","callId":"pw:api@107","parentId":"fixture@106","startTime":135748.059,"class":"Test","method":"step","apiName":"apiRequestContext.dispose","params":{},"stack":[]}
{"type":"after","callId":"pw:api@107","endTime":135749.488,"annotations":[]}
{"type":"after","callId":"fixture@106","endTime":135749.6,"annotations":[]}
{"type":"before","callId":"fixture@108","parentId":"hook@89","startTime":135750.06,"class":"Test","method":"step","apiName":"fixture: page","params":{},"stack":[{"file":"/home/neetoci/neeto-chat-web/playwright-tests/e2e/fixtures/index.ts","line":7,"column":4}]}
{"type":"after","callId":"fixture@108","endTime":135750.197,"annotations":[]}
{"type":"before","callId":"fixture@109","parentId":"hook@89","startTime":135750.486,"class":"Test","method":"step","apiName":"fixture: page","params":{},"stack":[]}
{"type":"after","callId":"fixture@109","endTime":135750.607,"annotations":[]}
{"type":"before","callId":"fixture@110","parentId":"hook@89","startTime":135750.924,"class":"Test","method":"step","apiName":"fixture: context","params":{},"stack":[]}
{"type":"after","callId":"fixture@110","endTime":135751.057,"annotations":[]}
{"type":"before","callId":"pw:api@111","parentId":"hook@89","startTime":143663.422,"class":"Test","method":"step","apiName":"video.saveAs","params":{"path":"/home/neetoci/neeto-chat-web/playwright-tests/test-results/integrations-slack-Verify--54bf8-is-send-via-automation-rule-chromium-retry1/video.webm"},"stack":[]}
{"type":"before","callId":"pw:api@112","parentId":"hook@89","startTime":143664.421,"class":"Test","method":"step","apiName":"video.saveAs","params":{"path":"/home/neetoci/neeto-chat-web/playwright-tests/test-results/integrations-slack-Verify--54bf8-is-send-via-automation-rule-chromium-retry1/video-1.webm"},"stack":[]}
{"type":"after","callId":"pw:api@111","endTime":143665.706,"annotations":[]}
{"type":"after","callId":"pw:api@112","endTime":143713.06,"annotations":[]}
{"type":"before","callId":"_attach@1","startTime":143723.023,"class":"Test","method":"step","apiName":"_attach \"_error-context-0\"","params":{},"stack":[]}
{"type":"after","callId":"_attach@1","endTime":143723.035,"attachments":[{"name":"_error-context-0","contentType":"text/markdown","sha1":"fe1f937ce87eb2f8fa240a8dd226b908ef8a3b90"}]}
{"type":"before","callId":"_attach@2","startTime":143724.234,"class":"Test","method":"step","apiName":"_attach \"_error-context-1\"","params":{},"stack":[]}
{"type":"after","callId":"_attach@2","endTime":143724.239,"attachments":[{"name":"_error-context-1","contentType":"text/markdown","sha1":"05602ce54f3f1238baaf72adea2c4a2cb2c29392"}]}
{"type":"after","callId":"hook@89","endTime":143725.3,"attachments":[{"name":"screenshot","contentType":"image/png","sha1":"2574dcd306b43a68279b1ec34d09fd0a554ece3f"},{"name":"screenshot","contentType":"image/png","sha1":"e4a6c2d0a323cc9010718fe68405ae38336c3572"},{"name":"video","contentType":"video/webm","sha1":"c33f760ac20afd882733b664710d90197a40644d"},{"name":"video","contentType":"video/webm","sha1":"25efc6c0b2a6b8deff4ea6d8c66ef8b29ca8732f"}],"annotations":[],"error":{"name":"","message":"TimeoutError: locator.click: Timeout 10000ms exceeded.\nCall log:\n\u001b[2m  - waiting for getByRole('cell', { name: 'Send new conversations to Slack general channel' }).getByTestId('nui-dropdown-icon')\u001b[22m\n","stack":"TimeoutError: locator.click: Timeout 10000ms exceeded.\nCall log:\n\u001b[2m  - waiting for getByRole('cell', { name: 'Send new conversations to Slack general channel' }).getByTestId('nui-dropdown-icon')\u001b[22m\n\n    at AutomationRulesPage.deleteAutomationRule (/home/neetoci/neeto-chat-web/playwright-tests/e2e/poms/automations.ts:131:8)\n    at /home/neetoci/neeto-chat-web/playwright-tests/e2e/tests/integrations/slack.spec.ts:85:7"}}
{"type":"before","callId":"hook@113","startTime":143725.665,"class":"Test","method":"step","apiName":"Worker Cleanup","params":{},"stack":[]}
{"type":"before","callId":"fixture@114","parentId":"hook@113","startTime":143726.455,"class":"Test","method":"step","apiName":"fixture: t","params":{},"stack":[{"file":"/home/neetoci/neeto-chat-web/playwright-tests/e2e/fixtures/index.ts","line":8,"column":4}]}
{"type":"after","callId":"fixture@114","endTime":143726.531,"annotations":[]}
{"type":"before","callId":"fixture@115","parentId":"hook@113","startTime":143726.989,"class":"Test","method":"step","apiName":"fixture: browser","params":{},"stack":[{"file":"/home/neetoci/neeto-chat-web/playwright-tests/node_modules/@bigbinary/neeto-playwright-commons/build/compiled/fixtures/stealth.js","line":4,"column":21}]}
{"type":"after","callId":"fixture@115","endTime":143762.417,"annotations":[]}
{"type":"before","callId":"fixture@116","parentId":"hook@113","startTime":143762.724,"class":"Test","method":"step","apiName":"fixture: browser","params":{},"stack":[]}
{"type":"after","callId":"fixture@116","endTime":143763.578,"annotations":[]}
{"type":"before","callId":"fixture@117","parentId":"hook@113","startTime":143763.996,"class":"Test","method":"step","apiName":"fixture: i18n","params":{},"stack":[{"file":"/home/neetoci/neeto-chat-web/playwright-tests/e2e/fixtures/index.ts","line":8,"column":4}]}
{"type":"after","callId":"fixture@117","endTime":143764.045,"annotations":[]}
{"type":"after","callId":"hook@113","endTime":143764.24,"annotations":[]}